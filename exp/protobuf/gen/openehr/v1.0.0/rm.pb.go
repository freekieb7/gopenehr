// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: openehr/v1.0.0/rm.proto

package v1_1_0

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The EHR object is the root object and access point of an EHR for a subject of care.
type Ehr struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identifier of the logical EHR management system in which this EHR was created.
	SystemId *HierObjectId `protobuf:"bytes,1,opt,name=system_id,json=systemId,proto3" json:"system_id,omitempty"`
	// The unique identifier of this EHR.
	EhrId *HierObjectId `protobuf:"bytes,2,opt,name=ehr_id,json=ehrId,proto3" json:"ehr_id,omitempty"`
	// List of contributions causing changes to this EHR. Each contribution contains a list of versions, which may include references to any number of VERSION instances, i.e. items of type VERSIONED_COMPOSITION and VERSIONED_FOLDER.
	Contributions []*ObjectRef `protobuf:"bytes,3,rep,name=contributions,proto3" json:"contributions,omitempty"`
	// Reference to EHR_STATUS object for this EHR.
	EhrStatus *ObjectRef `protobuf:"bytes,4,opt,name=ehr_status,json=ehrStatus,proto3" json:"ehr_status,omitempty"`
	// Reference to EHR_ACCESS object for this EHR.
	EhrAccess *ObjectRef `protobuf:"bytes,5,opt,name=ehr_access,json=ehrAccess,proto3" json:"ehr_access,omitempty"`
	// Master list of all Versioned Composition references in this EHR.
	Compositions []*ObjectRef `protobuf:"bytes,6,rep,name=compositions,proto3" json:"compositions,omitempty"`
	// Optional directory structure for this EHR. If present, this is a reference to the first member of folders.
	Directoyr *ObjectRef `protobuf:"bytes,7,opt,name=directoyr,proto3,oneof" json:"directoyr,omitempty"`
	// Time of creation of the EHR.
	TimeCreated *DvDateTime `protobuf:"bytes,8,opt,name=time_created,json=timeCreated,proto3" json:"time_created,omitempty"`
	// Optional additional Folder structures for this EHR. If set, the directory attribute refers to the first member.
	Folders []*ObjectRef `protobuf:"bytes,9,rep,name=folders,proto3" json:"folders,omitempty"`
	// Optional list of tags associated with this EHR. Tag target values can only be within the same EHR.
	Tags          []*ObjectRef `protobuf:"bytes,10,rep,name=tags,proto3" json:"tags,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Ehr) Reset() {
	*x = Ehr{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Ehr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ehr) ProtoMessage() {}

func (x *Ehr) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ehr.ProtoReflect.Descriptor instead.
func (*Ehr) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{0}
}

func (x *Ehr) GetSystemId() *HierObjectId {
	if x != nil {
		return x.SystemId
	}
	return nil
}

func (x *Ehr) GetEhrId() *HierObjectId {
	if x != nil {
		return x.EhrId
	}
	return nil
}

func (x *Ehr) GetContributions() []*ObjectRef {
	if x != nil {
		return x.Contributions
	}
	return nil
}

func (x *Ehr) GetEhrStatus() *ObjectRef {
	if x != nil {
		return x.EhrStatus
	}
	return nil
}

func (x *Ehr) GetEhrAccess() *ObjectRef {
	if x != nil {
		return x.EhrAccess
	}
	return nil
}

func (x *Ehr) GetCompositions() []*ObjectRef {
	if x != nil {
		return x.Compositions
	}
	return nil
}

func (x *Ehr) GetDirectoyr() *ObjectRef {
	if x != nil {
		return x.Directoyr
	}
	return nil
}

func (x *Ehr) GetTimeCreated() *DvDateTime {
	if x != nil {
		return x.TimeCreated
	}
	return nil
}

func (x *Ehr) GetFolders() []*ObjectRef {
	if x != nil {
		return x.Folders
	}
	return nil
}

func (x *Ehr) GetTags() []*ObjectRef {
	if x != nil {
		return x.Tags
	}
	return nil
}

// Content of one version in a VERSIONED_COMPOSITION. A Composition is considered the unit of modification of the record, the unit of transmission in record Extracts, and the unit of attestation by authorising clinicians. In this latter sense, it may be considered equivalent to a signed document.
type Composition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Mandatory indicator of the localised language in which this Composition is written.
	// Coded from openEHR Code Set languages.
	// The language of an Entry if different from the Composition is indicated in ENTRY.language.
	Language *CodePhrase `protobuf:"bytes,7,opt,name=language,proto3" json:"language,omitempty"`
	// Name of territory in which this Composition was written.
	// Coded from openEHR countries code set, which is an expression of the ISO 3166 standard.
	Territory *CodePhrase `protobuf:"bytes,8,opt,name=territory,proto3" json:"territory,omitempty"`
	// Temporal category of this Composition, i.e.
	//
	// - 431|persistent| - of potential life-time validity;
	// - 451|episodic| - valid over the life of a care episode;
	// - 433|event| - valid at the time of recording (long-term validity requires subsequent clinical assessment).
	//
	// or any other code defined in the openEHR terminology group 'category'.
	Category *DvCodedText `protobuf:"bytes,9,opt,name=category,proto3" json:"category,omitempty"`
	// The clinical session context of this Composition, i.e. the contextual attributes of the clinical session.
	Context *EventContext `protobuf:"bytes,10,opt,name=context,proto3,oneof" json:"context,omitempty"`
	// The person primarily responsible for the content of the Composition (but not necessarily its committal into the EHR system).
	// This is the identifier which should appear on the screen.
	// It may or may not be the person who entered the data.
	// When it is the patient, the special self instance of PARTY_PROXY will be used.
	Composer *PartyProxy `protobuf:"bytes,11,opt,name=composer,proto3" json:"composer,omitempty"`
	// The content of this Composition.
	Content       []*ContentItem `protobuf:"bytes,12,rep,name=content,proto3" json:"content,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Composition) Reset() {
	*x = Composition{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Composition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Composition) ProtoMessage() {}

func (x *Composition) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Composition.ProtoReflect.Descriptor instead.
func (*Composition) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{1}
}

func (x *Composition) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Composition) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *Composition) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Composition) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Composition) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *Composition) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *Composition) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *Composition) GetTerritory() *CodePhrase {
	if x != nil {
		return x.Territory
	}
	return nil
}

func (x *Composition) GetCategory() *DvCodedText {
	if x != nil {
		return x.Category
	}
	return nil
}

func (x *Composition) GetContext() *EventContext {
	if x != nil {
		return x.Context
	}
	return nil
}

func (x *Composition) GetComposer() *PartyProxy {
	if x != nil {
		return x.Composer
	}
	return nil
}

func (x *Composition) GetContent() []*ContentItem {
	if x != nil {
		return x.Content
	}
	return nil
}

// Documents the context information of a healthcare event involving the subject of care and the health system. The context information recorded here are independent of the attributes recorded in the version audit, which document the system interaction context, i.e. the context of a user interacting with the health record system. Healthcare events include patient contacts, and any other business activity, such as pathology investigations which take place on behalf of the patient.
type EventContext struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	StartTime       *DvDateTime            `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	EndTime         *DvDateTime            `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3,oneof" json:"end_time,omitempty"`
	Location        *string                `protobuf:"bytes,3,opt,name=location,proto3,oneof" json:"location,omitempty"`
	Setting         *DvCodedText           `protobuf:"bytes,4,opt,name=setting,proto3" json:"setting,omitempty"`
	OtherContext    *ItemStructure         `protobuf:"bytes,5,opt,name=other_context,json=otherContext,proto3,oneof" json:"other_context,omitempty"`
	PartyIdentified *PartyIdentified       `protobuf:"bytes,6,opt,name=party_identified,json=partyIdentified,proto3,oneof" json:"party_identified,omitempty"`
	Participations  []*Participation       `protobuf:"bytes,7,rep,name=participations,proto3" json:"participations,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *EventContext) Reset() {
	*x = EventContext{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventContext) ProtoMessage() {}

func (x *EventContext) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventContext.ProtoReflect.Descriptor instead.
func (*EventContext) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{2}
}

func (x *EventContext) GetStartTime() *DvDateTime {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *EventContext) GetEndTime() *DvDateTime {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *EventContext) GetLocation() string {
	if x != nil && x.Location != nil {
		return *x.Location
	}
	return ""
}

func (x *EventContext) GetSetting() *DvCodedText {
	if x != nil {
		return x.Setting
	}
	return nil
}

func (x *EventContext) GetOtherContext() *ItemStructure {
	if x != nil {
		return x.OtherContext
	}
	return nil
}

func (x *EventContext) GetPartyIdentified() *PartyIdentified {
	if x != nil {
		return x.PartyIdentified
	}
	return nil
}

func (x *EventContext) GetParticipations() []*Participation {
	if x != nil {
		return x.Participations
	}
	return nil
}

// Abstract ancestor of all concrete content types.
type ContentItem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Item:
	//
	//	*ContentItem_Section
	//	*ContentItem_Entry
	//	*ContentItem_Observation
	//	*ContentItem_Evaluation
	//	*ContentItem_Instruction
	//	*ContentItem_Action
	Item          isContentItem_Item `protobuf_oneof:"item"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContentItem) Reset() {
	*x = ContentItem{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContentItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContentItem) ProtoMessage() {}

func (x *ContentItem) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContentItem.ProtoReflect.Descriptor instead.
func (*ContentItem) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{3}
}

func (x *ContentItem) GetItem() isContentItem_Item {
	if x != nil {
		return x.Item
	}
	return nil
}

func (x *ContentItem) GetSection() *Section {
	if x != nil {
		if x, ok := x.Item.(*ContentItem_Section); ok {
			return x.Section
		}
	}
	return nil
}

func (x *ContentItem) GetEntry() *AdminEntry {
	if x != nil {
		if x, ok := x.Item.(*ContentItem_Entry); ok {
			return x.Entry
		}
	}
	return nil
}

func (x *ContentItem) GetObservation() *Observation {
	if x != nil {
		if x, ok := x.Item.(*ContentItem_Observation); ok {
			return x.Observation
		}
	}
	return nil
}

func (x *ContentItem) GetEvaluation() *Evaluation {
	if x != nil {
		if x, ok := x.Item.(*ContentItem_Evaluation); ok {
			return x.Evaluation
		}
	}
	return nil
}

func (x *ContentItem) GetInstruction() *Instruction {
	if x != nil {
		if x, ok := x.Item.(*ContentItem_Instruction); ok {
			return x.Instruction
		}
	}
	return nil
}

func (x *ContentItem) GetAction() *Action {
	if x != nil {
		if x, ok := x.Item.(*ContentItem_Action); ok {
			return x.Action
		}
	}
	return nil
}

type isContentItem_Item interface {
	isContentItem_Item()
}

type ContentItem_Section struct {
	Section *Section `protobuf:"bytes,1,opt,name=section,proto3,oneof"`
}

type ContentItem_Entry struct {
	Entry *AdminEntry `protobuf:"bytes,2,opt,name=entry,proto3,oneof"`
}

type ContentItem_Observation struct {
	Observation *Observation `protobuf:"bytes,3,opt,name=observation,proto3,oneof"`
}

type ContentItem_Evaluation struct {
	Evaluation *Evaluation `protobuf:"bytes,4,opt,name=evaluation,proto3,oneof"`
}

type ContentItem_Instruction struct {
	Instruction *Instruction `protobuf:"bytes,5,opt,name=instruction,proto3,oneof"`
}

type ContentItem_Action struct {
	Action *Action `protobuf:"bytes,6,opt,name=action,proto3,oneof"`
}

func (*ContentItem_Section) isContentItem_Item() {}

func (*ContentItem_Entry) isContentItem_Item() {}

func (*ContentItem_Observation) isContentItem_Item() {}

func (*ContentItem_Evaluation) isContentItem_Item() {}

func (*ContentItem_Instruction) isContentItem_Item() {}

func (*ContentItem_Action) isContentItem_Item() {}

// Represents a heading in a heading structure, or section tree. Created according to archetyped structures for typical headings such as SOAP, physical examination, but also pathology result heading structures. Should not be used instead of ENTRY hierarchical structures.
type Section struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Ordered list of content items under this section, which may include:
	//
	// - more SECTIONs;
	// - ENTRYs.
	Items         []*ContentItem `protobuf:"bytes,7,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Section) Reset() {
	*x = Section{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Section) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Section) ProtoMessage() {}

func (x *Section) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Section.ProtoReflect.Descriptor instead.
func (*Section) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{4}
}

func (x *Section) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Section) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *Section) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Section) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Section) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *Section) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *Section) GetItems() []*ContentItem {
	if x != nil {
		return x.Items
	}
	return nil
}

// Entry subtype for administrative information, i.e. information about setting up the clinical process, but not itself clinically relevant. Archetypes will define contained information.
//
// Used for administrative details of admission, episode, ward location, discharge, appointment (if not stored in a practice management or appointments system).
//
// Not to be used for any clinically significant information.
type AdminEntry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
	Language *CodePhrase `protobuf:"bytes,7,opt,name=language,proto3" json:"language,omitempty"`
	// Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
	Encoding *CodePhrase `protobuf:"bytes,8,opt,name=encoding,proto3" json:"encoding,omitempty"`
	// Other participations at ENTRY level.
	OtherParticipations []*Participation `protobuf:"bytes,9,rep,name=other_participations,json=otherParticipations,proto3" json:"other_participations,omitempty"`
	// Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
	WorkflowId *ObjectRef `protobuf:"bytes,10,opt,name=workflow_id,json=workflowId,proto3,oneof" json:"workflow_id,omitempty"`
	// Id of human subject of this ENTRY, e.g.:
	//
	// - organ donor
	// - foetus
	// - a family member
	// - another clinically relevant person.
	Subject *PartyProxy `protobuf:"bytes,11,opt,name=subject,proto3" json:"subject,omitempty"`
	// Optional identification of provider of the information in this ENTRY, which might be:
	//
	// - the patient
	// - a patient agent, e.g. parent, guardian
	// - the clinician
	// - a device or software
	//
	// Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
	Provider *PartyProxy `protobuf:"bytes,12,opt,name=provider,proto3,oneof" json:"provider,omitempty"`
	// Content of the Admin Entry. The data of the Entry; modelled in archetypes.
	Data          *ItemStructure `protobuf:"bytes,13,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AdminEntry) Reset() {
	*x = AdminEntry{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdminEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdminEntry) ProtoMessage() {}

func (x *AdminEntry) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdminEntry.ProtoReflect.Descriptor instead.
func (*AdminEntry) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{5}
}

func (x *AdminEntry) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *AdminEntry) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *AdminEntry) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *AdminEntry) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *AdminEntry) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *AdminEntry) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *AdminEntry) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *AdminEntry) GetEncoding() *CodePhrase {
	if x != nil {
		return x.Encoding
	}
	return nil
}

func (x *AdminEntry) GetOtherParticipations() []*Participation {
	if x != nil {
		return x.OtherParticipations
	}
	return nil
}

func (x *AdminEntry) GetWorkflowId() *ObjectRef {
	if x != nil {
		return x.WorkflowId
	}
	return nil
}

func (x *AdminEntry) GetSubject() *PartyProxy {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *AdminEntry) GetProvider() *PartyProxy {
	if x != nil {
		return x.Provider
	}
	return nil
}

func (x *AdminEntry) GetData() *ItemStructure {
	if x != nil {
		return x.Data
	}
	return nil
}

// Entry subtype for all clinical data in the past or present, i.e. which (by the time it is recorded) has already occurred. OBSERVATION data is expressed using the class HISTORY<T>, which guarantees that it is situated in time. OBSERVATION is used for all notionally objective (i.e. measured in some way) observations of phenomena, and patient-reported phenomena, e.g. pain.
//
// Not to be used for recording opinion or future statements of any kind, including instructions, intentions, plans etc.
type Observation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
	Language *CodePhrase `protobuf:"bytes,7,opt,name=language,proto3" json:"language,omitempty"`
	// Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
	Encoding *CodePhrase `protobuf:"bytes,8,opt,name=encoding,proto3" json:"encoding,omitempty"`
	// Other participations at ENTRY level.
	OtherParticipations []*Participation `protobuf:"bytes,9,rep,name=other_participations,json=otherParticipations,proto3" json:"other_participations,omitempty"`
	// Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
	WorkflowId *ObjectRef `protobuf:"bytes,10,opt,name=workflow_id,json=workflowId,proto3,oneof" json:"workflow_id,omitempty"`
	// Id of human subject of this ENTRY, e.g.:
	//
	// - organ donor
	// - foetus
	// - a family member
	// - another clinically relevant person.
	Subject *PartyProxy `protobuf:"bytes,11,opt,name=subject,proto3" json:"subject,omitempty"`
	// Optional identification of provider of the information in this ENTRY, which might be:
	//
	// - the patient
	// - a patient agent, e.g. parent, guardian
	// - the clinician
	// - a device or software
	//
	// Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
	Provider *PartyProxy `protobuf:"bytes,12,opt,name=provider,proto3,oneof" json:"provider,omitempty"`
	// Description of the method (i.e. how) the information in this entry was arrived at. For OBSERVATIONs, this is a description of the method or instrument used. For EVALUATIONs, how the evaluation was arrived at. For INSTRUCTIONs, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process.
	Protocol *ItemStructure `protobuf:"bytes,13,opt,name=protocol,proto3,oneof" json:"protocol,omitempty"`
	// Optional external identifier of guideline creating this Entry if relevant.
	GuidelineId *ObjectRef `protobuf:"bytes,14,opt,name=guideline_id,json=guidelineId,proto3,oneof" json:"guideline_id,omitempty"`
	// The data of this observation, in the form of a history of values which may be of any complexity.
	Data *HistoryItemStructure `protobuf:"bytes,15,opt,name=data,proto3" json:"data,omitempty"`
	// Optional recording of the state of subject of this observation during the observation process, in the form of a separate history of values which may be of any complexity. State may also be recorded within the History of the data attribute.
	State         *HistoryItemStructure `protobuf:"bytes,16,opt,name=state,proto3,oneof" json:"state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Observation) Reset() {
	*x = Observation{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Observation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Observation) ProtoMessage() {}

func (x *Observation) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Observation.ProtoReflect.Descriptor instead.
func (*Observation) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{6}
}

func (x *Observation) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Observation) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *Observation) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Observation) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Observation) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *Observation) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *Observation) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *Observation) GetEncoding() *CodePhrase {
	if x != nil {
		return x.Encoding
	}
	return nil
}

func (x *Observation) GetOtherParticipations() []*Participation {
	if x != nil {
		return x.OtherParticipations
	}
	return nil
}

func (x *Observation) GetWorkflowId() *ObjectRef {
	if x != nil {
		return x.WorkflowId
	}
	return nil
}

func (x *Observation) GetSubject() *PartyProxy {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *Observation) GetProvider() *PartyProxy {
	if x != nil {
		return x.Provider
	}
	return nil
}

func (x *Observation) GetProtocol() *ItemStructure {
	if x != nil {
		return x.Protocol
	}
	return nil
}

func (x *Observation) GetGuidelineId() *ObjectRef {
	if x != nil {
		return x.GuidelineId
	}
	return nil
}

func (x *Observation) GetData() *HistoryItemStructure {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *Observation) GetState() *HistoryItemStructure {
	if x != nil {
		return x.State
	}
	return nil
}

// Entry type for evaluation statements. Used for all kinds of statements which evaluate other information, such as interpretations of observations, diagnoses, differential diagnoses, hypotheses, risk assessments, goals and plans.
//
// Should not be used for actionable statements such as medication orders - these are represented using the INSTRUCTION type.
type Evaluation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
	Language *CodePhrase `protobuf:"bytes,7,opt,name=language,proto3" json:"language,omitempty"`
	// Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
	Encoding *CodePhrase `protobuf:"bytes,8,opt,name=encoding,proto3" json:"encoding,omitempty"`
	// Other participations at ENTRY level.
	OtherParticipations []*Participation `protobuf:"bytes,9,rep,name=other_participations,json=otherParticipations,proto3" json:"other_participations,omitempty"`
	// Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
	WorkflowId *ObjectRef `protobuf:"bytes,10,opt,name=workflow_id,json=workflowId,proto3,oneof" json:"workflow_id,omitempty"`
	// Id of human subject of this ENTRY, e.g.:
	//
	// - organ donor
	// - foetus
	// - a family member
	// - another clinically relevant person.
	Subject *PartyProxy `protobuf:"bytes,11,opt,name=subject,proto3" json:"subject,omitempty"`
	// Optional identification of provider of the information in this ENTRY, which might be:
	//
	// - the patient
	// - a patient agent, e.g. parent, guardian
	// - the clinician
	// - a device or software
	//
	// Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
	Provider *PartyProxy `protobuf:"bytes,12,opt,name=provider,proto3,oneof" json:"provider,omitempty"`
	// Description of the method (i.e. how) the information in this entry was arrived at. For OBSERVATIONs, this is a description of the method or instrument used. For EVALUATIONs, how the evaluation was arrived at. For INSTRUCTIONs, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process.
	Protocol *ItemStructure `protobuf:"bytes,13,opt,name=protocol,proto3,oneof" json:"protocol,omitempty"`
	// Optional external identifier of guideline creating this Entry if relevant.
	GuidelineId *ObjectRef `protobuf:"bytes,14,opt,name=guideline_id,json=guidelineId,proto3,oneof" json:"guideline_id,omitempty"`
	// The data of this evaluation, in the form of a spatial data structure.
	Data          *ItemStructure `protobuf:"bytes,15,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Evaluation) Reset() {
	*x = Evaluation{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Evaluation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Evaluation) ProtoMessage() {}

func (x *Evaluation) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Evaluation.ProtoReflect.Descriptor instead.
func (*Evaluation) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{7}
}

func (x *Evaluation) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Evaluation) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *Evaluation) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Evaluation) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Evaluation) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *Evaluation) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *Evaluation) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *Evaluation) GetEncoding() *CodePhrase {
	if x != nil {
		return x.Encoding
	}
	return nil
}

func (x *Evaluation) GetOtherParticipations() []*Participation {
	if x != nil {
		return x.OtherParticipations
	}
	return nil
}

func (x *Evaluation) GetWorkflowId() *ObjectRef {
	if x != nil {
		return x.WorkflowId
	}
	return nil
}

func (x *Evaluation) GetSubject() *PartyProxy {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *Evaluation) GetProvider() *PartyProxy {
	if x != nil {
		return x.Provider
	}
	return nil
}

func (x *Evaluation) GetProtocol() *ItemStructure {
	if x != nil {
		return x.Protocol
	}
	return nil
}

func (x *Evaluation) GetGuidelineId() *ObjectRef {
	if x != nil {
		return x.GuidelineId
	}
	return nil
}

func (x *Evaluation) GetData() *ItemStructure {
	if x != nil {
		return x.Data
	}
	return nil
}

// Used to specify actions in the future. Enables simple and complex specifications to be expressed, including in a fully-computable workflow form. Used for any actionable statement such as medication and therapeutic orders, monitoring, recall and review. Enough details must be provided for the specification to be directly executed by an actor, either human or machine.
//
// Not to be used for plan items which are only specified in general terms.
type Instruction struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
	Language *CodePhrase `protobuf:"bytes,7,opt,name=language,proto3" json:"language,omitempty"`
	// Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
	Encoding *CodePhrase `protobuf:"bytes,8,opt,name=encoding,proto3" json:"encoding,omitempty"`
	// Other participations at ENTRY level.
	OtherParticipations []*Participation `protobuf:"bytes,9,rep,name=other_participations,json=otherParticipations,proto3" json:"other_participations,omitempty"`
	// Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
	WorkflowId *ObjectRef `protobuf:"bytes,10,opt,name=workflow_id,json=workflowId,proto3,oneof" json:"workflow_id,omitempty"`
	// Id of human subject of this ENTRY, e.g.:
	//
	// - organ donor
	// - foetus
	// - a family member
	// - another clinically relevant person.
	Subject *PartyProxy `protobuf:"bytes,11,opt,name=subject,proto3" json:"subject,omitempty"`
	// Optional identification of provider of the information in this ENTRY, which might be:
	//
	// - the patient
	// - a patient agent, e.g. parent, guardian
	// - the clinician
	// - a device or software
	//
	// Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
	Provider *PartyProxy `protobuf:"bytes,12,opt,name=provider,proto3,oneof" json:"provider,omitempty"`
	// Description of the method (i.e. how) the information in this entry was arrived at. For OBSERVATIONs, this is a description of the method or instrument used. For EVALUATIONs, how the evaluation was arrived at. For INSTRUCTIONs, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process.
	Protocol *ItemStructure `protobuf:"bytes,13,opt,name=protocol,proto3,oneof" json:"protocol,omitempty"`
	// Optional external identifier of guideline creating this Entry if relevant.
	GuidelineId *ObjectRef `protobuf:"bytes,14,opt,name=guideline_id,json=guidelineId,proto3,oneof" json:"guideline_id,omitempty"`
	// Mandatory human-readable version of what the Instruction is about.
	Narrative *DvText `protobuf:"bytes,15,opt,name=narrative,proto3" json:"narrative,omitempty"`
	// Optional expiry date/time to assist determination of when an Instruction can be assumed to have expired. This helps prevent false listing of Instructions as Active when they clearly must have been terminated in some way or other.
	ExpiryTime *DvDateTime `protobuf:"bytes,16,opt,name=expiry_time,json=expiryTime,proto3,oneof" json:"expiry_time,omitempty"`
	// Optional workflow engine executable expression of the Instruction.
	WfDefinition *DvParsable `protobuf:"bytes,17,opt,name=wf_definition,json=wfDefinition,proto3,oneof" json:"wf_definition,omitempty"`
	// List of all activities in Instruction.
	Activities    []*Activity `protobuf:"bytes,18,rep,name=activities,proto3" json:"activities,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Instruction) Reset() {
	*x = Instruction{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Instruction) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Instruction) ProtoMessage() {}

func (x *Instruction) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Instruction.ProtoReflect.Descriptor instead.
func (*Instruction) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{8}
}

func (x *Instruction) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Instruction) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *Instruction) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Instruction) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Instruction) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *Instruction) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *Instruction) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *Instruction) GetEncoding() *CodePhrase {
	if x != nil {
		return x.Encoding
	}
	return nil
}

func (x *Instruction) GetOtherParticipations() []*Participation {
	if x != nil {
		return x.OtherParticipations
	}
	return nil
}

func (x *Instruction) GetWorkflowId() *ObjectRef {
	if x != nil {
		return x.WorkflowId
	}
	return nil
}

func (x *Instruction) GetSubject() *PartyProxy {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *Instruction) GetProvider() *PartyProxy {
	if x != nil {
		return x.Provider
	}
	return nil
}

func (x *Instruction) GetProtocol() *ItemStructure {
	if x != nil {
		return x.Protocol
	}
	return nil
}

func (x *Instruction) GetGuidelineId() *ObjectRef {
	if x != nil {
		return x.GuidelineId
	}
	return nil
}

func (x *Instruction) GetNarrative() *DvText {
	if x != nil {
		return x.Narrative
	}
	return nil
}

func (x *Instruction) GetExpiryTime() *DvDateTime {
	if x != nil {
		return x.ExpiryTime
	}
	return nil
}

func (x *Instruction) GetWfDefinition() *DvParsable {
	if x != nil {
		return x.WfDefinition
	}
	return nil
}

func (x *Instruction) GetActivities() []*Activity {
	if x != nil {
		return x.Activities
	}
	return nil
}

// Defines a single activity within an Instruction, such as a medication administration.
type Activity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Timing of the activity, in the form of a parsable string. If used, the preferred syntax is ISO8601 'R' format, but other formats may be used including HL7 GTS.
	//
	// May be omitted if:
	// - timing is represented structurally in the description attribute (e.g. via archetyped elements), or
	// - unavailable, e.g. imported legacy data; in such cases, the INSTRUCTION.narrative should carry text that indicates the timing of its activities.
	Timing *DvParsable `protobuf:"bytes,7,opt,name=timing,proto3,oneof" json:"timing,omitempty"`
	// Perl-compliant regular expression pattern, enclosed in '//' delimiters, indicating the valid identifiers of archetypes for Actions corresponding to this Activity specification.
	//
	// Defaults to /.*/, meaning any archetype.
	ActionArchetypeId string `protobuf:"bytes,8,opt,name=action_archetype_id,json=actionArchetypeId,proto3" json:"action_archetype_id,omitempty"`
	// Description of the activity, in the form of an archetyped structure.
	Description   *ItemStructure `protobuf:"bytes,9,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Activity) Reset() {
	*x = Activity{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Activity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Activity) ProtoMessage() {}

func (x *Activity) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Activity.ProtoReflect.Descriptor instead.
func (*Activity) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{9}
}

func (x *Activity) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Activity) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *Activity) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Activity) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Activity) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *Activity) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *Activity) GetTiming() *DvParsable {
	if x != nil {
		return x.Timing
	}
	return nil
}

func (x *Activity) GetActionArchetypeId() string {
	if x != nil {
		return x.ActionArchetypeId
	}
	return ""
}

func (x *Activity) GetDescription() *ItemStructure {
	if x != nil {
		return x.Description
	}
	return nil
}

// Used to record a clinical action that has been performed, which may have been ad hoc, or due to the execution of an Activity in an Instruction workflow. Every Action corresponds to a careflow step of some kind or another.
type Action struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
	Language *CodePhrase `protobuf:"bytes,7,opt,name=language,proto3" json:"language,omitempty"`
	// Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
	Encoding *CodePhrase `protobuf:"bytes,8,opt,name=encoding,proto3" json:"encoding,omitempty"`
	// Other participations at ENTRY level.
	OtherParticipations []*Participation `protobuf:"bytes,9,rep,name=other_participations,json=otherParticipations,proto3" json:"other_participations,omitempty"`
	// Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
	WorkflowId *ObjectRef `protobuf:"bytes,10,opt,name=workflow_id,json=workflowId,proto3,oneof" json:"workflow_id,omitempty"`
	// Id of human subject of this ENTRY, e.g.:
	//
	// - organ donor
	// - foetus
	// - a family member
	// - another clinically relevant person.
	Subject *PartyProxy `protobuf:"bytes,11,opt,name=subject,proto3" json:"subject,omitempty"`
	// Optional identification of provider of the information in this ENTRY, which might be:
	//
	// - the patient
	// - a patient agent, e.g. parent, guardian
	// - the clinician
	// - a device or software
	//
	// Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
	Provider *PartyProxy `protobuf:"bytes,12,opt,name=provider,proto3,oneof" json:"provider,omitempty"`
	// Description of the method (i.e. how) the information in this entry was arrived at. For OBSERVATIONs, this is a description of the method or instrument used. For EVALUATIONs, how the evaluation was arrived at. For INSTRUCTIONs, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process.
	Protocol *ItemStructure `protobuf:"bytes,13,opt,name=protocol,proto3,oneof" json:"protocol,omitempty"`
	// Optional external identifier of guideline creating this Entry if relevant.
	GuidelineId *ObjectRef `protobuf:"bytes,14,opt,name=guideline_id,json=guidelineId,proto3,oneof" json:"guideline_id,omitempty"`
	// Point in time at which this action completed.
	Time *DvDateTime `protobuf:"bytes,15,opt,name=time,proto3" json:"time,omitempty"`
	// Details of transition in the Instruction state machine caused by this Action.
	IsmTransition *IsmTransition `protobuf:"bytes,16,opt,name=ism_transition,json=ismTransition,proto3" json:"ism_transition,omitempty"`
	// Details of the Instruction that caused this Action to be performed, if there was one.
	InstructionDetails *InstructionDetails `protobuf:"bytes,17,opt,name=instruction_details,json=instructionDetails,proto3,oneof" json:"instruction_details,omitempty"`
	// Description of the action that has been performed, in the form of an archetyped structure.
	Description   *ItemStructure `protobuf:"bytes,18,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Action) Reset() {
	*x = Action{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Action) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Action) ProtoMessage() {}

func (x *Action) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Action.ProtoReflect.Descriptor instead.
func (*Action) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{10}
}

func (x *Action) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Action) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *Action) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Action) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Action) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *Action) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *Action) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *Action) GetEncoding() *CodePhrase {
	if x != nil {
		return x.Encoding
	}
	return nil
}

func (x *Action) GetOtherParticipations() []*Participation {
	if x != nil {
		return x.OtherParticipations
	}
	return nil
}

func (x *Action) GetWorkflowId() *ObjectRef {
	if x != nil {
		return x.WorkflowId
	}
	return nil
}

func (x *Action) GetSubject() *PartyProxy {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *Action) GetProvider() *PartyProxy {
	if x != nil {
		return x.Provider
	}
	return nil
}

func (x *Action) GetProtocol() *ItemStructure {
	if x != nil {
		return x.Protocol
	}
	return nil
}

func (x *Action) GetGuidelineId() *ObjectRef {
	if x != nil {
		return x.GuidelineId
	}
	return nil
}

func (x *Action) GetTime() *DvDateTime {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *Action) GetIsmTransition() *IsmTransition {
	if x != nil {
		return x.IsmTransition
	}
	return nil
}

func (x *Action) GetInstructionDetails() *InstructionDetails {
	if x != nil {
		return x.InstructionDetails
	}
	return nil
}

func (x *Action) GetDescription() *ItemStructure {
	if x != nil {
		return x.Description
	}
	return nil
}

// Used to record details of the Instruction causing an Action.
type InstructionDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Reference to causing Instruction.
	InstructionId *LocatableRef `protobuf:"bytes,1,opt,name=instruction_id,json=instructionId,proto3" json:"instruction_id,omitempty"`
	// Identifier of Activity within Instruction, in the form of its archetype path.
	ActivityId string `protobuf:"bytes,2,opt,name=activity_id,json=activityId,proto3" json:"activity_id,omitempty"`
	// Various workflow engine state details, potentially including such things as:
	//
	// condition that fired to cause this Action to be done (with actual variables substituted);
	//
	// list of notifications which actually occurred (with all variables substituted);
	//
	// other workflow engine state.
	//
	// This specification does not currently define the actual structure or semantics of this field.
	WfDetails     *ItemStructure `protobuf:"bytes,3,opt,name=wf_details,json=wfDetails,proto3,oneof" json:"wf_details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstructionDetails) Reset() {
	*x = InstructionDetails{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstructionDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstructionDetails) ProtoMessage() {}

func (x *InstructionDetails) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstructionDetails.ProtoReflect.Descriptor instead.
func (*InstructionDetails) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{11}
}

func (x *InstructionDetails) GetInstructionId() *LocatableRef {
	if x != nil {
		return x.InstructionId
	}
	return nil
}

func (x *InstructionDetails) GetActivityId() string {
	if x != nil {
		return x.ActivityId
	}
	return ""
}

func (x *InstructionDetails) GetWfDetails() *ItemStructure {
	if x != nil {
		return x.WfDetails
	}
	return nil
}

// Model of a transition in the Instruction State Machine, caused by a careflow step. The attributes document the careflow step as well as the ISM transition.
type IsmTransition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ISM current state. Coded by openEHR terminology group Instruction states.
	CurrentState *DvCodedText `protobuf:"bytes,1,opt,name=current_state,json=currentState,proto3" json:"current_state,omitempty"`
	// The ISM transition which occurred to arrive in the current_state. Coded by openEHR terminology group Instruction transitions.
	Transition *DvCodedText `protobuf:"bytes,2,opt,name=transition,proto3,oneof" json:"transition,omitempty"`
	// The step in the careflow process which occurred as part of generating this action, e.g. dispense , start_administration. This attribute represents the clinical label for the activity, as opposed to current_state which represents the state machine (ISM) computable form. Defined in archetype.
	CareflowStep *DvCodedText `protobuf:"bytes,3,opt,name=careflow_step,json=careflowStep,proto3,oneof" json:"careflow_step,omitempty"`
	// Optional possibility of adding one or more reasons for this careflow step having been taken. Multiple reasons may occur in medication management for example.
	Reason        *DvText `protobuf:"bytes,4,opt,name=reason,proto3,oneof" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IsmTransition) Reset() {
	*x = IsmTransition{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IsmTransition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IsmTransition) ProtoMessage() {}

func (x *IsmTransition) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IsmTransition.ProtoReflect.Descriptor instead.
func (*IsmTransition) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{12}
}

func (x *IsmTransition) GetCurrentState() *DvCodedText {
	if x != nil {
		return x.CurrentState
	}
	return nil
}

func (x *IsmTransition) GetTransition() *DvCodedText {
	if x != nil {
		return x.Transition
	}
	return nil
}

func (x *IsmTransition) GetCareflowStep() *DvCodedText {
	if x != nil {
		return x.CareflowStep
	}
	return nil
}

func (x *IsmTransition) GetReason() *DvText {
	if x != nil {
		return x.Reason
	}
	return nil
}

// Version container for EHR_ACCESS instance.
type VersionedEhrAccess struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier of this version container in the form of a UID with no extension.
	// This id will be the same in all instances of the same container in a distributed environment,
	// meaning that it can be understood as the uid of the virtual version tree.
	Uid *HierObjectId `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
	OwnerId *ObjectRef `protobuf:"bytes,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Time of initial creation of this versioned object.
	TimeCreated   *DvDateTime `protobuf:"bytes,3,opt,name=time_created,json=timeCreated,proto3" json:"time_created,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersionedEhrAccess) Reset() {
	*x = VersionedEhrAccess{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersionedEhrAccess) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionedEhrAccess) ProtoMessage() {}

func (x *VersionedEhrAccess) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionedEhrAccess.ProtoReflect.Descriptor instead.
func (*VersionedEhrAccess) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{13}
}

func (x *VersionedEhrAccess) GetUid() *HierObjectId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *VersionedEhrAccess) GetOwnerId() *ObjectRef {
	if x != nil {
		return x.OwnerId
	}
	return nil
}

func (x *VersionedEhrAccess) GetTimeCreated() *DvDateTime {
	if x != nil {
		return x.TimeCreated
	}
	return nil
}

// A versioned EhrStatus object
type VersionedEhrStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier of this version container in the form of a UID with no extension.
	// This id will be the same in all instances of the same container in a distributed environment,
	// meaning that it can be understood as the uid of the virtual version tree.
	Uid *HierObjectId `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
	OwnerId *ObjectRef `protobuf:"bytes,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Time of initial creation of this versioned object.
	TimeCreated   *DvDateTime `protobuf:"bytes,3,opt,name=time_created,json=timeCreated,proto3" json:"time_created,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersionedEhrStatus) Reset() {
	*x = VersionedEhrStatus{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersionedEhrStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionedEhrStatus) ProtoMessage() {}

func (x *VersionedEhrStatus) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionedEhrStatus.ProtoReflect.Descriptor instead.
func (*VersionedEhrStatus) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{14}
}

func (x *VersionedEhrStatus) GetUid() *HierObjectId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *VersionedEhrStatus) GetOwnerId() *ObjectRef {
	if x != nil {
		return x.OwnerId
	}
	return nil
}

func (x *VersionedEhrStatus) GetTimeCreated() *DvDateTime {
	if x != nil {
		return x.TimeCreated
	}
	return nil
}

// Version-controlled composition abstraction, defined by inheriting VERSIONED_OBJECT<COMPOSITION>.
type VersionedFolder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier of this version container in the form of a UID with no extension.
	// This id will be the same in all instances of the same container in a distributed environment,
	// meaning that it can be understood as the uid of the virtual version tree.
	Uid *HierObjectId `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
	OwnerId *ObjectRef `protobuf:"bytes,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Time of initial creation of this versioned object.
	TimeCreated   *DvDateTime `protobuf:"bytes,3,opt,name=time_created,json=timeCreated,proto3" json:"time_created,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersionedFolder) Reset() {
	*x = VersionedFolder{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersionedFolder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionedFolder) ProtoMessage() {}

func (x *VersionedFolder) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionedFolder.ProtoReflect.Descriptor instead.
func (*VersionedFolder) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{15}
}

func (x *VersionedFolder) GetUid() *HierObjectId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *VersionedFolder) GetOwnerId() *ObjectRef {
	if x != nil {
		return x.OwnerId
	}
	return nil
}

func (x *VersionedFolder) GetTimeCreated() *DvDateTime {
	if x != nil {
		return x.TimeCreated
	}
	return nil
}

// Static type formed by binding generic parameter of VERSIONED_OBJECT<T> to PARTY.
type VersionedParty struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier of this version container in the form of a UID with no extension.
	// This id will be the same in all instances of the same container in a distributed environment,
	// meaning that it can be understood as the uid of the virtual version tree.
	Uid *HierObjectId `protobuf:"bytes,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
	OwnerId *ObjectRef `protobuf:"bytes,2,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	// Time of initial creation of this versioned object.
	TimeCreated   *DvDateTime `protobuf:"bytes,3,opt,name=time_created,json=timeCreated,proto3" json:"time_created,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersionedParty) Reset() {
	*x = VersionedParty{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersionedParty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionedParty) ProtoMessage() {}

func (x *VersionedParty) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionedParty.ProtoReflect.Descriptor instead.
func (*VersionedParty) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{16}
}

func (x *VersionedParty) GetUid() *HierObjectId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *VersionedParty) GetOwnerId() *ObjectRef {
	if x != nil {
		return x.OwnerId
	}
	return nil
}

func (x *VersionedParty) GetTimeCreated() *DvDateTime {
	if x != nil {
		return x.TimeCreated
	}
	return nil
}

// Ancestor class of identifiers of informational objects. Ids may be completely meaningless, in which case their only job is to refer to something, or may carry some information to do with the identified object.
//
// Object ids are used inside an object to identify that object. To identify another object in another service, use an OBJECT_REF, or else use a UID for local objects identified by UID. If none of the subtypes is suitable, direct instances of this class may be used.
type ObjectId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Id:
	//
	//	*ObjectId_HierObjectId
	//	*ObjectId_ObjectVersionId
	//	*ObjectId_ArchetypeId
	//	*ObjectId_TemplateId
	//	*ObjectId_TerminologyId
	//	*ObjectId_GenericId
	Id            isObjectId_Id `protobuf_oneof:"id"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ObjectId) Reset() {
	*x = ObjectId{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ObjectId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObjectId) ProtoMessage() {}

func (x *ObjectId) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObjectId.ProtoReflect.Descriptor instead.
func (*ObjectId) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{17}
}

func (x *ObjectId) GetId() isObjectId_Id {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *ObjectId) GetHierObjectId() *HierObjectId {
	if x != nil {
		if x, ok := x.Id.(*ObjectId_HierObjectId); ok {
			return x.HierObjectId
		}
	}
	return nil
}

func (x *ObjectId) GetObjectVersionId() *ObjectVersionId {
	if x != nil {
		if x, ok := x.Id.(*ObjectId_ObjectVersionId); ok {
			return x.ObjectVersionId
		}
	}
	return nil
}

func (x *ObjectId) GetArchetypeId() *ArchetypeId {
	if x != nil {
		if x, ok := x.Id.(*ObjectId_ArchetypeId); ok {
			return x.ArchetypeId
		}
	}
	return nil
}

func (x *ObjectId) GetTemplateId() *TemplateId {
	if x != nil {
		if x, ok := x.Id.(*ObjectId_TemplateId); ok {
			return x.TemplateId
		}
	}
	return nil
}

func (x *ObjectId) GetTerminologyId() *TerminologyId {
	if x != nil {
		if x, ok := x.Id.(*ObjectId_TerminologyId); ok {
			return x.TerminologyId
		}
	}
	return nil
}

func (x *ObjectId) GetGenericId() *GenericId {
	if x != nil {
		if x, ok := x.Id.(*ObjectId_GenericId); ok {
			return x.GenericId
		}
	}
	return nil
}

type isObjectId_Id interface {
	isObjectId_Id()
}

type ObjectId_HierObjectId struct {
	HierObjectId *HierObjectId `protobuf:"bytes,1,opt,name=hier_object_id,json=hierObjectId,proto3,oneof"`
}

type ObjectId_ObjectVersionId struct {
	ObjectVersionId *ObjectVersionId `protobuf:"bytes,2,opt,name=object_version_id,json=objectVersionId,proto3,oneof"`
}

type ObjectId_ArchetypeId struct {
	ArchetypeId *ArchetypeId `protobuf:"bytes,3,opt,name=archetype_id,json=archetypeId,proto3,oneof"`
}

type ObjectId_TemplateId struct {
	TemplateId *TemplateId `protobuf:"bytes,4,opt,name=template_id,json=templateId,proto3,oneof"`
}

type ObjectId_TerminologyId struct {
	TerminologyId *TerminologyId `protobuf:"bytes,5,opt,name=terminology_id,json=terminologyId,proto3,oneof"`
}

type ObjectId_GenericId struct {
	GenericId *GenericId `protobuf:"bytes,6,opt,name=generic_id,json=genericId,proto3,oneof"`
}

func (*ObjectId_HierObjectId) isObjectId_Id() {}

func (*ObjectId_ObjectVersionId) isObjectId_Id() {}

func (*ObjectId_ArchetypeId) isObjectId_Id() {}

func (*ObjectId_TemplateId) isObjectId_Id() {}

func (*ObjectId_TerminologyId) isObjectId_Id() {}

func (*ObjectId_GenericId) isObjectId_Id() {}

// Abstract model of UID-based identifiers consisting of a root part and an optional extension; lexical form: root '::' extension.
type UidBasedId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Id:
	//
	//	*UidBasedId_HierObjectId
	//	*UidBasedId_ObjectVersionId
	Id            isUidBasedId_Id `protobuf_oneof:"id"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UidBasedId) Reset() {
	*x = UidBasedId{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UidBasedId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UidBasedId) ProtoMessage() {}

func (x *UidBasedId) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UidBasedId.ProtoReflect.Descriptor instead.
func (*UidBasedId) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{18}
}

func (x *UidBasedId) GetId() isUidBasedId_Id {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *UidBasedId) GetHierObjectId() *HierObjectId {
	if x != nil {
		if x, ok := x.Id.(*UidBasedId_HierObjectId); ok {
			return x.HierObjectId
		}
	}
	return nil
}

func (x *UidBasedId) GetObjectVersionId() *ObjectVersionId {
	if x != nil {
		if x, ok := x.Id.(*UidBasedId_ObjectVersionId); ok {
			return x.ObjectVersionId
		}
	}
	return nil
}

type isUidBasedId_Id interface {
	isUidBasedId_Id()
}

type UidBasedId_HierObjectId struct {
	HierObjectId *HierObjectId `protobuf:"bytes,1,opt,name=hier_object_id,json=hierObjectId,proto3,oneof"`
}

type UidBasedId_ObjectVersionId struct {
	ObjectVersionId *ObjectVersionId `protobuf:"bytes,2,opt,name=object_version_id,json=objectVersionId,proto3,oneof"`
}

func (*UidBasedId_HierObjectId) isUidBasedId_Id() {}

func (*UidBasedId_ObjectVersionId) isUidBasedId_Id() {}

// Concrete type corresponding to hierarchical identifiers of the form defined by UID_BASED_ID.
type HierObjectId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lexical form: root '::' extension.
	Value         string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HierObjectId) Reset() {
	*x = HierObjectId{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HierObjectId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HierObjectId) ProtoMessage() {}

func (x *HierObjectId) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HierObjectId.ProtoReflect.Descriptor instead.
func (*HierObjectId) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{19}
}

func (x *HierObjectId) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Globally unique identifier for one version of a versioned object
type ObjectVersionId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lexical form: object_id '::' creating_system_id '::' version_tree_id.
	Value         string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ObjectVersionId) Reset() {
	*x = ObjectVersionId{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ObjectVersionId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObjectVersionId) ProtoMessage() {}

func (x *ObjectVersionId) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObjectVersionId.ProtoReflect.Descriptor instead.
func (*ObjectVersionId) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{20}
}

func (x *ObjectVersionId) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Identifier for archetypes. Ideally these would identify globally unique archetypes.
type ArchetypeId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lexical form: rm_originator '-' rm_name '-' rm_entity '.' concept_name { '-' specialisation }* '.v' number.
	Value         string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ArchetypeId) Reset() {
	*x = ArchetypeId{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ArchetypeId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ArchetypeId) ProtoMessage() {}

func (x *ArchetypeId) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ArchetypeId.ProtoReflect.Descriptor instead.
func (*ArchetypeId) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{21}
}

func (x *ArchetypeId) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Identifier for templates
type TemplateId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lexical form to be determined.
	Value         string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TemplateId) Reset() {
	*x = TemplateId{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TemplateId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TemplateId) ProtoMessage() {}

func (x *TemplateId) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TemplateId.ProtoReflect.Descriptor instead.
func (*TemplateId) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{22}
}

func (x *TemplateId) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Identifier for terminologies such as accessed via a terminology query service.
// In this class, the value attribute identifies the Terminology in the terminology service, e.g. SNOMED-CT .
// A terminology is assumed to be in a particular language, which must be explicitly specified.
type TerminologyId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lexical form: name [ '(' version ')' ].
	Value         string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TerminologyId) Reset() {
	*x = TerminologyId{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TerminologyId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TerminologyId) ProtoMessage() {}

func (x *TerminologyId) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TerminologyId.ProtoReflect.Descriptor instead.
func (*TerminologyId) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{23}
}

func (x *TerminologyId) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Generic identifier type for identifiers whose format is otherwise unknown to openEHR.
// Includes an attribute for naming the identification scheme (which may well be local).
type GenericId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unknown format.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// Name of the scheme to which this identifier conforms.
	// Ideally this name will be recognisable globally but realistically it may be a local ad hoc scheme whose name is not controlled or standardised in any way.
	Scheme        string `protobuf:"bytes,2,opt,name=scheme,proto3" json:"scheme,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GenericId) Reset() {
	*x = GenericId{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GenericId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GenericId) ProtoMessage() {}

func (x *GenericId) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GenericId.ProtoReflect.Descriptor instead.
func (*GenericId) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{24}
}

func (x *GenericId) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *GenericId) GetScheme() string {
	if x != nil {
		return x.Scheme
	}
	return ""
}

// Class describing a reference to another object, which may exist locally or be maintained outside the current namespace, e.g. in another service. Services are usually external, e.g. available in a LAN (including on the same host) or the internet via Corba, SOAP, or some other distributed protocol. However, in small systems they may be part of the same executable as the data containing the Id.
type ObjectRef struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Namespace to which this identifier belongs in the local system context (and possibly in any other openEHR compliant environment) e.g. terminology , demographic . These names are not yet standardised. Legal values for namespace are:
	//
	// - "local"
	//
	// - "unknown"
	//
	// - a string matching the standard regex [a-zA-Z][a-zA-Z0-9_.:\/&?=+-]*.
	//
	// Note that the first two are just special values of the regex, and will be matched by it.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name of the class (concrete or abstract) of object to which this identifier type refers, e.g. PARTY, PERSON, GUIDELINE etc. These class names are from the relevant reference model. The type name ANY can be used to indicate that any type is accepted (e.g. if the type is unknown).
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Globally unique id of an object, regardless of where it is stored.
	Id            *ObjectId `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ObjectRef) Reset() {
	*x = ObjectRef{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ObjectRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ObjectRef) ProtoMessage() {}

func (x *ObjectRef) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ObjectRef.ProtoReflect.Descriptor instead.
func (*ObjectRef) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{25}
}

func (x *ObjectRef) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *ObjectRef) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *ObjectRef) GetId() *ObjectId {
	if x != nil {
		return x.Id
	}
	return nil
}

// Identifier for parties in a demographic or identity service. There are typically a number of subtypes of the PARTY class, including PERSON, ORGANISATION, etc. Abstract supertypes are allowed if the referenced object is of a type not known by the current implementation of this class (in other words, if the demographic model is changed by the addition of a new PARTY or ACTOR subtypes, valid PARTY_REFs can still be constructed to them).
type PartyRef struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Namespace to which this identifier belongs in the local system context (and possibly in any other openEHR compliant environment) e.g. terminology , demographic . These names are not yet standardised. Legal values for namespace are:
	//
	// - "local"
	//
	// - "unknown"
	//
	// - a string matching the standard regex [a-zA-Z][a-zA-Z0-9_.:\/&?=+-]*.
	//
	// Note that the first two are just special values of the regex, and will be matched by it.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name of the class (concrete or abstract) of object to which this identifier type refers, e.g. PARTY, PERSON, GUIDELINE etc. These class names are from the relevant reference model. The type name ANY can be used to indicate that any type is accepted (e.g. if the type is unknown).
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Globally unique id of an object, regardless of where it is stored.
	Id            *ObjectId `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartyRef) Reset() {
	*x = PartyRef{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartyRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartyRef) ProtoMessage() {}

func (x *PartyRef) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartyRef.ProtoReflect.Descriptor instead.
func (*PartyRef) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{26}
}

func (x *PartyRef) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *PartyRef) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *PartyRef) GetId() *ObjectId {
	if x != nil {
		return x.Id
	}
	return nil
}

type LocatableRef struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Namespace to which this identifier belongs in the local system context (and possibly in any other openEHR compliant environment) e.g. terminology , demographic . These names are not yet standardised. Legal values for namespace are:
	//
	// - "local"
	//
	// - "unknown"
	//
	// - a string matching the standard regex [a-zA-Z][a-zA-Z0-9_.:\/&?=+-]*.
	//
	// Note that the first two are just special values of the regex, and will be matched by it.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// Name of the class (concrete or abstract) of object to which this identifier type refers, e.g. PARTY, PERSON, GUIDELINE etc. These class names are from the relevant reference model. The type name ANY can be used to indicate that any type is accepted (e.g. if the type is unknown).
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Globally unique id of an object, regardless of where it is stored.
	Id *UidBasedId `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// The path to an instance in question, as an absolute path with respect to the object found at VERSION.data. An empty path means that the object referred to by id being specified.
	Path          *string `protobuf:"bytes,4,opt,name=path,proto3,oneof" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LocatableRef) Reset() {
	*x = LocatableRef{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LocatableRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LocatableRef) ProtoMessage() {}

func (x *LocatableRef) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LocatableRef.ProtoReflect.Descriptor instead.
func (*LocatableRef) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{27}
}

func (x *LocatableRef) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *LocatableRef) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *LocatableRef) GetId() *UidBasedId {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *LocatableRef) GetPath() string {
	if x != nil && x.Path != nil {
		return *x.Path
	}
	return ""
}

// Abstract parent of all DV_ data value types. Serves as a common ancestor of all data value types in openEHR models.
type DataValue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*DataValue_DvBoolean
	//	*DataValue_DvState
	//	*DataValue_DvIdentifier
	//	*DataValue_DvText
	//	*DataValue_DvCodedText
	//	*DataValue_DvParagraph
	//	*DataValue_DvIntervalAny
	//	*DataValue_DvReferenceRangeAny
	//	*DataValue_DvOrdinal
	//	*DataValue_DvScale
	//	*DataValue_DvQuantity
	//	*DataValue_DvCount
	//	*DataValue_DvProportion
	//	*DataValue_DvDate
	//	*DataValue_DvTime
	//	*DataValue_DvDateTime
	//	*DataValue_DvDuration
	//	*DataValue_DvPeriodicTimeSpecification
	//	*DataValue_DvGeneralTimeSpecification
	//	*DataValue_DvMultimedia
	//	*DataValue_DvParsable
	//	*DataValue_DvUri
	//	*DataValue_DvEhrUri
	Value         isDataValue_Value `protobuf_oneof:"value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DataValue) Reset() {
	*x = DataValue{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataValue) ProtoMessage() {}

func (x *DataValue) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataValue.ProtoReflect.Descriptor instead.
func (*DataValue) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{28}
}

func (x *DataValue) GetValue() isDataValue_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *DataValue) GetDvBoolean() *DvBoolean {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvBoolean); ok {
			return x.DvBoolean
		}
	}
	return nil
}

func (x *DataValue) GetDvState() *DvState {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvState); ok {
			return x.DvState
		}
	}
	return nil
}

func (x *DataValue) GetDvIdentifier() *DvIdentifier {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvIdentifier); ok {
			return x.DvIdentifier
		}
	}
	return nil
}

func (x *DataValue) GetDvText() *DvText {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvText); ok {
			return x.DvText
		}
	}
	return nil
}

func (x *DataValue) GetDvCodedText() *DvCodedText {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvCodedText); ok {
			return x.DvCodedText
		}
	}
	return nil
}

func (x *DataValue) GetDvParagraph() *DvParagraph {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvParagraph); ok {
			return x.DvParagraph
		}
	}
	return nil
}

func (x *DataValue) GetDvIntervalAny() *DvIntervalAny {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvIntervalAny); ok {
			return x.DvIntervalAny
		}
	}
	return nil
}

func (x *DataValue) GetDvReferenceRangeAny() *ReferenceRangeAny {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvReferenceRangeAny); ok {
			return x.DvReferenceRangeAny
		}
	}
	return nil
}

func (x *DataValue) GetDvOrdinal() *DvOrdinal {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvOrdinal); ok {
			return x.DvOrdinal
		}
	}
	return nil
}

func (x *DataValue) GetDvScale() *DvScale {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvScale); ok {
			return x.DvScale
		}
	}
	return nil
}

func (x *DataValue) GetDvQuantity() *DvQuantity {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvQuantity); ok {
			return x.DvQuantity
		}
	}
	return nil
}

func (x *DataValue) GetDvCount() *DvCount {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvCount); ok {
			return x.DvCount
		}
	}
	return nil
}

func (x *DataValue) GetDvProportion() *DvProportion {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvProportion); ok {
			return x.DvProportion
		}
	}
	return nil
}

func (x *DataValue) GetDvDate() *DvDate {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvDate); ok {
			return x.DvDate
		}
	}
	return nil
}

func (x *DataValue) GetDvTime() *DvTime {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvTime); ok {
			return x.DvTime
		}
	}
	return nil
}

func (x *DataValue) GetDvDateTime() *DvDateTime {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvDateTime); ok {
			return x.DvDateTime
		}
	}
	return nil
}

func (x *DataValue) GetDvDuration() *DvDuration {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvDuration); ok {
			return x.DvDuration
		}
	}
	return nil
}

func (x *DataValue) GetDvPeriodicTimeSpecification() *DvPeriodicTimeSpecification {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvPeriodicTimeSpecification); ok {
			return x.DvPeriodicTimeSpecification
		}
	}
	return nil
}

func (x *DataValue) GetDvGeneralTimeSpecification() *DvGeneralTimeSpecification {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvGeneralTimeSpecification); ok {
			return x.DvGeneralTimeSpecification
		}
	}
	return nil
}

func (x *DataValue) GetDvMultimedia() *DvMultimedia {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvMultimedia); ok {
			return x.DvMultimedia
		}
	}
	return nil
}

func (x *DataValue) GetDvParsable() *DvParsable {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvParsable); ok {
			return x.DvParsable
		}
	}
	return nil
}

func (x *DataValue) GetDvUri() *DvUri {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvUri); ok {
			return x.DvUri
		}
	}
	return nil
}

func (x *DataValue) GetDvEhrUri() *DvEhrUri {
	if x != nil {
		if x, ok := x.Value.(*DataValue_DvEhrUri); ok {
			return x.DvEhrUri
		}
	}
	return nil
}

type isDataValue_Value interface {
	isDataValue_Value()
}

type DataValue_DvBoolean struct {
	DvBoolean *DvBoolean `protobuf:"bytes,1,opt,name=dv_boolean,json=dvBoolean,proto3,oneof"`
}

type DataValue_DvState struct {
	DvState *DvState `protobuf:"bytes,2,opt,name=dv_state,json=dvState,proto3,oneof"`
}

type DataValue_DvIdentifier struct {
	DvIdentifier *DvIdentifier `protobuf:"bytes,3,opt,name=dv_identifier,json=dvIdentifier,proto3,oneof"`
}

type DataValue_DvText struct {
	DvText *DvText `protobuf:"bytes,4,opt,name=dv_text,json=dvText,proto3,oneof"`
}

type DataValue_DvCodedText struct {
	DvCodedText *DvCodedText `protobuf:"bytes,5,opt,name=dv_coded_text,json=dvCodedText,proto3,oneof"`
}

type DataValue_DvParagraph struct {
	DvParagraph *DvParagraph `protobuf:"bytes,6,opt,name=dv_paragraph,json=dvParagraph,proto3,oneof"`
}

type DataValue_DvIntervalAny struct {
	DvIntervalAny *DvIntervalAny `protobuf:"bytes,7,opt,name=dv_interval_any,json=dvIntervalAny,proto3,oneof"`
}

type DataValue_DvReferenceRangeAny struct {
	DvReferenceRangeAny *ReferenceRangeAny `protobuf:"bytes,8,opt,name=dv_reference_range_any,json=dvReferenceRangeAny,proto3,oneof"`
}

type DataValue_DvOrdinal struct {
	DvOrdinal *DvOrdinal `protobuf:"bytes,9,opt,name=dv_ordinal,json=dvOrdinal,proto3,oneof"`
}

type DataValue_DvScale struct {
	DvScale *DvScale `protobuf:"bytes,10,opt,name=dv_scale,json=dvScale,proto3,oneof"`
}

type DataValue_DvQuantity struct {
	DvQuantity *DvQuantity `protobuf:"bytes,11,opt,name=dv_quantity,json=dvQuantity,proto3,oneof"`
}

type DataValue_DvCount struct {
	DvCount *DvCount `protobuf:"bytes,12,opt,name=dv_count,json=dvCount,proto3,oneof"`
}

type DataValue_DvProportion struct {
	DvProportion *DvProportion `protobuf:"bytes,13,opt,name=dv_proportion,json=dvProportion,proto3,oneof"`
}

type DataValue_DvDate struct {
	DvDate *DvDate `protobuf:"bytes,14,opt,name=dv_date,json=dvDate,proto3,oneof"`
}

type DataValue_DvTime struct {
	DvTime *DvTime `protobuf:"bytes,15,opt,name=dv_time,json=dvTime,proto3,oneof"`
}

type DataValue_DvDateTime struct {
	DvDateTime *DvDateTime `protobuf:"bytes,16,opt,name=dv_date_time,json=dvDateTime,proto3,oneof"`
}

type DataValue_DvDuration struct {
	DvDuration *DvDuration `protobuf:"bytes,17,opt,name=dv_duration,json=dvDuration,proto3,oneof"`
}

type DataValue_DvPeriodicTimeSpecification struct {
	DvPeriodicTimeSpecification *DvPeriodicTimeSpecification `protobuf:"bytes,18,opt,name=dv_periodic_time_specification,json=dvPeriodicTimeSpecification,proto3,oneof"`
}

type DataValue_DvGeneralTimeSpecification struct {
	DvGeneralTimeSpecification *DvGeneralTimeSpecification `protobuf:"bytes,19,opt,name=dv_general_time_specification,json=dvGeneralTimeSpecification,proto3,oneof"`
}

type DataValue_DvMultimedia struct {
	DvMultimedia *DvMultimedia `protobuf:"bytes,20,opt,name=dv_multimedia,json=dvMultimedia,proto3,oneof"`
}

type DataValue_DvParsable struct {
	DvParsable *DvParsable `protobuf:"bytes,21,opt,name=dv_parsable,json=dvParsable,proto3,oneof"`
}

type DataValue_DvUri struct {
	DvUri *DvUri `protobuf:"bytes,22,opt,name=dv_uri,json=dvUri,proto3,oneof"`
}

type DataValue_DvEhrUri struct {
	DvEhrUri *DvEhrUri `protobuf:"bytes,23,opt,name=dv_ehr_uri,json=dvEhrUri,proto3,oneof"`
}

func (*DataValue_DvBoolean) isDataValue_Value() {}

func (*DataValue_DvState) isDataValue_Value() {}

func (*DataValue_DvIdentifier) isDataValue_Value() {}

func (*DataValue_DvText) isDataValue_Value() {}

func (*DataValue_DvCodedText) isDataValue_Value() {}

func (*DataValue_DvParagraph) isDataValue_Value() {}

func (*DataValue_DvIntervalAny) isDataValue_Value() {}

func (*DataValue_DvReferenceRangeAny) isDataValue_Value() {}

func (*DataValue_DvOrdinal) isDataValue_Value() {}

func (*DataValue_DvScale) isDataValue_Value() {}

func (*DataValue_DvQuantity) isDataValue_Value() {}

func (*DataValue_DvCount) isDataValue_Value() {}

func (*DataValue_DvProportion) isDataValue_Value() {}

func (*DataValue_DvDate) isDataValue_Value() {}

func (*DataValue_DvTime) isDataValue_Value() {}

func (*DataValue_DvDateTime) isDataValue_Value() {}

func (*DataValue_DvDuration) isDataValue_Value() {}

func (*DataValue_DvPeriodicTimeSpecification) isDataValue_Value() {}

func (*DataValue_DvGeneralTimeSpecification) isDataValue_Value() {}

func (*DataValue_DvMultimedia) isDataValue_Value() {}

func (*DataValue_DvParsable) isDataValue_Value() {}

func (*DataValue_DvUri) isDataValue_Value() {}

func (*DataValue_DvEhrUri) isDataValue_Value() {}

// Items which are truly boolean data, such as true/false or yes/no answers. For such data, it is important to devise the meanings (usually questions in subjective data) carefully, so that the only allowed results are in fact true or false.
//
// Misuse: The DV_BOOLEAN class should not be used as a replacement for naively modelled enumerated types such as male/female etc. Such values should be coded, and in any case the enumeration often has more than two values.
type DvBoolean struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Boolean value of this item. Actual values may be language or implementation dependent.
	Value         bool `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvBoolean) Reset() {
	*x = DvBoolean{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvBoolean) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvBoolean) ProtoMessage() {}

func (x *DvBoolean) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvBoolean.ProtoReflect.Descriptor instead.
func (*DvBoolean) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{29}
}

func (x *DvBoolean) GetValue() bool {
	if x != nil {
		return x.Value
	}
	return false
}

// For representing state values which obey a defined state machine, such as a variable representing the states of an instruction or care process.
//
// DV_STATE is expressed as a String but its values are driven by archetype-defined state machines.
// This provides a powerful way of capturing stateful complex processes in simple data.
type DvState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The state name.
	// State names are determined by a state/event table defined in archetypes, and coded using openEHR Terminology or local archetype terms, as specified by the archetype.
	Value *DvCodedText `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// Indicates whether this state is a terminal state, such as "aborted", "completed" etc. from which no further transitions are possible.
	IsTerminal    bool `protobuf:"varint,2,opt,name=is_terminal,json=isTerminal,proto3" json:"is_terminal,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvState) Reset() {
	*x = DvState{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvState) ProtoMessage() {}

func (x *DvState) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvState.ProtoReflect.Descriptor instead.
func (*DvState) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{30}
}

func (x *DvState) GetValue() *DvCodedText {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *DvState) GetIsTerminal() bool {
	if x != nil {
		return x.IsTerminal
	}
	return false
}

// Type for representing identifiers of real-world entities.
// Typical identifiers include drivers licence number, social security number, veterans affairs number, prescription id, order id, and so on.
//
// DV_IDENTIFIER is used to represent any identifier of a real thing, issued by some authority or agency.
//
// Misuse: DV_IDENTIFIER is not used to express identifiers generated by the infrastructure to refer to information items; the types OBJECT_ID and OBJECT_REF and subtypes are defined for this purpose.
type DvIdentifier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional authority which issues the kind of id used in the id field of this object.
	Issuer *string `protobuf:"bytes,1,opt,name=issuer,proto3,oneof" json:"issuer,omitempty"`
	// Optional organisation that assigned the id to the item being identified.
	Assigner *string `protobuf:"bytes,2,opt,name=assigner,proto3,oneof" json:"assigner,omitempty"`
	// The identifier value. Often structured, according to the definition of the issuing authoritys rules.
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// Optional identifier type, such as prescription , or Social Security Number . One day a controlled vocabulary might be possible for this.
	Type          *string `protobuf:"bytes,4,opt,name=type,proto3,oneof" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvIdentifier) Reset() {
	*x = DvIdentifier{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvIdentifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvIdentifier) ProtoMessage() {}

func (x *DvIdentifier) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvIdentifier.ProtoReflect.Descriptor instead.
func (*DvIdentifier) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{31}
}

func (x *DvIdentifier) GetIssuer() string {
	if x != nil && x.Issuer != nil {
		return *x.Issuer
	}
	return ""
}

func (x *DvIdentifier) GetAssigner() string {
	if x != nil && x.Assigner != nil {
		return *x.Assigner
	}
	return ""
}

func (x *DvIdentifier) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *DvIdentifier) GetType() string {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return ""
}

type DvTextType struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*DvTextType_DvText
	//	*DvTextType_DvCodedText
	Type          isDvTextType_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvTextType) Reset() {
	*x = DvTextType{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvTextType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvTextType) ProtoMessage() {}

func (x *DvTextType) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvTextType.ProtoReflect.Descriptor instead.
func (*DvTextType) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{32}
}

func (x *DvTextType) GetType() isDvTextType_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *DvTextType) GetDvText() *DvText {
	if x != nil {
		if x, ok := x.Type.(*DvTextType_DvText); ok {
			return x.DvText
		}
	}
	return nil
}

func (x *DvTextType) GetDvCodedText() *DvCodedText {
	if x != nil {
		if x, ok := x.Type.(*DvTextType_DvCodedText); ok {
			return x.DvCodedText
		}
	}
	return nil
}

type isDvTextType_Type interface {
	isDvTextType_Type()
}

type DvTextType_DvText struct {
	DvText *DvText `protobuf:"bytes,1,opt,name=dv_text,json=dvText,proto3,oneof"`
}

type DvTextType_DvCodedText struct {
	DvCodedText *DvCodedText `protobuf:"bytes,2,opt,name=dv_coded_text,json=dvCodedText,proto3,oneof"`
}

func (*DvTextType_DvText) isDvTextType_Type() {}

func (*DvTextType_DvCodedText) isDvTextType_Type() {}

// A text item, which may contain any amount of legal characters arranged as e.g. words, sentences etc (i.e. one DV_TEXT may be more than one word). Visual formatting and hyperlinks may be included via markdown.
//
// If the formatting field is set, the value field is affected as follows:
//
// - formatting = "plain": plain text, may contain newlines;
//
// - formatting = "plain_no_newlines": plain text with no newlines;
//
// - formatting = "markdown": text in markdown format; use of CommonMark strongly recommended.
//
// A DV_TEXT can be coded by adding mappings to it.
type DvText struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Displayable rendition of the item, regardless of its underlying structure.
	// For DV_CODED_TEXT, this is the rubric of the complete term as provided by the terminology service.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// DEPRECATED: this field is deprecated; use markdown link/text in the value attribute, and "markdown" as the value of the formatting field.
	// Original usage, prior to RM Release 1.0.4: Optional link sitting behind a section of plain text or coded term item.
	Hyperlink *DvUri `protobuf:"bytes,2,opt,name=hyperlink,proto3,oneof" json:"hyperlink,omitempty"`
	// If set, contains one of the following values:
	//
	// - "plain": use for plain text, possibly containing newlines, but otherwise unformatted (same as Void);
	// - "plain_no_newlines": use for text containing no newlines or other formatting;
	// - "markdown": use for markdown formatted text, strongly recommended in the format of the CommonMark specification.
	//
	// DEPRECATED usage: contains a string of the form "name:value; name:value" , e.g. "font-weight : bold; font-family : Arial; font-size : 12pt;". Values taken from W3C CSS2 properties lists for background and font .
	Formatting *string `protobuf:"bytes,3,opt,name=formatting,proto3,oneof" json:"formatting,omitempty"`
	// Terms from other terminologies most closely matching this term, typically used where the originator (e.g. pathology lab) of information uses a local terminology but also supplies one or more equivalents from well known terminologies (e.g. LOINC).
	Mappings []*TermMapping `protobuf:"bytes,4,rep,name=mappings,proto3" json:"mappings,omitempty"`
	// Optional indicator of the localised language in which the value is written.
	// Coded from openEHR Code Set languages.
	// Only used when either the text object is in a different language from the enclosing ENTRY, or else the text object is being used outside of an ENTRY or other enclosing structure which indicates the language.
	Language *CodePhrase `protobuf:"bytes,5,opt,name=language,proto3,oneof" json:"language,omitempty"`
	// Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set character sets.
	// Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding.
	// This attribute allows for variations from these assumptions.
	Encoding      *CodePhrase `protobuf:"bytes,6,opt,name=encoding,proto3,oneof" json:"encoding,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvText) Reset() {
	*x = DvText{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvText) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvText) ProtoMessage() {}

func (x *DvText) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvText.ProtoReflect.Descriptor instead.
func (*DvText) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{33}
}

func (x *DvText) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *DvText) GetHyperlink() *DvUri {
	if x != nil {
		return x.Hyperlink
	}
	return nil
}

func (x *DvText) GetFormatting() string {
	if x != nil && x.Formatting != nil {
		return *x.Formatting
	}
	return ""
}

func (x *DvText) GetMappings() []*TermMapping {
	if x != nil {
		return x.Mappings
	}
	return nil
}

func (x *DvText) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *DvText) GetEncoding() *CodePhrase {
	if x != nil {
		return x.Encoding
	}
	return nil
}

// A text item whose value must be the rubric from a controlled terminology, the key (i.e. the 'code') of which is the defining_code attribute. In other words: a DV_CODED_TEXT is a combination of a CODE_PHRASE (effectively a code) and the rubric of that term, from a terminology service, in the language in which the data were authored.
//
// Since DV_CODED_TEXT is a subtype of DV_TEXT, it can be used in place of it, effectively allowing the type DV_TEXT to mean a text item, which may optionally be coded.
//
// Misuse: If the intention is to represent a term code attached in some way to a fragment of plain text, DV_CODED_TEXT should not be used; instead use a DV_TEXT and a TERM_MAPPING to a CODE_PHRASE.
type DvCodedText struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Displayable rendition of the item, regardless of its underlying structure.
	// For DV_CODED_TEXT, this is the rubric of the complete term as provided by the terminology service.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// DEPRECATED: this field is deprecated; use markdown link/text in the value attribute, and "markdown" as the value of the formatting field.
	// Original usage, prior to RM Release 1.0.4: Optional link sitting behind a section of plain text or coded term item.
	Hyperlink *DvUri `protobuf:"bytes,2,opt,name=hyperlink,proto3,oneof" json:"hyperlink,omitempty"`
	// If set, contains one of the following values:
	//
	// - "plain": use for plain text, possibly containing newlines, but otherwise unformatted (same as Void);
	// - "plain_no_newlines": use for text containing no newlines or other formatting;
	// - "markdown": use for markdown formatted text, strongly recommended in the format of the CommonMark specification.
	//
	// DEPRECATED usage: contains a string of the form "name:value; name:value" , e.g. "font-weight : bold; font-family : Arial; font-size : 12pt;". Values taken from W3C CSS2 properties lists for background and font .
	Formatting *string `protobuf:"bytes,3,opt,name=formatting,proto3,oneof" json:"formatting,omitempty"`
	// Terms from other terminologies most closely matching this term, typically used where the originator (e.g. pathology lab) of information uses a local terminology but also supplies one or more equivalents from well known terminologies (e.g. LOINC).
	Mappings []*TermMapping `protobuf:"bytes,4,rep,name=mappings,proto3" json:"mappings,omitempty"`
	// Optional indicator of the localised language in which the value is written.
	// Coded from openEHR Code Set languages.
	// Only used when either the text object is in a different language from the enclosing ENTRY, or else the text object is being used outside of an ENTRY or other enclosing structure which indicates the language.
	Language *CodePhrase `protobuf:"bytes,5,opt,name=language,proto3,oneof" json:"language,omitempty"`
	// Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set character sets.
	// Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding.
	// This attribute allows for variations from these assumptions.
	Encoding *CodePhrase `protobuf:"bytes,6,opt,name=encoding,proto3,oneof" json:"encoding,omitempty"`
	// The term of which the value attribute is the textual rendition (i.e. rubric).
	DefiningCode  *CodePhrase `protobuf:"bytes,7,opt,name=defining_code,json=definingCode,proto3" json:"defining_code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvCodedText) Reset() {
	*x = DvCodedText{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvCodedText) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvCodedText) ProtoMessage() {}

func (x *DvCodedText) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvCodedText.ProtoReflect.Descriptor instead.
func (*DvCodedText) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{34}
}

func (x *DvCodedText) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *DvCodedText) GetHyperlink() *DvUri {
	if x != nil {
		return x.Hyperlink
	}
	return nil
}

func (x *DvCodedText) GetFormatting() string {
	if x != nil && x.Formatting != nil {
		return *x.Formatting
	}
	return ""
}

func (x *DvCodedText) GetMappings() []*TermMapping {
	if x != nil {
		return x.Mappings
	}
	return nil
}

func (x *DvCodedText) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *DvCodedText) GetEncoding() *CodePhrase {
	if x != nil {
		return x.Encoding
	}
	return nil
}

func (x *DvCodedText) GetDefiningCode() *CodePhrase {
	if x != nil {
		return x.DefiningCode
	}
	return nil
}

// DEPRECATED: use markdown formatted DV_TEXT instead.
//
// Original definition:
//
// A logical composite text value consisting of a series of DV_TEXTs, i.e. plain text (optionally coded) potentially with simple formatting, to form a larger tract of prose, which may be interpreted for display purposes as a paragraph.
//
// DV_PARAGRAPH is the standard way for constructing longer text items in summaries, reports and so on.
type DvParagraph struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Items making up the paragraph, each of which is a text item (which may have its own formatting, and/or have hyperlinks).
	Items         []*DvText `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvParagraph) Reset() {
	*x = DvParagraph{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvParagraph) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvParagraph) ProtoMessage() {}

func (x *DvParagraph) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvParagraph.ProtoReflect.Descriptor instead.
func (*DvParagraph) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{35}
}

func (x *DvParagraph) GetItems() []*DvText {
	if x != nil {
		return x.Items
	}
	return nil
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
//
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
//
// The basic semantics are derived from the class Interval<T>, described in the support RM.
type DvIntervalAny struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lower bound. lower bound.
	Lower []byte `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	// Upper bound. Upper bound.
	Upper []byte `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	// lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
	LowerUnbounded bool `protobuf:"varint,3,opt,name=lower_unbounded,json=lowerUnbounded,proto3" json:"lower_unbounded,omitempty"`
	// upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
	UpperUnbounded bool `protobuf:"varint,4,opt,name=upper_unbounded,json=upperUnbounded,proto3" json:"upper_unbounded,omitempty"`
	// lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
	LowerIncluded bool `protobuf:"varint,5,opt,name=lower_included,json=lowerIncluded,proto3" json:"lower_included,omitempty"`
	// upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
	UpperIncluded bool `protobuf:"varint,6,opt,name=upper_included,json=upperIncluded,proto3" json:"upper_included,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvIntervalAny) Reset() {
	*x = DvIntervalAny{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvIntervalAny) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvIntervalAny) ProtoMessage() {}

func (x *DvIntervalAny) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvIntervalAny.ProtoReflect.Descriptor instead.
func (*DvIntervalAny) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{36}
}

func (x *DvIntervalAny) GetLower() []byte {
	if x != nil {
		return x.Lower
	}
	return nil
}

func (x *DvIntervalAny) GetUpper() []byte {
	if x != nil {
		return x.Upper
	}
	return nil
}

func (x *DvIntervalAny) GetLowerUnbounded() bool {
	if x != nil {
		return x.LowerUnbounded
	}
	return false
}

func (x *DvIntervalAny) GetUpperUnbounded() bool {
	if x != nil {
		return x.UpperUnbounded
	}
	return false
}

func (x *DvIntervalAny) GetLowerIncluded() bool {
	if x != nil {
		return x.LowerIncluded
	}
	return false
}

func (x *DvIntervalAny) GetUpperIncluded() bool {
	if x != nil {
		return x.UpperIncluded
	}
	return false
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
//
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
//
// The basic semantics are derived from the class Interval<T>, described in the support RM.
type DvIntervalInt64 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lower bound. lower bound.
	Lower int64 `protobuf:"varint,1,opt,name=lower,proto3" json:"lower,omitempty"`
	// Upper bound. Upper bound.
	Upper int64 `protobuf:"varint,2,opt,name=upper,proto3" json:"upper,omitempty"`
	// lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
	LowerUnbounded bool `protobuf:"varint,3,opt,name=lower_unbounded,json=lowerUnbounded,proto3" json:"lower_unbounded,omitempty"`
	// upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
	UpperUnbounded bool `protobuf:"varint,4,opt,name=upper_unbounded,json=upperUnbounded,proto3" json:"upper_unbounded,omitempty"`
	// lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
	LowerIncluded bool `protobuf:"varint,5,opt,name=lower_included,json=lowerIncluded,proto3" json:"lower_included,omitempty"`
	// upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
	UpperIncluded bool `protobuf:"varint,6,opt,name=upper_included,json=upperIncluded,proto3" json:"upper_included,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvIntervalInt64) Reset() {
	*x = DvIntervalInt64{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvIntervalInt64) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvIntervalInt64) ProtoMessage() {}

func (x *DvIntervalInt64) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvIntervalInt64.ProtoReflect.Descriptor instead.
func (*DvIntervalInt64) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{37}
}

func (x *DvIntervalInt64) GetLower() int64 {
	if x != nil {
		return x.Lower
	}
	return 0
}

func (x *DvIntervalInt64) GetUpper() int64 {
	if x != nil {
		return x.Upper
	}
	return 0
}

func (x *DvIntervalInt64) GetLowerUnbounded() bool {
	if x != nil {
		return x.LowerUnbounded
	}
	return false
}

func (x *DvIntervalInt64) GetUpperUnbounded() bool {
	if x != nil {
		return x.UpperUnbounded
	}
	return false
}

func (x *DvIntervalInt64) GetLowerIncluded() bool {
	if x != nil {
		return x.LowerIncluded
	}
	return false
}

func (x *DvIntervalInt64) GetUpperIncluded() bool {
	if x != nil {
		return x.UpperIncluded
	}
	return false
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
//
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
//
// The basic semantics are derived from the class Interval<T>, described in the support RM.
type DvIntervalDvDateTime struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lower bound. lower bound.
	Lower *DvDateTime `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	// Upper bound. Upper bound.
	Upper *DvDateTime `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	// lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
	LowerUnbounded bool `protobuf:"varint,3,opt,name=lower_unbounded,json=lowerUnbounded,proto3" json:"lower_unbounded,omitempty"`
	// upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
	UpperUnbounded bool `protobuf:"varint,4,opt,name=upper_unbounded,json=upperUnbounded,proto3" json:"upper_unbounded,omitempty"`
	// lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
	LowerIncluded bool `protobuf:"varint,5,opt,name=lower_included,json=lowerIncluded,proto3" json:"lower_included,omitempty"`
	// upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
	UpperIncluded bool `protobuf:"varint,6,opt,name=upper_included,json=upperIncluded,proto3" json:"upper_included,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvIntervalDvDateTime) Reset() {
	*x = DvIntervalDvDateTime{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvIntervalDvDateTime) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvIntervalDvDateTime) ProtoMessage() {}

func (x *DvIntervalDvDateTime) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvIntervalDvDateTime.ProtoReflect.Descriptor instead.
func (*DvIntervalDvDateTime) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{38}
}

func (x *DvIntervalDvDateTime) GetLower() *DvDateTime {
	if x != nil {
		return x.Lower
	}
	return nil
}

func (x *DvIntervalDvDateTime) GetUpper() *DvDateTime {
	if x != nil {
		return x.Upper
	}
	return nil
}

func (x *DvIntervalDvDateTime) GetLowerUnbounded() bool {
	if x != nil {
		return x.LowerUnbounded
	}
	return false
}

func (x *DvIntervalDvDateTime) GetUpperUnbounded() bool {
	if x != nil {
		return x.UpperUnbounded
	}
	return false
}

func (x *DvIntervalDvDateTime) GetLowerIncluded() bool {
	if x != nil {
		return x.LowerIncluded
	}
	return false
}

func (x *DvIntervalDvDateTime) GetUpperIncluded() bool {
	if x != nil {
		return x.UpperIncluded
	}
	return false
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
//
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
//
// The basic semantics are derived from the class Interval<T>, described in the support RM.
type DvIntervalDvDuration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lower bound. lower bound.
	Lower *DvDateTime `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	// Upper bound. Upper bound.
	Upper *DvDateTime `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	// lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
	LowerUnbounded bool `protobuf:"varint,3,opt,name=lower_unbounded,json=lowerUnbounded,proto3" json:"lower_unbounded,omitempty"`
	// upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
	UpperUnbounded bool `protobuf:"varint,4,opt,name=upper_unbounded,json=upperUnbounded,proto3" json:"upper_unbounded,omitempty"`
	// lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
	LowerIncluded bool `protobuf:"varint,5,opt,name=lower_included,json=lowerIncluded,proto3" json:"lower_included,omitempty"`
	// upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
	UpperIncluded bool `protobuf:"varint,6,opt,name=upper_included,json=upperIncluded,proto3" json:"upper_included,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvIntervalDvDuration) Reset() {
	*x = DvIntervalDvDuration{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvIntervalDvDuration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvIntervalDvDuration) ProtoMessage() {}

func (x *DvIntervalDvDuration) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvIntervalDvDuration.ProtoReflect.Descriptor instead.
func (*DvIntervalDvDuration) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{39}
}

func (x *DvIntervalDvDuration) GetLower() *DvDateTime {
	if x != nil {
		return x.Lower
	}
	return nil
}

func (x *DvIntervalDvDuration) GetUpper() *DvDateTime {
	if x != nil {
		return x.Upper
	}
	return nil
}

func (x *DvIntervalDvDuration) GetLowerUnbounded() bool {
	if x != nil {
		return x.LowerUnbounded
	}
	return false
}

func (x *DvIntervalDvDuration) GetUpperUnbounded() bool {
	if x != nil {
		return x.UpperUnbounded
	}
	return false
}

func (x *DvIntervalDvDuration) GetLowerIncluded() bool {
	if x != nil {
		return x.LowerIncluded
	}
	return false
}

func (x *DvIntervalDvDuration) GetUpperIncluded() bool {
	if x != nil {
		return x.UpperIncluded
	}
	return false
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
//
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
//
// The basic semantics are derived from the class Interval<T>, described in the support RM.
type DvIntervalDvQuantity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lower bound. lower bound.
	Lower *DvQuantity `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	// Upper bound. Upper bound.
	Upper *DvQuantity `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	// lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
	LowerUnbounded bool `protobuf:"varint,3,opt,name=lower_unbounded,json=lowerUnbounded,proto3" json:"lower_unbounded,omitempty"`
	// upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
	UpperUnbounded bool `protobuf:"varint,4,opt,name=upper_unbounded,json=upperUnbounded,proto3" json:"upper_unbounded,omitempty"`
	// lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
	LowerIncluded bool `protobuf:"varint,5,opt,name=lower_included,json=lowerIncluded,proto3" json:"lower_included,omitempty"`
	// upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
	UpperIncluded bool `protobuf:"varint,6,opt,name=upper_included,json=upperIncluded,proto3" json:"upper_included,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvIntervalDvQuantity) Reset() {
	*x = DvIntervalDvQuantity{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvIntervalDvQuantity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvIntervalDvQuantity) ProtoMessage() {}

func (x *DvIntervalDvQuantity) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvIntervalDvQuantity.ProtoReflect.Descriptor instead.
func (*DvIntervalDvQuantity) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{40}
}

func (x *DvIntervalDvQuantity) GetLower() *DvQuantity {
	if x != nil {
		return x.Lower
	}
	return nil
}

func (x *DvIntervalDvQuantity) GetUpper() *DvQuantity {
	if x != nil {
		return x.Upper
	}
	return nil
}

func (x *DvIntervalDvQuantity) GetLowerUnbounded() bool {
	if x != nil {
		return x.LowerUnbounded
	}
	return false
}

func (x *DvIntervalDvQuantity) GetUpperUnbounded() bool {
	if x != nil {
		return x.UpperUnbounded
	}
	return false
}

func (x *DvIntervalDvQuantity) GetLowerIncluded() bool {
	if x != nil {
		return x.LowerIncluded
	}
	return false
}

func (x *DvIntervalDvQuantity) GetUpperIncluded() bool {
	if x != nil {
		return x.UpperIncluded
	}
	return false
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
//
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
//
// The basic semantics are derived from the class Interval<T>, described in the support RM.
type DvIntervalDvCount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lower bound. lower bound.
	Lower *DvCount `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	// Upper bound. Upper bound.
	Upper *DvCount `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	// lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
	LowerUnbounded bool `protobuf:"varint,3,opt,name=lower_unbounded,json=lowerUnbounded,proto3" json:"lower_unbounded,omitempty"`
	// upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
	UpperUnbounded bool `protobuf:"varint,4,opt,name=upper_unbounded,json=upperUnbounded,proto3" json:"upper_unbounded,omitempty"`
	// lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
	LowerIncluded bool `protobuf:"varint,5,opt,name=lower_included,json=lowerIncluded,proto3" json:"lower_included,omitempty"`
	// upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
	UpperIncluded bool `protobuf:"varint,6,opt,name=upper_included,json=upperIncluded,proto3" json:"upper_included,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvIntervalDvCount) Reset() {
	*x = DvIntervalDvCount{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvIntervalDvCount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvIntervalDvCount) ProtoMessage() {}

func (x *DvIntervalDvCount) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvIntervalDvCount.ProtoReflect.Descriptor instead.
func (*DvIntervalDvCount) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{41}
}

func (x *DvIntervalDvCount) GetLower() *DvCount {
	if x != nil {
		return x.Lower
	}
	return nil
}

func (x *DvIntervalDvCount) GetUpper() *DvCount {
	if x != nil {
		return x.Upper
	}
	return nil
}

func (x *DvIntervalDvCount) GetLowerUnbounded() bool {
	if x != nil {
		return x.LowerUnbounded
	}
	return false
}

func (x *DvIntervalDvCount) GetUpperUnbounded() bool {
	if x != nil {
		return x.UpperUnbounded
	}
	return false
}

func (x *DvIntervalDvCount) GetLowerIncluded() bool {
	if x != nil {
		return x.LowerIncluded
	}
	return false
}

func (x *DvIntervalDvCount) GetUpperIncluded() bool {
	if x != nil {
		return x.UpperIncluded
	}
	return false
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
//
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
//
// The basic semantics are derived from the class Interval<T>, described in the support RM.
type DvIntervalDvProportion struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Lower bound. lower bound.
	Lower *DvProportion `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	// Upper bound. Upper bound.
	Upper *DvProportion `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	// lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
	LowerUnbounded bool `protobuf:"varint,3,opt,name=lower_unbounded,json=lowerUnbounded,proto3" json:"lower_unbounded,omitempty"`
	// upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
	UpperUnbounded bool `protobuf:"varint,4,opt,name=upper_unbounded,json=upperUnbounded,proto3" json:"upper_unbounded,omitempty"`
	// lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
	LowerIncluded bool `protobuf:"varint,5,opt,name=lower_included,json=lowerIncluded,proto3" json:"lower_included,omitempty"`
	// upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
	UpperIncluded bool `protobuf:"varint,6,opt,name=upper_included,json=upperIncluded,proto3" json:"upper_included,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvIntervalDvProportion) Reset() {
	*x = DvIntervalDvProportion{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvIntervalDvProportion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvIntervalDvProportion) ProtoMessage() {}

func (x *DvIntervalDvProportion) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvIntervalDvProportion.ProtoReflect.Descriptor instead.
func (*DvIntervalDvProportion) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{42}
}

func (x *DvIntervalDvProportion) GetLower() *DvProportion {
	if x != nil {
		return x.Lower
	}
	return nil
}

func (x *DvIntervalDvProportion) GetUpper() *DvProportion {
	if x != nil {
		return x.Upper
	}
	return nil
}

func (x *DvIntervalDvProportion) GetLowerUnbounded() bool {
	if x != nil {
		return x.LowerUnbounded
	}
	return false
}

func (x *DvIntervalDvProportion) GetUpperUnbounded() bool {
	if x != nil {
		return x.UpperUnbounded
	}
	return false
}

func (x *DvIntervalDvProportion) GetLowerIncluded() bool {
	if x != nil {
		return x.LowerIncluded
	}
	return false
}

func (x *DvIntervalDvProportion) GetUpperIncluded() bool {
	if x != nil {
		return x.UpperIncluded
	}
	return false
}

// Defines a named range to be associated with any DV_ORDERED datum.
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges.
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
type ReferenceRangeAny struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
	Meaning *DvTextType `protobuf:"bytes,1,opt,name=meaning,proto3" json:"meaning,omitempty"`
	// The data range for this meaning, e.g. critical etc.
	Range         *DvIntervalAny `protobuf:"bytes,2,opt,name=range,proto3" json:"range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReferenceRangeAny) Reset() {
	*x = ReferenceRangeAny{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReferenceRangeAny) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReferenceRangeAny) ProtoMessage() {}

func (x *ReferenceRangeAny) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReferenceRangeAny.ProtoReflect.Descriptor instead.
func (*ReferenceRangeAny) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{43}
}

func (x *ReferenceRangeAny) GetMeaning() *DvTextType {
	if x != nil {
		return x.Meaning
	}
	return nil
}

func (x *ReferenceRangeAny) GetRange() *DvIntervalAny {
	if x != nil {
		return x.Range
	}
	return nil
}

// Defines a named range to be associated with any DV_ORDERED datum.
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges.
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
type ReferenceRangeInt64 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
	Meaning *DvTextType `protobuf:"bytes,1,opt,name=meaning,proto3" json:"meaning,omitempty"`
	// The data range for this meaning, e.g. critical etc.
	Range         *DvIntervalInt64 `protobuf:"bytes,2,opt,name=range,proto3" json:"range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReferenceRangeInt64) Reset() {
	*x = ReferenceRangeInt64{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReferenceRangeInt64) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReferenceRangeInt64) ProtoMessage() {}

func (x *ReferenceRangeInt64) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReferenceRangeInt64.ProtoReflect.Descriptor instead.
func (*ReferenceRangeInt64) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{44}
}

func (x *ReferenceRangeInt64) GetMeaning() *DvTextType {
	if x != nil {
		return x.Meaning
	}
	return nil
}

func (x *ReferenceRangeInt64) GetRange() *DvIntervalInt64 {
	if x != nil {
		return x.Range
	}
	return nil
}

// Defines a named range to be associated with any DV_ORDERED datum.
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges.
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
type ReferenceRangeDvDateTime struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
	//
	// Types that are valid to be assigned to Meaning:
	//
	//	*ReferenceRangeDvDateTime_MeaningDvText
	//	*ReferenceRangeDvDateTime_MeaningDvCodedText
	Meaning isReferenceRangeDvDateTime_Meaning `protobuf_oneof:"meaning"`
	// The data range for this meaning, e.g. critical etc.
	Range         *DvIntervalDvDateTime `protobuf:"bytes,3,opt,name=range,proto3" json:"range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReferenceRangeDvDateTime) Reset() {
	*x = ReferenceRangeDvDateTime{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReferenceRangeDvDateTime) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReferenceRangeDvDateTime) ProtoMessage() {}

func (x *ReferenceRangeDvDateTime) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReferenceRangeDvDateTime.ProtoReflect.Descriptor instead.
func (*ReferenceRangeDvDateTime) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{45}
}

func (x *ReferenceRangeDvDateTime) GetMeaning() isReferenceRangeDvDateTime_Meaning {
	if x != nil {
		return x.Meaning
	}
	return nil
}

func (x *ReferenceRangeDvDateTime) GetMeaningDvText() *DvText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvDateTime_MeaningDvText); ok {
			return x.MeaningDvText
		}
	}
	return nil
}

func (x *ReferenceRangeDvDateTime) GetMeaningDvCodedText() *DvCodedText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvDateTime_MeaningDvCodedText); ok {
			return x.MeaningDvCodedText
		}
	}
	return nil
}

func (x *ReferenceRangeDvDateTime) GetRange() *DvIntervalDvDateTime {
	if x != nil {
		return x.Range
	}
	return nil
}

type isReferenceRangeDvDateTime_Meaning interface {
	isReferenceRangeDvDateTime_Meaning()
}

type ReferenceRangeDvDateTime_MeaningDvText struct {
	MeaningDvText *DvText `protobuf:"bytes,1,opt,name=meaning_dv_text,json=meaningDvText,proto3,oneof"`
}

type ReferenceRangeDvDateTime_MeaningDvCodedText struct {
	MeaningDvCodedText *DvCodedText `protobuf:"bytes,2,opt,name=meaning_dv_coded_text,json=meaningDvCodedText,proto3,oneof"`
}

func (*ReferenceRangeDvDateTime_MeaningDvText) isReferenceRangeDvDateTime_Meaning() {}

func (*ReferenceRangeDvDateTime_MeaningDvCodedText) isReferenceRangeDvDateTime_Meaning() {}

// Defines a named range to be associated with any DV_ORDERED datum.
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges.
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
type ReferenceRangeDvQuantity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
	//
	// Types that are valid to be assigned to Meaning:
	//
	//	*ReferenceRangeDvQuantity_MeaningDvText
	//	*ReferenceRangeDvQuantity_MeaningDvCodedText
	Meaning isReferenceRangeDvQuantity_Meaning `protobuf_oneof:"meaning"`
	// The data range for this meaning, e.g. critical etc.
	Range         *DvIntervalDvQuantity `protobuf:"bytes,3,opt,name=range,proto3" json:"range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReferenceRangeDvQuantity) Reset() {
	*x = ReferenceRangeDvQuantity{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReferenceRangeDvQuantity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReferenceRangeDvQuantity) ProtoMessage() {}

func (x *ReferenceRangeDvQuantity) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReferenceRangeDvQuantity.ProtoReflect.Descriptor instead.
func (*ReferenceRangeDvQuantity) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{46}
}

func (x *ReferenceRangeDvQuantity) GetMeaning() isReferenceRangeDvQuantity_Meaning {
	if x != nil {
		return x.Meaning
	}
	return nil
}

func (x *ReferenceRangeDvQuantity) GetMeaningDvText() *DvText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvQuantity_MeaningDvText); ok {
			return x.MeaningDvText
		}
	}
	return nil
}

func (x *ReferenceRangeDvQuantity) GetMeaningDvCodedText() *DvCodedText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvQuantity_MeaningDvCodedText); ok {
			return x.MeaningDvCodedText
		}
	}
	return nil
}

func (x *ReferenceRangeDvQuantity) GetRange() *DvIntervalDvQuantity {
	if x != nil {
		return x.Range
	}
	return nil
}

type isReferenceRangeDvQuantity_Meaning interface {
	isReferenceRangeDvQuantity_Meaning()
}

type ReferenceRangeDvQuantity_MeaningDvText struct {
	MeaningDvText *DvText `protobuf:"bytes,1,opt,name=meaning_dv_text,json=meaningDvText,proto3,oneof"`
}

type ReferenceRangeDvQuantity_MeaningDvCodedText struct {
	MeaningDvCodedText *DvCodedText `protobuf:"bytes,2,opt,name=meaning_dv_coded_text,json=meaningDvCodedText,proto3,oneof"`
}

func (*ReferenceRangeDvQuantity_MeaningDvText) isReferenceRangeDvQuantity_Meaning() {}

func (*ReferenceRangeDvQuantity_MeaningDvCodedText) isReferenceRangeDvQuantity_Meaning() {}

// Defines a named range to be associated with any DV_ORDERED datum.
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges.
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
type ReferenceRangeDvCount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
	//
	// Types that are valid to be assigned to Meaning:
	//
	//	*ReferenceRangeDvCount_MeaningDvText
	//	*ReferenceRangeDvCount_MeaningDvCodedText
	Meaning isReferenceRangeDvCount_Meaning `protobuf_oneof:"meaning"`
	// The data range for this meaning, e.g. critical etc.
	Range         *DvIntervalDvCount `protobuf:"bytes,3,opt,name=range,proto3" json:"range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReferenceRangeDvCount) Reset() {
	*x = ReferenceRangeDvCount{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReferenceRangeDvCount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReferenceRangeDvCount) ProtoMessage() {}

func (x *ReferenceRangeDvCount) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReferenceRangeDvCount.ProtoReflect.Descriptor instead.
func (*ReferenceRangeDvCount) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{47}
}

func (x *ReferenceRangeDvCount) GetMeaning() isReferenceRangeDvCount_Meaning {
	if x != nil {
		return x.Meaning
	}
	return nil
}

func (x *ReferenceRangeDvCount) GetMeaningDvText() *DvText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvCount_MeaningDvText); ok {
			return x.MeaningDvText
		}
	}
	return nil
}

func (x *ReferenceRangeDvCount) GetMeaningDvCodedText() *DvCodedText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvCount_MeaningDvCodedText); ok {
			return x.MeaningDvCodedText
		}
	}
	return nil
}

func (x *ReferenceRangeDvCount) GetRange() *DvIntervalDvCount {
	if x != nil {
		return x.Range
	}
	return nil
}

type isReferenceRangeDvCount_Meaning interface {
	isReferenceRangeDvCount_Meaning()
}

type ReferenceRangeDvCount_MeaningDvText struct {
	MeaningDvText *DvText `protobuf:"bytes,1,opt,name=meaning_dv_text,json=meaningDvText,proto3,oneof"`
}

type ReferenceRangeDvCount_MeaningDvCodedText struct {
	MeaningDvCodedText *DvCodedText `protobuf:"bytes,2,opt,name=meaning_dv_coded_text,json=meaningDvCodedText,proto3,oneof"`
}

func (*ReferenceRangeDvCount_MeaningDvText) isReferenceRangeDvCount_Meaning() {}

func (*ReferenceRangeDvCount_MeaningDvCodedText) isReferenceRangeDvCount_Meaning() {}

// Defines a named range to be associated with any DV_ORDERED datum.
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges.
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
type ReferenceRangeDvProportion struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
	//
	// Types that are valid to be assigned to Meaning:
	//
	//	*ReferenceRangeDvProportion_MeaningDvText
	//	*ReferenceRangeDvProportion_MeaningDvCodedText
	Meaning isReferenceRangeDvProportion_Meaning `protobuf_oneof:"meaning"`
	// The data range for this meaning, e.g. critical etc.
	Range         *DvIntervalDvProportion `protobuf:"bytes,3,opt,name=range,proto3" json:"range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReferenceRangeDvProportion) Reset() {
	*x = ReferenceRangeDvProportion{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReferenceRangeDvProportion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReferenceRangeDvProportion) ProtoMessage() {}

func (x *ReferenceRangeDvProportion) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReferenceRangeDvProportion.ProtoReflect.Descriptor instead.
func (*ReferenceRangeDvProportion) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{48}
}

func (x *ReferenceRangeDvProportion) GetMeaning() isReferenceRangeDvProportion_Meaning {
	if x != nil {
		return x.Meaning
	}
	return nil
}

func (x *ReferenceRangeDvProportion) GetMeaningDvText() *DvText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvProportion_MeaningDvText); ok {
			return x.MeaningDvText
		}
	}
	return nil
}

func (x *ReferenceRangeDvProportion) GetMeaningDvCodedText() *DvCodedText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvProportion_MeaningDvCodedText); ok {
			return x.MeaningDvCodedText
		}
	}
	return nil
}

func (x *ReferenceRangeDvProportion) GetRange() *DvIntervalDvProportion {
	if x != nil {
		return x.Range
	}
	return nil
}

type isReferenceRangeDvProportion_Meaning interface {
	isReferenceRangeDvProportion_Meaning()
}

type ReferenceRangeDvProportion_MeaningDvText struct {
	MeaningDvText *DvText `protobuf:"bytes,1,opt,name=meaning_dv_text,json=meaningDvText,proto3,oneof"`
}

type ReferenceRangeDvProportion_MeaningDvCodedText struct {
	MeaningDvCodedText *DvCodedText `protobuf:"bytes,2,opt,name=meaning_dv_coded_text,json=meaningDvCodedText,proto3,oneof"`
}

func (*ReferenceRangeDvProportion_MeaningDvText) isReferenceRangeDvProportion_Meaning() {}

func (*ReferenceRangeDvProportion_MeaningDvCodedText) isReferenceRangeDvProportion_Meaning() {}

// A data type that represents integral score values, e.g. pain, Apgar values, etc, where there is:
//
// a) implied ordering, b) no implication that the distance between each value is constant, and c) the total number of values is finite; d) integer values only.
//
// Note that although the term 'ordinal' in mathematics means natural numbers only, here any integer is allowed, since negative and zero values are often used by medical professionals for values around a neutral point. Examples of sets of ordinal values:
//
// - -3, -2, -1, 0, 1, 2, 3 reflex response values
// - 0, 1, 2 Apgar values
//
// This class is used for recording any clinical datum which is customarily recorded using symbolic values. Example: the results on a urinalysis strip, e.g. {neg, trace, +, , +} are used for leucocytes, protein, nitrites etc; for non-haemolysed blood {neg, trace, moderate}; for haemolysed blood {small, moderate, large}.
//
// For scores or scales that include Real numbers (or might in the future, i.e. not fixed for all time, such as Apgar), use DV_SCALE. DV_SCALE may also be used in future for representing purely Integer-based scales, however, the DV_ORDINAL type should continue to be supported in software implementations in order to accommodate existing data that are instances of this type.
type DvOrdinal struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
	NormalStatus *CodePhrase `protobuf:"bytes,1,opt,name=normal_status,json=normalStatus,proto3,oneof" json:"normal_status,omitempty"`
	// Optional normal range.
	NormalRange *DvIntervalInt64 `protobuf:"bytes,2,opt,name=normal_range,json=normalRange,proto3,oneof" json:"normal_range,omitempty"`
	// Optional tagged other reference ranges for this value in its particular measurement context.
	OtherReferenceRanges []*ReferenceRangeInt64 `protobuf:"bytes,3,rep,name=other_reference_ranges,json=otherReferenceRanges,proto3" json:"other_reference_ranges,omitempty"`
	// Coded textual representation of this value in the enumeration, which may be strings made from + symbols, or other enumerations of terms such as mild, moderate, severe, or even the same number series as the values, e.g. 1, 2, 3.
	Symbol *DvCodedText `protobuf:"bytes,4,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// Value in ordered enumeration of values. Any integer value can be used.
	Value         int64 `protobuf:"varint,5,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvOrdinal) Reset() {
	*x = DvOrdinal{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvOrdinal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvOrdinal) ProtoMessage() {}

func (x *DvOrdinal) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvOrdinal.ProtoReflect.Descriptor instead.
func (*DvOrdinal) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{49}
}

func (x *DvOrdinal) GetNormalStatus() *CodePhrase {
	if x != nil {
		return x.NormalStatus
	}
	return nil
}

func (x *DvOrdinal) GetNormalRange() *DvIntervalInt64 {
	if x != nil {
		return x.NormalRange
	}
	return nil
}

func (x *DvOrdinal) GetOtherReferenceRanges() []*ReferenceRangeInt64 {
	if x != nil {
		return x.OtherReferenceRanges
	}
	return nil
}

func (x *DvOrdinal) GetSymbol() *DvCodedText {
	if x != nil {
		return x.Symbol
	}
	return nil
}

func (x *DvOrdinal) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

// A data type that represents scale values, where there is:
//
// a) implied ordering, b) no implication that the distance between each value is constant, and c) the total number of values is finite; d) non-integer values are allowed.
//
// Example:
//
// # Borg CR 10 Scale
//
// 0    No Breathlessness at all
// 0.5  Very Very Slight (Just Noticeable)
// 1    Very Slight
// 2    Slight Breathlessness
// 3    Moderate
// ... etc
//
// For scores that include only Integers, DV_SCALE may also be used, but DV_ORDINAL should be supported to accommodate existing data instances of that type.
type DvScale struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
	NormalStatus *CodePhrase `protobuf:"bytes,1,opt,name=normal_status,json=normalStatus,proto3,oneof" json:"normal_status,omitempty"`
	// Optional normal range.
	NormalRange *DvIntervalInt64 `protobuf:"bytes,2,opt,name=normal_range,json=normalRange,proto3,oneof" json:"normal_range,omitempty"`
	// Optional tagged other reference ranges for this value in its particular measurement context.
	OtherReferenceRanges []*ReferenceRangeInt64 `protobuf:"bytes,3,rep,name=other_reference_ranges,json=otherReferenceRanges,proto3" json:"other_reference_ranges,omitempty"`
	// Coded textual representation of this value in the scale range, which may be strings made from symbols or other enumerations of terms such as no breathlessness, very very slight, slight breathlessness. Codes come from archetypes.
	//
	// In some cases, a scale may include values that have no code/symbol. In this case, the symbol will be a DV-CODED_TEXT including the terminology_id and a blank String value for code_string.
	Symbol *DvCodedText `protobuf:"bytes,4,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// Real number value of Scale item.
	Value         float32 `protobuf:"fixed32,5,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvScale) Reset() {
	*x = DvScale{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvScale) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvScale) ProtoMessage() {}

func (x *DvScale) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvScale.ProtoReflect.Descriptor instead.
func (*DvScale) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{50}
}

func (x *DvScale) GetNormalStatus() *CodePhrase {
	if x != nil {
		return x.NormalStatus
	}
	return nil
}

func (x *DvScale) GetNormalRange() *DvIntervalInt64 {
	if x != nil {
		return x.NormalRange
	}
	return nil
}

func (x *DvScale) GetOtherReferenceRanges() []*ReferenceRangeInt64 {
	if x != nil {
		return x.OtherReferenceRanges
	}
	return nil
}

func (x *DvScale) GetSymbol() *DvCodedText {
	if x != nil {
		return x.Symbol
	}
	return nil
}

func (x *DvScale) GetValue() float32 {
	if x != nil {
		return x.Value
	}
	return 0
}

// Quantitified type representing scientific quantities, i.e. quantities expressed as a magnitude and units. Units are expressed in the UCUM syntax (Unified Code for Units of Measure (UCUM), by Gunther Schadow and Clement J. McDonald of The Regenstrief Institute) (case-sensitive form) by default, or another system if units_system is set.
//
// Can also be used for time durations, where it is more convenient to treat these as simply a number of seconds rather than days, months, years (in the latter case, DV_DURATION may be used).
type DvQuantity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
	NormalStatus *CodePhrase `protobuf:"bytes,1,opt,name=normal_status,json=normalStatus,proto3,oneof" json:"normal_status,omitempty"`
	// Optional normal range.
	NormalRange *DvIntervalDvQuantity `protobuf:"bytes,2,opt,name=normal_range,json=normalRange,proto3,oneof" json:"normal_range,omitempty"`
	// Optional tagged other reference ranges for this value in its particular measurement context.
	OtherReferenceRanges []*ReferenceRangeDvQuantity `protobuf:"bytes,3,rep,name=other_reference_ranges,json=otherReferenceRanges,proto3" json:"other_reference_ranges,omitempty"`
	// Optional status of magnitude with values:
	//
	// - "=" : magnitude is a point value
	// - "<" : value is < magnitude
	// - ">" : value is > magnitude
	// - "<=" : value is <= magnitude
	// - ">=" : value is >= magnitude
	// - "~" : value is approximately magnitude
	//
	// If not present, assumed meaning is "=" .
	MagnitudeStatus *string `protobuf:"bytes,4,opt,name=magnitude_status,json=magnitudeStatus,proto3,oneof" json:"magnitude_status,omitempty"`
	// If True, indicates that when this object was created, accuracy was recorded as a percent value; if False, as an absolute quantity value.
	AccuracyIsPercent *bool `protobuf:"varint,5,opt,name=accuracy_is_percent,json=accuracyIsPercent,proto3,oneof" json:"accuracy_is_percent,omitempty"`
	// Accuracy of measurement, expressed either as a half-range percent value (accuracy_is_percent = True) or a half-range quantity. A value of 0 means that accuracy is 100%, i.e. no error.
	//
	// A value of unknown_accuracy_value means that accuracy was not recorded.
	Accuracy *float32 `protobuf:"fixed32,6,opt,name=accuracy,proto3,oneof" json:"accuracy,omitempty"`
	// Numeric magnitude of the quantity.
	Magnitude float32 `protobuf:"fixed32,7,opt,name=magnitude,proto3" json:"magnitude,omitempty"`
	// Precision to which the value of the quantity is expressed, in terms of number of decimal places. The value 0 implies an integral quantity. The value -1 implies no limit, i.e. any number of decimal places.
	Precision *int64 `protobuf:"varint,8,opt,name=precision,proto3,oneof" json:"precision,omitempty"`
	// Quantity units, expressed as a code or syntax string from either UCUM (the default) or the units system specified in units_system, when set.
	//
	// In either case, the value is the code or syntax - normally formed of standard ASCII - which is in principal not the same as the display string, although in simple cases such as 'm' (for meters) it will be.
	//
	// If the units_display_name field is set, this may be used for display. If not, the implementations must effect the resolution of the units value to a display form locally, e.g. by lookup of reference tables, request to a terminology service etc.
	//
	// Example values from UCUM: "kg/m^2", mm[Hg]", "ms-1", "km/h".
	Units string `protobuf:"bytes,9,opt,name=units,proto3" json:"units,omitempty"`
	// Optional field used to specify a units system from which codes in units are defined. Value is a URI identifying a terminology containing units concepts from the (HL7 FHIR terminologies list).
	//
	// If not set, the UCUM standard (case-sensitive codes) is assumed as the units system.
	UnitsSystem *string `protobuf:"bytes,10,opt,name=units_system,json=unitsSystem,proto3,oneof" json:"units_system,omitempty"`
	// Optional field containing the displayable form of the units field, e.g. 'C'.
	//
	// If not set, the application environment needs to determine the displayable form.
	UnitsDisplayName *string `protobuf:"bytes,11,opt,name=units_display_name,json=unitsDisplayName,proto3,oneof" json:"units_display_name,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *DvQuantity) Reset() {
	*x = DvQuantity{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvQuantity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvQuantity) ProtoMessage() {}

func (x *DvQuantity) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvQuantity.ProtoReflect.Descriptor instead.
func (*DvQuantity) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{51}
}

func (x *DvQuantity) GetNormalStatus() *CodePhrase {
	if x != nil {
		return x.NormalStatus
	}
	return nil
}

func (x *DvQuantity) GetNormalRange() *DvIntervalDvQuantity {
	if x != nil {
		return x.NormalRange
	}
	return nil
}

func (x *DvQuantity) GetOtherReferenceRanges() []*ReferenceRangeDvQuantity {
	if x != nil {
		return x.OtherReferenceRanges
	}
	return nil
}

func (x *DvQuantity) GetMagnitudeStatus() string {
	if x != nil && x.MagnitudeStatus != nil {
		return *x.MagnitudeStatus
	}
	return ""
}

func (x *DvQuantity) GetAccuracyIsPercent() bool {
	if x != nil && x.AccuracyIsPercent != nil {
		return *x.AccuracyIsPercent
	}
	return false
}

func (x *DvQuantity) GetAccuracy() float32 {
	if x != nil && x.Accuracy != nil {
		return *x.Accuracy
	}
	return 0
}

func (x *DvQuantity) GetMagnitude() float32 {
	if x != nil {
		return x.Magnitude
	}
	return 0
}

func (x *DvQuantity) GetPrecision() int64 {
	if x != nil && x.Precision != nil {
		return *x.Precision
	}
	return 0
}

func (x *DvQuantity) GetUnits() string {
	if x != nil {
		return x.Units
	}
	return ""
}

func (x *DvQuantity) GetUnitsSystem() string {
	if x != nil && x.UnitsSystem != nil {
		return *x.UnitsSystem
	}
	return ""
}

func (x *DvQuantity) GetUnitsDisplayName() string {
	if x != nil && x.UnitsDisplayName != nil {
		return *x.UnitsDisplayName
	}
	return ""
}

// Countable quantities. Used for countable types such as pregnancies and steps (taken by a physiotherapy patient), number of cigarettes smoked in a day.
//
// Misuse: Not to be used for amounts of physical entities (which all have units).
type DvCount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
	NormalStatus *CodePhrase `protobuf:"bytes,1,opt,name=normal_status,json=normalStatus,proto3,oneof" json:"normal_status,omitempty"`
	// Optional normal range.
	NormalRange *DvIntervalDvCount `protobuf:"bytes,2,opt,name=normal_range,json=normalRange,proto3,oneof" json:"normal_range,omitempty"`
	// Optional tagged other reference ranges for this value in its particular measurement context.
	OtherReferenceRanges []*ReferenceRangeDvCount `protobuf:"bytes,3,rep,name=other_reference_ranges,json=otherReferenceRanges,proto3" json:"other_reference_ranges,omitempty"`
	// Optional status of magnitude with values:
	//
	// - "=" : magnitude is a point value
	// - "<" : value is < magnitude
	// - ">" : value is > magnitude
	// - "<=" : value is <= magnitude
	// - ">=" : value is >= magnitude
	// - "~" : value is approximately magnitude
	//
	// If not present, assumed meaning is "=" .
	MagnitudeStatus *string `protobuf:"bytes,4,opt,name=magnitude_status,json=magnitudeStatus,proto3,oneof" json:"magnitude_status,omitempty"`
	// If True, indicates that when this object was created, accuracy was recorded as a percent value; if False, as an absolute quantity value.
	AccuracyIsPercent *bool `protobuf:"varint,5,opt,name=accuracy_is_percent,json=accuracyIsPercent,proto3,oneof" json:"accuracy_is_percent,omitempty"`
	// Accuracy of measurement, expressed either as a half-range percent value (accuracy_is_percent = True) or a half-range quantity. A value of 0 means that accuracy is 100%, i.e. no error.
	//
	// A value of unknown_accuracy_value means that accuracy was not recorded.
	Accuracy *float32 `protobuf:"fixed32,6,opt,name=accuracy,proto3,oneof" json:"accuracy,omitempty"`
	Magnitude     int64 `protobuf:"varint,7,opt,name=magnitude,proto3" json:"magnitude,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvCount) Reset() {
	*x = DvCount{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvCount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvCount) ProtoMessage() {}

func (x *DvCount) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvCount.ProtoReflect.Descriptor instead.
func (*DvCount) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{52}
}

func (x *DvCount) GetNormalStatus() *CodePhrase {
	if x != nil {
		return x.NormalStatus
	}
	return nil
}

func (x *DvCount) GetNormalRange() *DvIntervalDvCount {
	if x != nil {
		return x.NormalRange
	}
	return nil
}

func (x *DvCount) GetOtherReferenceRanges() []*ReferenceRangeDvCount {
	if x != nil {
		return x.OtherReferenceRanges
	}
	return nil
}

func (x *DvCount) GetMagnitudeStatus() string {
	if x != nil && x.MagnitudeStatus != nil {
		return *x.MagnitudeStatus
	}
	return ""
}

func (x *DvCount) GetAccuracyIsPercent() bool {
	if x != nil && x.AccuracyIsPercent != nil {
		return *x.AccuracyIsPercent
	}
	return false
}

func (x *DvCount) GetAccuracy() float32 {
	if x != nil && x.Accuracy != nil {
		return *x.Accuracy
	}
	return 0
}

func (x *DvCount) GetMagnitude() int64 {
	if x != nil {
		return x.Magnitude
	}
	return 0
}

// Models a ratio of values, i.e. where the numerator and denominator are both pure numbers. The valid_proportion_kind property of the PROPORTION_KIND class is used to control the type attribute to be one of a defined set.
//
// Used for recording titers (e.g. 1:128), concentration ratios, e.g. Na:K (unitary denominator), albumin:creatinine ratio, and percentages, e.g. red cell distirbution width (RDW).
//
// Misuse: Should not be used to represent things like blood pressure which are often written using a '/' character, giving the misleading impression that the item is a ratio, when in fact it is a structured value. Similarly, visual acuity, often written as (e.g.) "6/24" in clinical notes is not a ratio but an ordinal (which includes non-numeric symbols like CF = count fingers etc). Should not be used for formulations.
type DvProportion struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
	NormalStatus *CodePhrase `protobuf:"bytes,1,opt,name=normal_status,json=normalStatus,proto3,oneof" json:"normal_status,omitempty"`
	// Optional normal range.
	NormalRange *DvIntervalDvProportion `protobuf:"bytes,2,opt,name=normal_range,json=normalRange,proto3,oneof" json:"normal_range,omitempty"`
	// Optional tagged other reference ranges for this value in its particular measurement context.
	OtherReferenceRanges []*ReferenceRangeDvProportion `protobuf:"bytes,3,rep,name=other_reference_ranges,json=otherReferenceRanges,proto3" json:"other_reference_ranges,omitempty"`
	// Optional status of magnitude with values:
	//
	// - "=" : magnitude is a point value
	// - "<" : value is < magnitude
	// - ">" : value is > magnitude
	// - "<=" : value is <= magnitude
	// - ">=" : value is >= magnitude
	// - "~" : value is approximately magnitude
	//
	// If not present, assumed meaning is "=" .
	MagnitudeStatus *string `protobuf:"bytes,4,opt,name=magnitude_status,json=magnitudeStatus,proto3,oneof" json:"magnitude_status,omitempty"`
	// If True, indicates that when this object was created, accuracy was recorded as a percent value; if False, as an absolute quantity value.
	AccuracyIsPercent *bool `protobuf:"varint,5,opt,name=accuracy_is_percent,json=accuracyIsPercent,proto3,oneof" json:"accuracy_is_percent,omitempty"`
	// Accuracy of measurement, expressed either as a half-range percent value (accuracy_is_percent = True) or a half-range quantity. A value of 0 means that accuracy is 100%, i.e. no error.
	//
	// A value of unknown_accuracy_value means that accuracy was not recorded.
	Accuracy *float32 `protobuf:"fixed32,6,opt,name=accuracy,proto3,oneof" json:"accuracy,omitempty"`
	// Numerator of ratio
	Numerator float32 `protobuf:"fixed32,7,opt,name=numerator,proto3" json:"numerator,omitempty"`
	// Denominator of ratio.
	Denominator float32 `protobuf:"fixed32,8,opt,name=denominator,proto3" json:"denominator,omitempty"`
	// Indicates semantic type of proportion, including percent, unitary etc.
	Type int64 `protobuf:"varint,9,opt,name=type,proto3" json:"type,omitempty"`
	// Indicates semantic type of proportion, including percent, unitary etc.
	Precision     *int64 `protobuf:"varint,10,opt,name=precision,proto3,oneof" json:"precision,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvProportion) Reset() {
	*x = DvProportion{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvProportion) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvProportion) ProtoMessage() {}

func (x *DvProportion) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvProportion.ProtoReflect.Descriptor instead.
func (*DvProportion) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{53}
}

func (x *DvProportion) GetNormalStatus() *CodePhrase {
	if x != nil {
		return x.NormalStatus
	}
	return nil
}

func (x *DvProportion) GetNormalRange() *DvIntervalDvProportion {
	if x != nil {
		return x.NormalRange
	}
	return nil
}

func (x *DvProportion) GetOtherReferenceRanges() []*ReferenceRangeDvProportion {
	if x != nil {
		return x.OtherReferenceRanges
	}
	return nil
}

func (x *DvProportion) GetMagnitudeStatus() string {
	if x != nil && x.MagnitudeStatus != nil {
		return *x.MagnitudeStatus
	}
	return ""
}

func (x *DvProportion) GetAccuracyIsPercent() bool {
	if x != nil && x.AccuracyIsPercent != nil {
		return *x.AccuracyIsPercent
	}
	return false
}

func (x *DvProportion) GetAccuracy() float32 {
	if x != nil && x.Accuracy != nil {
		return *x.Accuracy
	}
	return 0
}

func (x *DvProportion) GetNumerator() float32 {
	if x != nil {
		return x.Numerator
	}
	return 0
}

func (x *DvProportion) GetDenominator() float32 {
	if x != nil {
		return x.Denominator
	}
	return 0
}

func (x *DvProportion) GetType() int64 {
	if x != nil {
		return x.Type
	}
	return 0
}

func (x *DvProportion) GetPrecision() int64 {
	if x != nil && x.Precision != nil {
		return *x.Precision
	}
	return 0
}

// Represents an absolute point in time, as measured on the Gregorian calendar, and specified only to the day. Semantics defined by ISO 8601. Used for recording dates in real world time. The partial form is used for approximate birth dates, dates of death, etc.
type DvDate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
	NormalStatus *CodePhrase `protobuf:"bytes,1,opt,name=normal_status,json=normalStatus,proto3,oneof" json:"normal_status,omitempty"`
	// Optional normal range.
	NormalRange *DvIntervalDvProportion `protobuf:"bytes,2,opt,name=normal_range,json=normalRange,proto3,oneof" json:"normal_range,omitempty"`
	// Optional tagged other reference ranges for this value in its particular measurement context.
	OtherReferenceRanges []*ReferenceRangeDvProportion `protobuf:"bytes,3,rep,name=other_reference_ranges,json=otherReferenceRanges,proto3" json:"other_reference_ranges,omitempty"`
	// Optional status of magnitude with values:
	//
	// - "=" : magnitude is a point value
	// - "<" : value is < magnitude
	// - ">" : value is > magnitude
	// - "<=" : value is <= magnitude
	// - ">=" : value is >= magnitude
	// - "~" : value is approximately magnitude
	//
	// If not present, assumed meaning is "=" .
	MagnitudeStatus *string `protobuf:"bytes,4,opt,name=magnitude_status,json=magnitudeStatus,proto3,oneof" json:"magnitude_status,omitempty"`
	// Time accuracy, expressed as a duration.
	Accuracy *DvDuration `protobuf:"bytes,5,opt,name=accuracy,proto3,oneof" json:"accuracy,omitempty"`
	// ISO8601 date string.
	Value         string `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvDate) Reset() {
	*x = DvDate{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvDate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvDate) ProtoMessage() {}

func (x *DvDate) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvDate.ProtoReflect.Descriptor instead.
func (*DvDate) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{54}
}

func (x *DvDate) GetNormalStatus() *CodePhrase {
	if x != nil {
		return x.NormalStatus
	}
	return nil
}

func (x *DvDate) GetNormalRange() *DvIntervalDvProportion {
	if x != nil {
		return x.NormalRange
	}
	return nil
}

func (x *DvDate) GetOtherReferenceRanges() []*ReferenceRangeDvProportion {
	if x != nil {
		return x.OtherReferenceRanges
	}
	return nil
}

func (x *DvDate) GetMagnitudeStatus() string {
	if x != nil && x.MagnitudeStatus != nil {
		return *x.MagnitudeStatus
	}
	return ""
}

func (x *DvDate) GetAccuracy() *DvDuration {
	if x != nil {
		return x.Accuracy
	}
	return nil
}

func (x *DvDate) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Represents an absolute point in time from an origin usually interpreted as meaning the start of the current day, specified to a fraction of a second. Semantics defined by ISO 8601.
//
// Used for recording real world times, rather than scientifically measured fine amounts of time. The partial form is used for approximate times of events and substance administrations.
type DvTime struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
	NormalStatus *CodePhrase `protobuf:"bytes,1,opt,name=normal_status,json=normalStatus,proto3,oneof" json:"normal_status,omitempty"`
	// Optional normal range.
	NormalRange *DvIntervalDvProportion `protobuf:"bytes,2,opt,name=normal_range,json=normalRange,proto3,oneof" json:"normal_range,omitempty"`
	// Optional tagged other reference ranges for this value in its particular measurement context.
	OtherReferenceRanges []*ReferenceRangeDvProportion `protobuf:"bytes,3,rep,name=other_reference_ranges,json=otherReferenceRanges,proto3" json:"other_reference_ranges,omitempty"`
	// Optional status of magnitude with values:
	//
	// - "=" : magnitude is a point value
	// - "<" : value is < magnitude
	// - ">" : value is > magnitude
	// - "<=" : value is <= magnitude
	// - ">=" : value is >= magnitude
	// - "~" : value is approximately magnitude
	//
	// If not present, assumed meaning is "=" .
	MagnitudeStatus *string `protobuf:"bytes,4,opt,name=magnitude_status,json=magnitudeStatus,proto3,oneof" json:"magnitude_status,omitempty"`
	// Time accuracy, expressed as a duration.
	Accuracy *DvDuration `protobuf:"bytes,5,opt,name=accuracy,proto3,oneof" json:"accuracy,omitempty"`
	// ISO8601 time string.
	Value         string `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvTime) Reset() {
	*x = DvTime{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvTime) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvTime) ProtoMessage() {}

func (x *DvTime) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvTime.ProtoReflect.Descriptor instead.
func (*DvTime) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{55}
}

func (x *DvTime) GetNormalStatus() *CodePhrase {
	if x != nil {
		return x.NormalStatus
	}
	return nil
}

func (x *DvTime) GetNormalRange() *DvIntervalDvProportion {
	if x != nil {
		return x.NormalRange
	}
	return nil
}

func (x *DvTime) GetOtherReferenceRanges() []*ReferenceRangeDvProportion {
	if x != nil {
		return x.OtherReferenceRanges
	}
	return nil
}

func (x *DvTime) GetMagnitudeStatus() string {
	if x != nil && x.MagnitudeStatus != nil {
		return *x.MagnitudeStatus
	}
	return ""
}

func (x *DvTime) GetAccuracy() *DvDuration {
	if x != nil {
		return x.Accuracy
	}
	return nil
}

func (x *DvTime) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Represents an absolute point in time, specified to the second. Semantics defined by ISO 8601.
//
// Used for recording a precise point in real world time, and for approximate time stamps, e.g. the origin of a HISTORY in an OBSERVATION which is only partially known.
type DvDateTime struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
	NormalStatus *CodePhrase `protobuf:"bytes,1,opt,name=normal_status,json=normalStatus,proto3,oneof" json:"normal_status,omitempty"`
	// Optional normal range.
	NormalRange *DvIntervalDvProportion `protobuf:"bytes,2,opt,name=normal_range,json=normalRange,proto3,oneof" json:"normal_range,omitempty"`
	// Optional tagged other reference ranges for this value in its particular measurement context.
	OtherReferenceRanges []*ReferenceRangeDvProportion `protobuf:"bytes,3,rep,name=other_reference_ranges,json=otherReferenceRanges,proto3" json:"other_reference_ranges,omitempty"`
	// Optional status of magnitude with values:
	//
	// - "=" : magnitude is a point value
	// - "<" : value is < magnitude
	// - ">" : value is > magnitude
	// - "<=" : value is <= magnitude
	// - ">=" : value is >= magnitude
	// - "~" : value is approximately magnitude
	//
	// If not present, assumed meaning is "=" .
	MagnitudeStatus *string `protobuf:"bytes,4,opt,name=magnitude_status,json=magnitudeStatus,proto3,oneof" json:"magnitude_status,omitempty"`
	// Time accuracy, expressed as a duration.
	Accuracy *DvDuration `protobuf:"bytes,5,opt,name=accuracy,proto3,oneof" json:"accuracy,omitempty"`
	// ISO8601 date/time string.
	Value         string `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvDateTime) Reset() {
	*x = DvDateTime{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvDateTime) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvDateTime) ProtoMessage() {}

func (x *DvDateTime) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvDateTime.ProtoReflect.Descriptor instead.
func (*DvDateTime) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{56}
}

func (x *DvDateTime) GetNormalStatus() *CodePhrase {
	if x != nil {
		return x.NormalStatus
	}
	return nil
}

func (x *DvDateTime) GetNormalRange() *DvIntervalDvProportion {
	if x != nil {
		return x.NormalRange
	}
	return nil
}

func (x *DvDateTime) GetOtherReferenceRanges() []*ReferenceRangeDvProportion {
	if x != nil {
		return x.OtherReferenceRanges
	}
	return nil
}

func (x *DvDateTime) GetMagnitudeStatus() string {
	if x != nil && x.MagnitudeStatus != nil {
		return *x.MagnitudeStatus
	}
	return ""
}

func (x *DvDateTime) GetAccuracy() *DvDuration {
	if x != nil {
		return x.Accuracy
	}
	return nil
}

func (x *DvDateTime) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Represents a period of time with respect to a notional point in time, which is not specified.
// A sign may be used to indicate the duration is backwards in time rather than forwards.
//
// Used for recording the duration of something in the real world, particularly when there is a need a) to represent the duration in customary format, i.e. days, hours, minutes etc, and b) if it will be used in computational operations with date/time quantities, i.e. additions, subtractions etc.
//
// Misuse: Durations cannot be used to represent points in time, or intervals of time.
type DvDuration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional normal status indicator of value with respect to normal range for this value.
	// Often included by lab, even if the normal range itself is not included.
	// Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
	NormalStatus *CodePhrase `protobuf:"bytes,1,opt,name=normal_status,json=normalStatus,proto3,oneof" json:"normal_status,omitempty"`
	// Optional normal range.
	NormalRange *DvIntervalDvDateTime `protobuf:"bytes,2,opt,name=normal_range,json=normalRange,proto3,oneof" json:"normal_range,omitempty"`
	// Optional tagged other reference ranges for this value in its particular measurement context.
	OtherReferenceRanges []*ReferenceRangeDvDateTime `protobuf:"bytes,3,rep,name=other_reference_ranges,json=otherReferenceRanges,proto3" json:"other_reference_ranges,omitempty"`
	// Optional status of magnitude with values:
	//
	// - "=" : magnitude is a point value
	// - "<" : value is < magnitude
	// - ">" : value is > magnitude
	// - "<=" : value is <= magnitude
	// - ">=" : value is >= magnitude
	// - "~" : value is approximately magnitude
	//
	// If not present, assumed meaning is "=" .
	MagnitudeStatus *string `protobuf:"bytes,4,opt,name=magnitude_status,json=magnitudeStatus,proto3,oneof" json:"magnitude_status,omitempty"`
	// If True, indicates that when this object was created, accuracy was recorded as a percent value; if False, as an absolute quantity value.
	AccuracyIsPercent *bool `protobuf:"varint,5,opt,name=accuracy_is_percent,json=accuracyIsPercent,proto3,oneof" json:"accuracy_is_percent,omitempty"`
	// Accuracy of measurement, expressed either as a half-range percent value (accuracy_is_percent = True) or a half-range quantity. A value of 0 means that accuracy is 100%, i.e. no error.
	//
	// A value of unknown_accuracy_value means that accuracy was not recorded.
	Accuracy *float64 `protobuf:"fixed64,6,opt,name=accuracy,proto3,oneof" json:"accuracy,omitempty"`
	// ISO8601 duration string, including described deviations to support negative values and weeks.
	Value         string `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvDuration) Reset() {
	*x = DvDuration{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvDuration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvDuration) ProtoMessage() {}

func (x *DvDuration) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvDuration.ProtoReflect.Descriptor instead.
func (*DvDuration) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{57}
}

func (x *DvDuration) GetNormalStatus() *CodePhrase {
	if x != nil {
		return x.NormalStatus
	}
	return nil
}

func (x *DvDuration) GetNormalRange() *DvIntervalDvDateTime {
	if x != nil {
		return x.NormalRange
	}
	return nil
}

func (x *DvDuration) GetOtherReferenceRanges() []*ReferenceRangeDvDateTime {
	if x != nil {
		return x.OtherReferenceRanges
	}
	return nil
}

func (x *DvDuration) GetMagnitudeStatus() string {
	if x != nil && x.MagnitudeStatus != nil {
		return *x.MagnitudeStatus
	}
	return ""
}

func (x *DvDuration) GetAccuracyIsPercent() bool {
	if x != nil && x.AccuracyIsPercent != nil {
		return *x.AccuracyIsPercent
	}
	return false
}

func (x *DvDuration) GetAccuracy() float64 {
	if x != nil && x.Accuracy != nil {
		return *x.Accuracy
	}
	return 0
}

func (x *DvDuration) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// Specifies points in time in a general syntax. Based on the HL7v3 GTS data type.
type DvPeriodicTimeSpecification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The specification, in the HL7v3 syntax for PIVL or EIVL types.
	Value         *DvParsable `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvPeriodicTimeSpecification) Reset() {
	*x = DvPeriodicTimeSpecification{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvPeriodicTimeSpecification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvPeriodicTimeSpecification) ProtoMessage() {}

func (x *DvPeriodicTimeSpecification) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvPeriodicTimeSpecification.ProtoReflect.Descriptor instead.
func (*DvPeriodicTimeSpecification) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{58}
}

func (x *DvPeriodicTimeSpecification) GetValue() *DvParsable {
	if x != nil {
		return x.Value
	}
	return nil
}

// Specifies periodic points in time, linked to the calendar (phase-linked), or a real world repeating event, such as breakfast (event-linked). Based on the HL7v3 data types PIVL<T> and EIVL<T>.
//
// Used in therapeutic prescriptions, expressed as INSTRUCTIONs in the openEHR model.
type DvGeneralTimeSpecification struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The specification, in the HL7v3 syntax for PIVL or EIVL types.
	Value         *DvParsable `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvGeneralTimeSpecification) Reset() {
	*x = DvGeneralTimeSpecification{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvGeneralTimeSpecification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvGeneralTimeSpecification) ProtoMessage() {}

func (x *DvGeneralTimeSpecification) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvGeneralTimeSpecification.ProtoReflect.Descriptor instead.
func (*DvGeneralTimeSpecification) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{59}
}

func (x *DvGeneralTimeSpecification) GetValue() *DvParsable {
	if x != nil {
		return x.Value
	}
	return nil
}

// A specialisation of DV_ENCAPSULATED for audiovisual and bio-signal types.
// Includes further metadata relating to multimedia types which are not applicable to other subtypes of DV_ENCAPSULATED.
type DvMultimedia struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of character encoding scheme in which this value is encoded.
	// Coded from openEHR Code Set character sets .
	// Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding.
	// This attribute allows for variations from these assumptions.
	Charset *CodePhrase `protobuf:"bytes,1,opt,name=charset,proto3,oneof" json:"charset,omitempty"`
	// Optional indicator of the localised language in which the data is written, if relevant.
	// Coded from openEHR Code Set languages.
	Language *CodePhrase `protobuf:"bytes,2,opt,name=language,proto3,oneof" json:"language,omitempty"`
	// Text to display in lieu of multimedia display/replay.
	AlternateText *string `protobuf:"bytes,3,opt,name=alternate_text,json=alternateText,proto3,oneof" json:"alternate_text,omitempty"`
	// URI reference to electronic information stored outside the record as a file, database entry etc, if supplied as a reference.
	Uri *DvUri `protobuf:"bytes,4,opt,name=uri,proto3,oneof" json:"uri,omitempty"`
	// The actual data found at uri, if supplied inline.
	Data []byte `protobuf:"bytes,5,opt,name=data,proto3,oneof" json:"data,omitempty"`
	// Data media type coded from openEHR code set media types (interface for the IANA MIME types code set).
	MediaType *CodePhrase `protobuf:"bytes,6,opt,name=media_type,json=mediaType,proto3" json:"media_type,omitempty"`
	// Compression type, a coded value from the openEHR Integrity check code set. Void means no compression.
	CompressionAlgorithm *CodePhrase `protobuf:"bytes,7,opt,name=compression_algorithm,json=compressionAlgorithm,proto3" json:"compression_algorithm,omitempty"`
	// Binary cryptographic integrity checksum.
	IntegrityCheck []byte `protobuf:"bytes,8,opt,name=integrity_check,json=integrityCheck,proto3,oneof" json:"integrity_check,omitempty"`
	// Type of integrity check, a coded value from the openEHR Integrity check code set.
	IntegrityCheckAlgorithm *string `protobuf:"bytes,9,opt,name=integrity_check_algorithm,json=integrityCheckAlgorithm,proto3,oneof" json:"integrity_check_algorithm,omitempty"`
	// The thumbnail for this item, if one exists; mainly for graphics formats.
	Thumbnail *DvMultimedia `protobuf:"bytes,10,opt,name=thumbnail,proto3,oneof" json:"thumbnail,omitempty"`
	// Original size in bytes of unencoded encapsulated data. I.e. encodings such as base64, hexadecimal etc do not change the value of this attribute.
	Size          int64 `protobuf:"varint,11,opt,name=size,proto3" json:"size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvMultimedia) Reset() {
	*x = DvMultimedia{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvMultimedia) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvMultimedia) ProtoMessage() {}

func (x *DvMultimedia) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvMultimedia.ProtoReflect.Descriptor instead.
func (*DvMultimedia) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{60}
}

func (x *DvMultimedia) GetCharset() *CodePhrase {
	if x != nil {
		return x.Charset
	}
	return nil
}

func (x *DvMultimedia) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *DvMultimedia) GetAlternateText() string {
	if x != nil && x.AlternateText != nil {
		return *x.AlternateText
	}
	return ""
}

func (x *DvMultimedia) GetUri() *DvUri {
	if x != nil {
		return x.Uri
	}
	return nil
}

func (x *DvMultimedia) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *DvMultimedia) GetMediaType() *CodePhrase {
	if x != nil {
		return x.MediaType
	}
	return nil
}

func (x *DvMultimedia) GetCompressionAlgorithm() *CodePhrase {
	if x != nil {
		return x.CompressionAlgorithm
	}
	return nil
}

func (x *DvMultimedia) GetIntegrityCheck() []byte {
	if x != nil {
		return x.IntegrityCheck
	}
	return nil
}

func (x *DvMultimedia) GetIntegrityCheckAlgorithm() string {
	if x != nil && x.IntegrityCheckAlgorithm != nil {
		return *x.IntegrityCheckAlgorithm
	}
	return ""
}

func (x *DvMultimedia) GetThumbnail() *DvMultimedia {
	if x != nil {
		return x.Thumbnail
	}
	return nil
}

func (x *DvMultimedia) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

// Encapsulated data expressed as a parsable String. The internal model of the data item is not described in the openEHR model in common with other encapsulated types, but in this case, the form of the data is assumed to be plaintext, rather than compressed or other types of large binary data.
type DvParsable struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of character encoding scheme in which this value is encoded.
	// Coded from openEHR Code Set character sets .
	// Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding.
	// This attribute allows for variations from these assumptions.
	Charset *CodePhrase `protobuf:"bytes,1,opt,name=charset,proto3,oneof" json:"charset,omitempty"`
	// Optional indicator of the localised language in which the data is written, if relevant.
	// Coded from openEHR Code Set languages.
	Language *CodePhrase `protobuf:"bytes,2,opt,name=language,proto3,oneof" json:"language,omitempty"`
	// The string, which may validly be empty in some syntaxes.
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// Name of the formalism, e.g. GLIF 1.0 , Proforma etc.
	Formalism     string `protobuf:"bytes,4,opt,name=formalism,proto3" json:"formalism,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvParsable) Reset() {
	*x = DvParsable{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvParsable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvParsable) ProtoMessage() {}

func (x *DvParsable) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvParsable.ProtoReflect.Descriptor instead.
func (*DvParsable) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{61}
}

func (x *DvParsable) GetCharset() *CodePhrase {
	if x != nil {
		return x.Charset
	}
	return nil
}

func (x *DvParsable) GetLanguage() *CodePhrase {
	if x != nil {
		return x.Language
	}
	return nil
}

func (x *DvParsable) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *DvParsable) GetFormalism() string {
	if x != nil {
		return x.Formalism
	}
	return ""
}

// A reference to an object which structurally conforms to the Universal Resource Identifier (URI) RFC-3986 standard.
// The reference is contained in the value attribute, which is a String.
// So-called 'plain-text URIs' that contain RFC-3986 forbidden characters such as spaces etc, are allowed on the basis that they need to be RFC-3986 encoded prior to use in e.g. REST APIs or other contexts relying on machine-level conformance.
type DvUri struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value of URI as a String.
	// 'Plain-text' URIs are allowed, enabling better readability, but must be RFC-3986 encoded in use.
	Value         string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvUri) Reset() {
	*x = DvUri{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvUri) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvUri) ProtoMessage() {}

func (x *DvUri) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvUri.ProtoReflect.Descriptor instead.
func (*DvUri) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{62}
}

func (x *DvUri) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// A DV_EHR_URI is a DV_URI which has the scheme name 'ehr', and which can only reference items in EHRs.
//
// Used to reference items in an EHR, which may be the same as the current EHR (containing this link), or another.
type DvEhrUri struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value of URI as a String. 'Plain-text' URIs are allowed, enabling better readability, but must be RFC-3986 encoded in use.
	Value         string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DvEhrUri) Reset() {
	*x = DvEhrUri{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DvEhrUri) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DvEhrUri) ProtoMessage() {}

func (x *DvEhrUri) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DvEhrUri.ProtoReflect.Descriptor instead.
func (*DvEhrUri) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{63}
}

func (x *DvEhrUri) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// A fully coordinated (i.e. all coordination has been performed) term from a terminology service (as distinct from a particular terminology).
type CodePhrase struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the distinct terminology from which the code_string (or its elements) was extracted.
	TerminologyId *TerminologyId `protobuf:"bytes,1,opt,name=terminology_id,json=terminologyId,proto3" json:"terminology_id,omitempty"`
	// The key used by the terminology service to identify a concept or coordination of concepts.
	// This string is most likely parsable inside the terminology service, but nothing can be assumed about its syntax outside that context.
	CodeString string `protobuf:"bytes,2,opt,name=code_string,json=codeString,proto3" json:"code_string,omitempty"`
	// Optional attribute to carry preferred term corresponding to the code or expression in code_string.
	// Typical use in integration situations which create mappings, and representing data for which both a (non-preferred) actual term and a preferred term are both required.
	PreferredTerm *string `protobuf:"bytes,3,opt,name=preferred_term,json=preferredTerm,proto3,oneof" json:"preferred_term,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CodePhrase) Reset() {
	*x = CodePhrase{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CodePhrase) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CodePhrase) ProtoMessage() {}

func (x *CodePhrase) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CodePhrase.ProtoReflect.Descriptor instead.
func (*CodePhrase) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{64}
}

func (x *CodePhrase) GetTerminologyId() *TerminologyId {
	if x != nil {
		return x.TerminologyId
	}
	return nil
}

func (x *CodePhrase) GetCodeString() string {
	if x != nil {
		return x.CodeString
	}
	return ""
}

func (x *CodePhrase) GetPreferredTerm() string {
	if x != nil && x.PreferredTerm != nil {
		return *x.PreferredTerm
	}
	return ""
}

// Defines a named range to be associated with any DV_ORDERED datum.
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges.
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
type ReferenceRangeDvDuration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
	//
	// Types that are valid to be assigned to Meaning:
	//
	//	*ReferenceRangeDvDuration_DvText
	//	*ReferenceRangeDvDuration_DvCodedText
	Meaning isReferenceRangeDvDuration_Meaning `protobuf_oneof:"meaning"`
	// The data range for this meaning, e.g. critical etc.
	Range         *DvIntervalDvDuration `protobuf:"bytes,3,opt,name=range,proto3" json:"range,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReferenceRangeDvDuration) Reset() {
	*x = ReferenceRangeDvDuration{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReferenceRangeDvDuration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReferenceRangeDvDuration) ProtoMessage() {}

func (x *ReferenceRangeDvDuration) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReferenceRangeDvDuration.ProtoReflect.Descriptor instead.
func (*ReferenceRangeDvDuration) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{65}
}

func (x *ReferenceRangeDvDuration) GetMeaning() isReferenceRangeDvDuration_Meaning {
	if x != nil {
		return x.Meaning
	}
	return nil
}

func (x *ReferenceRangeDvDuration) GetDvText() *DvText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvDuration_DvText); ok {
			return x.DvText
		}
	}
	return nil
}

func (x *ReferenceRangeDvDuration) GetDvCodedText() *DvCodedText {
	if x != nil {
		if x, ok := x.Meaning.(*ReferenceRangeDvDuration_DvCodedText); ok {
			return x.DvCodedText
		}
	}
	return nil
}

func (x *ReferenceRangeDvDuration) GetRange() *DvIntervalDvDuration {
	if x != nil {
		return x.Range
	}
	return nil
}

type isReferenceRangeDvDuration_Meaning interface {
	isReferenceRangeDvDuration_Meaning()
}

type ReferenceRangeDvDuration_DvText struct {
	DvText *DvText `protobuf:"bytes,1,opt,name=dv_text,json=dvText,proto3,oneof"`
}

type ReferenceRangeDvDuration_DvCodedText struct {
	DvCodedText *DvCodedText `protobuf:"bytes,2,opt,name=dv_coded_text,json=dvCodedText,proto3,oneof"`
}

func (*ReferenceRangeDvDuration_DvText) isReferenceRangeDvDuration_Meaning() {}

func (*ReferenceRangeDvDuration_DvCodedText) isReferenceRangeDvDuration_Meaning() {}

// Represents a coded term mapped to a DV_TEXT, and the relative match of the target term with respect to the mapped item.
// Plain or coded text items may appear in the EHR for which one or mappings in alternative terminologies are required.
// Mappings are only used to enable computer processing, so they can only be instances of DV_CODED_TEXT.
//
// Used for adding classification terms (e.g. adding ICD classifiers to SNOMED descriptive terms), or mapping into equivalents in other terminologies (e.g. across nursing vocabularies).
type TermMapping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The relative match of the target term with respect to the mapped text item. Result meanings:
	//
	// - '>': the mapping is to a broader term e.g. orginal text = arbovirus infection , target = viral infection
	// - '=': the mapping is to a (supposedly) equivalent to the original item
	// - '<': the mapping is to a narrower term. e.g. original text = diabetes , mapping = diabetes mellitus .
	// - '?': the kind of mapping is unknown.
	//
	// The first three values are taken from the ISO standards 2788 ( Guide to Establishment and development of monolingual thesauri) and 5964 (Guide to Establishment and development of multilingual thesauri).
	Match string `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// Purpose of the mapping e.g. 'automated data mining', 'billing', 'interoperability'.
	Purpose *DvCodedText `protobuf:"bytes,2,opt,name=purpose,proto3,oneof" json:"purpose,omitempty"`
	// The target term of the mapping.
	Target        *CodePhrase `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TermMapping) Reset() {
	*x = TermMapping{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TermMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TermMapping) ProtoMessage() {}

func (x *TermMapping) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TermMapping.ProtoReflect.Descriptor instead.
func (*TermMapping) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{66}
}

func (x *TermMapping) GetMatch() string {
	if x != nil {
		return x.Match
	}
	return ""
}

func (x *TermMapping) GetPurpose() *DvCodedText {
	if x != nil {
		return x.Purpose
	}
	return nil
}

func (x *TermMapping) GetTarget() *CodePhrase {
	if x != nil {
		return x.Target
	}
	return nil
}

// Archetypes act as the configuration basis for the particular structures of instances defined by the reference model.
// To enable archetypes to be used to create valid data, key classes in the reference model act as root points for archetyping; accordingly, these classes have the archetype_details attribute set.
//
// An instance of the class ARCHETYPED contains the relevant archetype identification information, allowing generating archetypes to be matched up with data instances.
type Archetyped struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Globally unique archetype identifier.
	ArchetypeId *ArchetypeId `protobuf:"bytes,1,opt,name=archetype_id,json=archetypeId,proto3" json:"archetype_id,omitempty"`
	// Globally unique template identifier, if a template was active at this point in the structure.
	// Normally, a template would only be used at the top of a top-level structure, but the possibility exists for templates at lower levels.
	TemplateId *TemplateId `protobuf:"bytes,2,opt,name=template_id,json=templateId,proto3,oneof" json:"template_id,omitempty"`
	// Version of the openEHR reference model used to create this object.
	// Expressed in terms of the release version string, e.g. 1.0, 1.2.4.
	RmVersion     string `protobuf:"bytes,3,opt,name=rm_version,json=rmVersion,proto3" json:"rm_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Archetyped) Reset() {
	*x = Archetyped{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Archetyped) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Archetyped) ProtoMessage() {}

func (x *Archetyped) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Archetyped.ProtoReflect.Descriptor instead.
func (*Archetyped) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{67}
}

func (x *Archetyped) GetArchetypeId() *ArchetypeId {
	if x != nil {
		return x.ArchetypeId
	}
	return nil
}

func (x *Archetyped) GetTemplateId() *TemplateId {
	if x != nil {
		return x.TemplateId
	}
	return nil
}

func (x *Archetyped) GetRmVersion() string {
	if x != nil {
		return x.RmVersion
	}
	return ""
}

// The LINK type defines a logical relationship between two items, such as two ENTRYs or an ENTRY and a COMPOSITION.
// Links can be used across compositions, and across EHRs.
// Links can potentially be used between interior (i.e. non archetype root) nodes, although this probably should be prevented in archetypes.
// Multiple LINKs can be attached to the root object of any archetyped structure to give the effect of a 1N link.
//
// 1:1 and 1:N relationships between archetyped content elements (e.g. ENTRYs) can be expressed by using one, or more than one, respectively, LINKs.
// Chains of links can be used to see problem threads or other logical groupings of items.
//
// Links should be between archetyped structures only, i.e. between objects representing complete domain concepts because relationships between sub-elements of whole concepts are not necessarily meaningful, and may be downright confusing.
// Sensible links only exist between whole ENTRYs, SECTIONs, COMPOSITIONs and so on.
type Link struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Used to describe the relationship, usually in clinical terms, such as in response to (the relationship between test results and an order), follow-up to and so on.
	// Such relationships can represent any clinically meaningful connection between pieces of information.
	// Values for meaning include those described in Annex C, ENV 13606 pt 2 under the categories of generic, documenting and reporting, organisational, clinical, circumstantial, and view management.
	Meaning *DvText `protobuf:"bytes,1,opt,name=meaning,proto3" json:"meaning,omitempty"`
	// The type attribute is used to indicate a clinical or domain-level meaning for the kind of link, for example problem or issue.
	// If type values are designed appropriately, they can be used by the requestor of EHR extracts to categorise links which must be followed and which can be broken when the extract is created.
	Type *DvText `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// The logical to object in the link relation, as per the linguistic sense of the meaning attribute.
	Target        *DvEhrUri `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Link) Reset() {
	*x = Link{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Link) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Link) ProtoMessage() {}

func (x *Link) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Link.ProtoReflect.Descriptor instead.
func (*Link) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{68}
}

func (x *Link) GetMeaning() *DvText {
	if x != nil {
		return x.Meaning
	}
	return nil
}

func (x *Link) GetType() *DvText {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *Link) GetTarget() *DvEhrUri {
	if x != nil {
		return x.Target
	}
	return nil
}

// The FEEDER_AUDIT class defines the semantics of an audit trail which is constructed to describe the origin of data that have been transformed into openEHR form and committed to the system.
type FeederAudit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifiers used for the item in the originating system, e.g. filler and placer ids.
	OriginatingSystemItemIds []*DvIdentifier `protobuf:"bytes,1,rep,name=originating_system_item_ids,json=originatingSystemItemIds,proto3" json:"originating_system_item_ids,omitempty"`
	// Identifiers used for the item in the feeder system, where the feeder system is distinct from the originating system.
	FeederSystemItemIds []*DvIdentifier `protobuf:"bytes,2,rep,name=feeder_system_item_ids,json=feederSystemItemIds,proto3" json:"feeder_system_item_ids,omitempty"`
	// Optional inline inclusion of or reference to original content corresponding to the openEHR content at this node.
	// Typically a URI reference to a document or message in a persistent store associated with the EHR.
	//
	// Types that are valid to be assigned to OriginalContent:
	//
	//	*FeederAudit_DvMultimedia
	//	*FeederAudit_DvParsable
	OriginalContent isFeederAudit_OriginalContent `protobuf_oneof:"original_content"`
	// Any audit information for the information item from the originating system.
	OriginatingSystemAudit *FeederAuditDetails `protobuf:"bytes,5,opt,name=originating_system_audit,json=originatingSystemAudit,proto3" json:"originating_system_audit,omitempty"`
	// Any audit information for the information item from the feeder system, if different from the originating system.
	FeederSystemAudit *FeederAuditDetails `protobuf:"bytes,6,opt,name=feeder_system_audit,json=feederSystemAudit,proto3" json:"feeder_system_audit,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *FeederAudit) Reset() {
	*x = FeederAudit{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeederAudit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeederAudit) ProtoMessage() {}

func (x *FeederAudit) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeederAudit.ProtoReflect.Descriptor instead.
func (*FeederAudit) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{69}
}

func (x *FeederAudit) GetOriginatingSystemItemIds() []*DvIdentifier {
	if x != nil {
		return x.OriginatingSystemItemIds
	}
	return nil
}

func (x *FeederAudit) GetFeederSystemItemIds() []*DvIdentifier {
	if x != nil {
		return x.FeederSystemItemIds
	}
	return nil
}

func (x *FeederAudit) GetOriginalContent() isFeederAudit_OriginalContent {
	if x != nil {
		return x.OriginalContent
	}
	return nil
}

func (x *FeederAudit) GetDvMultimedia() *DvMultimedia {
	if x != nil {
		if x, ok := x.OriginalContent.(*FeederAudit_DvMultimedia); ok {
			return x.DvMultimedia
		}
	}
	return nil
}

func (x *FeederAudit) GetDvParsable() *DvParsable {
	if x != nil {
		if x, ok := x.OriginalContent.(*FeederAudit_DvParsable); ok {
			return x.DvParsable
		}
	}
	return nil
}

func (x *FeederAudit) GetOriginatingSystemAudit() *FeederAuditDetails {
	if x != nil {
		return x.OriginatingSystemAudit
	}
	return nil
}

func (x *FeederAudit) GetFeederSystemAudit() *FeederAuditDetails {
	if x != nil {
		return x.FeederSystemAudit
	}
	return nil
}

type isFeederAudit_OriginalContent interface {
	isFeederAudit_OriginalContent()
}

type FeederAudit_DvMultimedia struct {
	DvMultimedia *DvMultimedia `protobuf:"bytes,3,opt,name=dv_multimedia,json=dvMultimedia,proto3,oneof"`
}

type FeederAudit_DvParsable struct {
	DvParsable *DvParsable `protobuf:"bytes,4,opt,name=dv_parsable,json=dvParsable,proto3,oneof"`
}

func (*FeederAudit_DvMultimedia) isFeederAudit_OriginalContent() {}

func (*FeederAudit_DvParsable) isFeederAudit_OriginalContent() {}

// Audit details for any system in a feeder system chain.
// Audit details here means the general notion of who/where/when the information item to which the audit is attached was created.
// None of the attributes is defined as mandatory, however, in different scenarios, various combinations of attributes will usually be mandatory.
// This can be controlled by specifying feeder audit details in legacy archetypes.
type FeederAuditDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the system which handled the information item.
	// This is the IT system owned by the organisation legally responsible for handling the data, and at which the data were previously created or passed by an earlier system.
	SystemId string `protobuf:"bytes,1,opt,name=system_id,json=systemId,proto3" json:"system_id,omitempty"`
	// Identifier of the particular site/facility within an organisation which handled the item.
	// For computability, this identifier needs to be e.g. a PKI identifier which can be included in the identifier list of the PARTY_IDENTIFIED object.
	Location *PartyIdentified `protobuf:"bytes,2,opt,name=location,proto3,oneof" json:"location,omitempty"`
	// Identifiers for subject of the received information item.
	Subject *PartyProxy `protobuf:"bytes,3,opt,name=subject,proto3,oneof" json:"subject,omitempty"`
	// Optional provider(s) who created, committed, forwarded or otherwise handled the item.
	Provider *PartyProxy `protobuf:"bytes,4,opt,name=provider,proto3,oneof" json:"provider,omitempty"`
	// Time of handling the item. For an originating system, this will be time of creation, for an intermediate feeder system, this will be a time of accession or other time of handling, where available.
	Time *DvDateTime `protobuf:"bytes,5,opt,name=time,proto3,oneof" json:"time,omitempty"`
	// Any identifier used in the system such as "interim" , "final" , or numeric versions if available.
	VersionId *string `protobuf:"bytes,6,opt,name=version_id,json=versionId,proto3,oneof" json:"version_id,omitempty"`
	// Optional attribute to carry any custom meta-data. May be archetyped.
	OtherDetails  *ItemStructure `protobuf:"bytes,7,opt,name=other_details,json=otherDetails,proto3,oneof" json:"other_details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FeederAuditDetails) Reset() {
	*x = FeederAuditDetails{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeederAuditDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeederAuditDetails) ProtoMessage() {}

func (x *FeederAuditDetails) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeederAuditDetails.ProtoReflect.Descriptor instead.
func (*FeederAuditDetails) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{70}
}

func (x *FeederAuditDetails) GetSystemId() string {
	if x != nil {
		return x.SystemId
	}
	return ""
}

func (x *FeederAuditDetails) GetLocation() *PartyIdentified {
	if x != nil {
		return x.Location
	}
	return nil
}

func (x *FeederAuditDetails) GetSubject() *PartyProxy {
	if x != nil {
		return x.Subject
	}
	return nil
}

func (x *FeederAuditDetails) GetProvider() *PartyProxy {
	if x != nil {
		return x.Provider
	}
	return nil
}

func (x *FeederAuditDetails) GetTime() *DvDateTime {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *FeederAuditDetails) GetVersionId() string {
	if x != nil && x.VersionId != nil {
		return *x.VersionId
	}
	return ""
}

func (x *FeederAuditDetails) GetOtherDetails() *ItemStructure {
	if x != nil {
		return x.OtherDetails
	}
	return nil
}

// Abstract concept of a proxy description of a party, including an optional link to data for this party in a demographic or other identity management system. Sub- typed into PARTY_IDENTIFIED and PARTY_SELF.
type PartyProxy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Proxy:
	//
	//	*PartyProxy_PartySelf
	//	*PartyProxy_PartyIdentified
	//	*PartyProxy_PartyRelated
	Proxy         isPartyProxy_Proxy `protobuf_oneof:"proxy"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartyProxy) Reset() {
	*x = PartyProxy{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartyProxy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartyProxy) ProtoMessage() {}

func (x *PartyProxy) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartyProxy.ProtoReflect.Descriptor instead.
func (*PartyProxy) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{71}
}

func (x *PartyProxy) GetProxy() isPartyProxy_Proxy {
	if x != nil {
		return x.Proxy
	}
	return nil
}

func (x *PartyProxy) GetPartySelf() *PartySelf {
	if x != nil {
		if x, ok := x.Proxy.(*PartyProxy_PartySelf); ok {
			return x.PartySelf
		}
	}
	return nil
}

func (x *PartyProxy) GetPartyIdentified() *PartyIdentified {
	if x != nil {
		if x, ok := x.Proxy.(*PartyProxy_PartyIdentified); ok {
			return x.PartyIdentified
		}
	}
	return nil
}

func (x *PartyProxy) GetPartyRelated() *PartyRelated {
	if x != nil {
		if x, ok := x.Proxy.(*PartyProxy_PartyRelated); ok {
			return x.PartyRelated
		}
	}
	return nil
}

type isPartyProxy_Proxy interface {
	isPartyProxy_Proxy()
}

type PartyProxy_PartySelf struct {
	PartySelf *PartySelf `protobuf:"bytes,1,opt,name=party_self,json=partySelf,proto3,oneof"`
}

type PartyProxy_PartyIdentified struct {
	PartyIdentified *PartyIdentified `protobuf:"bytes,2,opt,name=party_identified,json=partyIdentified,proto3,oneof"`
}

type PartyProxy_PartyRelated struct {
	PartyRelated *PartyRelated `protobuf:"bytes,3,opt,name=party_related,json=partyRelated,proto3,oneof"`
}

func (*PartyProxy_PartySelf) isPartyProxy_Proxy() {}

func (*PartyProxy_PartyIdentified) isPartyProxy_Proxy() {}

func (*PartyProxy_PartyRelated) isPartyProxy_Proxy() {}

// Party proxy representing the subject of the record. Used to indicate that the party is the owner of the record. May or may not have external_ref set.
type PartySelf struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional reference to more detailed demographic or identification information for this party, in an external system.
	ExternalRef   *PartyRef `protobuf:"bytes,1,opt,name=external_ref,json=externalRef,proto3,oneof" json:"external_ref,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartySelf) Reset() {
	*x = PartySelf{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartySelf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartySelf) ProtoMessage() {}

func (x *PartySelf) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartySelf.ProtoReflect.Descriptor instead.
func (*PartySelf) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{72}
}

func (x *PartySelf) GetExternalRef() *PartyRef {
	if x != nil {
		return x.ExternalRef
	}
	return nil
}

// Proxy data for an identified party other than the subject of the record, minimally consisting of human-readable identifier(s), such as name, formal (and possibly computable) identifiers such as NHS number, and an optional link to external data. There must be at least one of name, identifier or external_ref present.
//
// Used to describe parties where only identifiers may be known, and there is no entry at all in the demographic system (or even no demographic system). Typically for health care providers, e.g. name and provider number of an institution.
//
// Should not be used to include patient identifying information.
type PartyIdentified struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional reference to more detailed demographic or identification information for this party, in an external system.
	ExternalRef *PartyRef `protobuf:"bytes,1,opt,name=external_ref,json=externalRef,proto3,oneof" json:"external_ref,omitempty"`
	// Optional human-readable name (in String form).
	Name *string `protobuf:"bytes,2,opt,name=name,proto3,oneof" json:"name,omitempty"`
	// One or more formal identifiers (possibly computable).
	Identifiers   []*DvIdentifier `protobuf:"bytes,3,rep,name=identifiers,proto3" json:"identifiers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartyIdentified) Reset() {
	*x = PartyIdentified{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartyIdentified) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartyIdentified) ProtoMessage() {}

func (x *PartyIdentified) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartyIdentified.ProtoReflect.Descriptor instead.
func (*PartyIdentified) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{73}
}

func (x *PartyIdentified) GetExternalRef() *PartyRef {
	if x != nil {
		return x.ExternalRef
	}
	return nil
}

func (x *PartyIdentified) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *PartyIdentified) GetIdentifiers() []*DvIdentifier {
	if x != nil {
		return x.Identifiers
	}
	return nil
}

// Proxy data for an identified party other than the subject of the record, minimally consisting of human-readable identifier(s), such as name, formal (and possibly computable) identifiers such as NHS number, and an optional link to external data. There must be at least one of name, identifier or external_ref present.
//
// Used to describe parties where only identifiers may be known, and there is no entry at all in the demographic system (or even no demographic system). Typically for health care providers, e.g. name and provider number of an institution.
//
// Should not be used to include patient identifying information.
type PartyRelated struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional reference to more detailed demographic or identification information for this party, in an external system.
	ExternalRef *PartyRef `protobuf:"bytes,1,opt,name=external_ref,json=externalRef,proto3,oneof" json:"external_ref,omitempty"`
	// Optional human-readable name (in String form).
	Name *string `protobuf:"bytes,2,opt,name=name,proto3,oneof" json:"name,omitempty"`
	// One or more formal identifiers (possibly computable).
	Identifiers []*DvIdentifier `protobuf:"bytes,3,rep,name=identifiers,proto3" json:"identifiers,omitempty"`
	// Relationship of subject of this ENTRY to the subject of the record.
	// May be coded. If it is the patient, coded as self.
	Relationship  *DvCodedText `protobuf:"bytes,4,opt,name=relationship,proto3" json:"relationship,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PartyRelated) Reset() {
	*x = PartyRelated{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PartyRelated) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartyRelated) ProtoMessage() {}

func (x *PartyRelated) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartyRelated.ProtoReflect.Descriptor instead.
func (*PartyRelated) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{74}
}

func (x *PartyRelated) GetExternalRef() *PartyRef {
	if x != nil {
		return x.ExternalRef
	}
	return nil
}

func (x *PartyRelated) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *PartyRelated) GetIdentifiers() []*DvIdentifier {
	if x != nil {
		return x.Identifiers
	}
	return nil
}

func (x *PartyRelated) GetRelationship() *DvCodedText {
	if x != nil {
		return x.Relationship
	}
	return nil
}

// Model of a participation of a Party (any Actor or Role) in an activity. Used to represent any participation of a Party in some activity, which is not explicitly in the model, e.g. assisting nurse. Can be used to record past or future participations.
//
// Should not be used in place of more permanent relationships between demographic entities.
type Participation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The function of the Party in this participation (note that a given party might participate in more than one way in a particular activity). This attribute should be coded, but cannot be limited to the HL7v3:ParticipationFunction vocabulary, since it is too limited and hospital-oriented.
	Function *DvText `protobuf:"bytes,1,opt,name=function,proto3" json:"function,omitempty"`
	// Optional field for recording the 'mode' of the performer / activity interaction, e.g. present, by telephone, by email etc.
	Mode *DvCodedText `protobuf:"bytes,2,opt,name=mode,proto3,oneof" json:"mode,omitempty"`
	// The id and possibly demographic system link of the party participating in the activity.
	Performer *PartyProxy `protobuf:"bytes,3,opt,name=performer,proto3" json:"performer,omitempty"`
	// The time interval during which the participation took place, if it is used in an observational context (i.e. recording facts about the past); or the intended time interval of the participation when used in future contexts, such as EHR Instructions.
	Time          *DvIntervalDvDateTime `protobuf:"bytes,4,opt,name=time,proto3,oneof" json:"time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Participation) Reset() {
	*x = Participation{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Participation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Participation) ProtoMessage() {}

func (x *Participation) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Participation.ProtoReflect.Descriptor instead.
func (*Participation) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{75}
}

func (x *Participation) GetFunction() *DvText {
	if x != nil {
		return x.Function
	}
	return nil
}

func (x *Participation) GetMode() *DvCodedText {
	if x != nil {
		return x.Mode
	}
	return nil
}

func (x *Participation) GetPerformer() *PartyProxy {
	if x != nil {
		return x.Performer
	}
	return nil
}

func (x *Participation) GetTime() *DvIntervalDvDateTime {
	if x != nil {
		return x.Time
	}
	return nil
}

// Abstract parent class of all spatial data types.
type ItemStructure struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Structure:
	//
	//	*ItemStructure_ItemSingle
	//	*ItemStructure_ItemList
	//	*ItemStructure_ItemTable
	//	*ItemStructure_ItemTree
	Structure     isItemStructure_Structure `protobuf_oneof:"structure"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ItemStructure) Reset() {
	*x = ItemStructure{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ItemStructure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ItemStructure) ProtoMessage() {}

func (x *ItemStructure) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ItemStructure.ProtoReflect.Descriptor instead.
func (*ItemStructure) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{76}
}

func (x *ItemStructure) GetStructure() isItemStructure_Structure {
	if x != nil {
		return x.Structure
	}
	return nil
}

func (x *ItemStructure) GetItemSingle() *ItemSingle {
	if x != nil {
		if x, ok := x.Structure.(*ItemStructure_ItemSingle); ok {
			return x.ItemSingle
		}
	}
	return nil
}

func (x *ItemStructure) GetItemList() *ItemList {
	if x != nil {
		if x, ok := x.Structure.(*ItemStructure_ItemList); ok {
			return x.ItemList
		}
	}
	return nil
}

func (x *ItemStructure) GetItemTable() *ItemTable {
	if x != nil {
		if x, ok := x.Structure.(*ItemStructure_ItemTable); ok {
			return x.ItemTable
		}
	}
	return nil
}

func (x *ItemStructure) GetItemTree() *ItemTree {
	if x != nil {
		if x, ok := x.Structure.(*ItemStructure_ItemTree); ok {
			return x.ItemTree
		}
	}
	return nil
}

type isItemStructure_Structure interface {
	isItemStructure_Structure()
}

type ItemStructure_ItemSingle struct {
	ItemSingle *ItemSingle `protobuf:"bytes,1,opt,name=item_single,json=itemSingle,proto3,oneof"`
}

type ItemStructure_ItemList struct {
	ItemList *ItemList `protobuf:"bytes,2,opt,name=item_list,json=itemList,proto3,oneof"`
}

type ItemStructure_ItemTable struct {
	ItemTable *ItemTable `protobuf:"bytes,3,opt,name=item_table,json=itemTable,proto3,oneof"`
}

type ItemStructure_ItemTree struct {
	ItemTree *ItemTree `protobuf:"bytes,4,opt,name=item_tree,json=itemTree,proto3,oneof"`
}

func (*ItemStructure_ItemSingle) isItemStructure_Structure() {}

func (*ItemStructure_ItemList) isItemStructure_Structure() {}

func (*ItemStructure_ItemTable) isItemStructure_Structure() {}

func (*ItemStructure_ItemTree) isItemStructure_Structure() {}

// Logical single value data structure.
// Used to represent any data which is logically a single value, such as a persons height or weight.
type ItemSingle struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	Item          *Element `protobuf:"bytes,7,opt,name=item,proto3" json:"item,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ItemSingle) Reset() {
	*x = ItemSingle{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ItemSingle) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ItemSingle) ProtoMessage() {}

func (x *ItemSingle) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ItemSingle.ProtoReflect.Descriptor instead.
func (*ItemSingle) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{77}
}

func (x *ItemSingle) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *ItemSingle) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *ItemSingle) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *ItemSingle) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *ItemSingle) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *ItemSingle) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *ItemSingle) GetItem() *Element {
	if x != nil {
		return x.Item
	}
	return nil
}

// Logical list data structure, where each item has a value and can be referred to by a name and a positional index in the list. The list may be empty.
//
// ITEM_LIST is used to represent any data which is logically a list of values, such as blood pressure, most protocols, many blood tests etc.
//
// Not to be used for time-based lists, which should be represented with the proper temporal class, i.e. HISTORY.
type ItemList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Physical representation of the list.
	Items         []*Element `protobuf:"bytes,7,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ItemList) Reset() {
	*x = ItemList{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ItemList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ItemList) ProtoMessage() {}

func (x *ItemList) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ItemList.ProtoReflect.Descriptor instead.
func (*ItemList) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{78}
}

func (x *ItemList) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *ItemList) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *ItemList) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *ItemList) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *ItemList) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *ItemList) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *ItemList) GetItems() []*Element {
	if x != nil {
		return x.Items
	}
	return nil
}

// Logical relational database style table data structure, in which columns are named and ordered with respect to each other. Implemented using Cluster-per-row encoding. Each row Cluster must have an identical number of Elements, each of which in turn must have identical names and value types in the corresponding positions in each row.
//
// Some columns may be designated key' columns, containing key data for each row, in the manner of relational tables. This allows row-naming, where each row represents a body site, a blood antigen etc. All values in a column have the same data type.
//
// Used for representing any data which is logically a table of values, such as blood pressure, most protocols, many blood tests etc.
//
// Misuse: Not to be used for time-based data, which should be represented with the temporal class HISTORY. The table may be empty.
type ItemTable struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Physical representation of the table as a list of CLUSTERs, each containing the data of one row of the table.
	Rows          []*Cluster `protobuf:"bytes,7,rep,name=rows,proto3" json:"rows,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ItemTable) Reset() {
	*x = ItemTable{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ItemTable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ItemTable) ProtoMessage() {}

func (x *ItemTable) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ItemTable.ProtoReflect.Descriptor instead.
func (*ItemTable) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{79}
}

func (x *ItemTable) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *ItemTable) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *ItemTable) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *ItemTable) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *ItemTable) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *ItemTable) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *ItemTable) GetRows() []*Cluster {
	if x != nil {
		return x.Rows
	}
	return nil
}

// Logical tree data structure. The tree may be empty. Used for representing data which are logically a tree such as audiology results, microbiology results, biochemistry results.
type ItemTree struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// The items comprising the ITEM_TREE. Can include 0 or more CLUSTERs and/or 0 or more individual ELEMENTs.
	Items         []*ItemTree_ItemTableItem `protobuf:"bytes,7,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ItemTree) Reset() {
	*x = ItemTree{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ItemTree) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ItemTree) ProtoMessage() {}

func (x *ItemTree) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ItemTree.ProtoReflect.Descriptor instead.
func (*ItemTree) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{80}
}

func (x *ItemTree) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *ItemTree) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *ItemTree) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *ItemTree) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *ItemTree) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *ItemTree) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *ItemTree) GetItems() []*ItemTree_ItemTableItem {
	if x != nil {
		return x.Items
	}
	return nil
}

// The grouping variant of ITEM, which may contain further instances of ITEM, in an ordered list.
type Cluster struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Ordered list of items - CLUSTER or ELEMENT objects - under this CLUSTER.
	Items         []*Cluster_ClusterItem `protobuf:"bytes,7,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster) Reset() {
	*x = Cluster{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster) ProtoMessage() {}

func (x *Cluster) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster.ProtoReflect.Descriptor instead.
func (*Cluster) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{81}
}

func (x *Cluster) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Cluster) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *Cluster) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Cluster) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Cluster) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *Cluster) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *Cluster) GetItems() []*Cluster_ClusterItem {
	if x != nil {
		return x.Items
	}
	return nil
}

// The leaf variant of ITEM, to which a DATA_VALUE instance is attached.
type Element struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Flavour of null value, e.g. 253|unknown|, 271|no information|, 272|masked|, and 273|not applicable|.
	NullFlavour *DvCodedText `protobuf:"bytes,7,opt,name=null_flavour,json=nullFlavour,proto3,oneof" json:"null_flavour,omitempty"`
	// Property representing leaf value object of ELEMENT. In real data, any concrete subtype of DATA_VALUE can be used.
	Value *DataValue `protobuf:"bytes,8,opt,name=value,proto3,oneof" json:"value,omitempty"`
	// Optional specific reason for null value; if set, null_flavour must be set.
	// Null reason may apply only to a minority of clinical data, commonly needed in reporting contexts.
	NullReason    *DvText `protobuf:"bytes,9,opt,name=null_reason,json=nullReason,proto3,oneof" json:"null_reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Element) Reset() {
	*x = Element{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Element) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Element) ProtoMessage() {}

func (x *Element) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Element.ProtoReflect.Descriptor instead.
func (*Element) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{82}
}

func (x *Element) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *Element) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *Element) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *Element) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *Element) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *Element) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *Element) GetNullFlavour() *DvCodedText {
	if x != nil {
		return x.NullFlavour
	}
	return nil
}

func (x *Element) GetValue() *DataValue {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *Element) GetNullReason() *DvText {
	if x != nil {
		return x.NullReason
	}
	return nil
}

// Root object of a linear history, i.e. time series structure. This is a generic class whose type parameter must be a descendant of ITEM_STRUCTURE, ensuring that each Event in the events of a given instance is of the same structural type, i.e. ITEM_TREE, ITEM_LIST etc.
//
// For a periodic series of events, period will be set, and the time of each Event in the History must correspond; i.e. the EVENT.offset must be a multiple of period for each Event. Missing events in a period History are however allowed.
type HistoryItemStructure struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Time origin of this event history. The first event is not necessarily at the origin point.
	Origin *DvDateTime `protobuf:"bytes,7,opt,name=origin,proto3" json:"origin,omitempty"`
	// Period between samples in this segment if periodic.
	Period *DvDuration `protobuf:"bytes,8,opt,name=period,proto3,oneof" json:"period,omitempty"`
	// Duration of the entire History; either corresponds to the duration of all the events, and/or the duration represented by the summary, if it exists.
	Duration *DvDuration `protobuf:"bytes,9,opt,name=duration,proto3,oneof" json:"duration,omitempty"`
	// Optional summary data that aggregates, organizes, reduces and transforms the event series. This may be a text or image that presents a graphical presentation, or some data that assists with the interpretation of the data.
	Summary *ItemStructure `protobuf:"bytes,10,opt,name=summary,proto3,oneof" json:"summary,omitempty"`
	// The events in the series. This attribute is of a generic type whose parameter must be a descendant of ITEM_SUTRUCTURE.
	Events        []*Event `protobuf:"bytes,11,rep,name=events,proto3" json:"events,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HistoryItemStructure) Reset() {
	*x = HistoryItemStructure{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HistoryItemStructure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HistoryItemStructure) ProtoMessage() {}

func (x *HistoryItemStructure) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HistoryItemStructure.ProtoReflect.Descriptor instead.
func (*HistoryItemStructure) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{83}
}

func (x *HistoryItemStructure) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *HistoryItemStructure) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *HistoryItemStructure) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *HistoryItemStructure) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *HistoryItemStructure) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *HistoryItemStructure) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *HistoryItemStructure) GetOrigin() *DvDateTime {
	if x != nil {
		return x.Origin
	}
	return nil
}

func (x *HistoryItemStructure) GetPeriod() *DvDuration {
	if x != nil {
		return x.Period
	}
	return nil
}

func (x *HistoryItemStructure) GetDuration() *DvDuration {
	if x != nil {
		return x.Duration
	}
	return nil
}

func (x *HistoryItemStructure) GetSummary() *ItemStructure {
	if x != nil {
		return x.Summary
	}
	return nil
}

func (x *HistoryItemStructure) GetEvents() []*Event {
	if x != nil {
		return x.Events
	}
	return nil
}

// Defines the abstract notion of a single event in a series. This class is generic, allowing types to be generated which are locked to particular spatial types, such as EVENT<ITEM_LIST>. Subtypes express point or intveral data.
type Event struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*Event_PointEvent
	//	*Event_IntervalEvent
	Type          isEvent_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Event) Reset() {
	*x = Event{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Event) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Event) ProtoMessage() {}

func (x *Event) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Event.ProtoReflect.Descriptor instead.
func (*Event) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{84}
}

func (x *Event) GetType() isEvent_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *Event) GetPointEvent() *PointEvent {
	if x != nil {
		if x, ok := x.Type.(*Event_PointEvent); ok {
			return x.PointEvent
		}
	}
	return nil
}

func (x *Event) GetIntervalEvent() *IntervalEvent {
	if x != nil {
		if x, ok := x.Type.(*Event_IntervalEvent); ok {
			return x.IntervalEvent
		}
	}
	return nil
}

type isEvent_Type interface {
	isEvent_Type()
}

type Event_PointEvent struct {
	PointEvent *PointEvent `protobuf:"bytes,1,opt,name=point_event,json=pointEvent,proto3,oneof"`
}

type Event_IntervalEvent struct {
	IntervalEvent *IntervalEvent `protobuf:"bytes,2,opt,name=interval_event,json=intervalEvent,proto3,oneof"`
}

func (*Event_PointEvent) isEvent_Type() {}

func (*Event_IntervalEvent) isEvent_Type() {}

// Defines a single point event in a series.
type PointEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Time of this event. If the width is non-zero, it is the time point of the trailing edge of the event.
	Time *DvDateTime `protobuf:"bytes,7,opt,name=time,proto3" json:"time,omitempty"`
	// Optional state data for this event.
	State *ItemStructure `protobuf:"bytes,8,opt,name=state,proto3,oneof" json:"state,omitempty"`
	// The data of this event.
	Data          []byte `protobuf:"bytes,9,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PointEvent) Reset() {
	*x = PointEvent{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PointEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PointEvent) ProtoMessage() {}

func (x *PointEvent) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PointEvent.ProtoReflect.Descriptor instead.
func (*PointEvent) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{85}
}

func (x *PointEvent) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *PointEvent) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *PointEvent) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *PointEvent) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *PointEvent) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *PointEvent) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *PointEvent) GetTime() *DvDateTime {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *PointEvent) GetState() *ItemStructure {
	if x != nil {
		return x.State
	}
	return nil
}

func (x *PointEvent) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

// Defines a single interval event in a series.
type IntervalEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Runtime name of this fragment, used to build runtime paths.
	// This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
	Name *DvText `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths.
	// Always in the form of an at-code, e.g. at0005.
	// This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
	//
	// At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
	ArchetypeNodeId string `protobuf:"bytes,2,opt,name=archetype_node_id,json=archetypeNodeId,proto3" json:"archetype_node_id,omitempty"`
	// Optional globally unique object identifier for root points of archetyped structures.
	Uid *UidBasedId `protobuf:"bytes,3,opt,name=uid,proto3,oneof" json:"uid,omitempty"`
	// Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on).
	// Links may be to structures in other compositions.
	Links []*Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	// Details of archetyping used on this node.
	ArchetypeDetails *Archetyped `protobuf:"bytes,5,opt,name=archetype_details,json=archetypeDetails,proto3,oneof" json:"archetype_details,omitempty"`
	// Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
	FeederAudit *FeederAudit `protobuf:"bytes,6,opt,name=feeder_audit,json=feederAudit,proto3,oneof" json:"feeder_audit,omitempty"`
	// Time of this event. If the width is non-zero, it is the time point of the trailing edge of the event.
	Time *DvDateTime `protobuf:"bytes,7,opt,name=time,proto3" json:"time,omitempty"`
	// Optional state data for this event.
	State *ItemStructure `protobuf:"bytes,8,opt,name=state,proto3,oneof" json:"state,omitempty"`
	// The data of this event.
	Data []byte `protobuf:"bytes,9,opt,name=data,proto3" json:"data,omitempty"`
	// Duration of the time interval during which the values recorded under data are true and, if set, the values recorded under state are true. Void if an instantaneous event.
	Width *DvDuration `protobuf:"bytes,10,opt,name=width,proto3" json:"width,omitempty"`
	// Optional count of original samples to which this event corresponds.
	SampleCount *int64 `protobuf:"varint,11,opt,name=sample_count,json=sampleCount,proto3,oneof" json:"sample_count,omitempty"`
	// Mathematical function of the data of this event, e.g. maximum, mean etc. Coded using openEHR vocabulary event math function. Default value 640|actual|, meaning 'actual value'.
	MathFunction  *DvCodedText `protobuf:"bytes,12,opt,name=math_function,json=mathFunction,proto3" json:"math_function,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IntervalEvent) Reset() {
	*x = IntervalEvent{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IntervalEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntervalEvent) ProtoMessage() {}

func (x *IntervalEvent) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntervalEvent.ProtoReflect.Descriptor instead.
func (*IntervalEvent) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{86}
}

func (x *IntervalEvent) GetName() *DvText {
	if x != nil {
		return x.Name
	}
	return nil
}

func (x *IntervalEvent) GetArchetypeNodeId() string {
	if x != nil {
		return x.ArchetypeNodeId
	}
	return ""
}

func (x *IntervalEvent) GetUid() *UidBasedId {
	if x != nil {
		return x.Uid
	}
	return nil
}

func (x *IntervalEvent) GetLinks() []*Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *IntervalEvent) GetArchetypeDetails() *Archetyped {
	if x != nil {
		return x.ArchetypeDetails
	}
	return nil
}

func (x *IntervalEvent) GetFeederAudit() *FeederAudit {
	if x != nil {
		return x.FeederAudit
	}
	return nil
}

func (x *IntervalEvent) GetTime() *DvDateTime {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *IntervalEvent) GetState() *ItemStructure {
	if x != nil {
		return x.State
	}
	return nil
}

func (x *IntervalEvent) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *IntervalEvent) GetWidth() *DvDuration {
	if x != nil {
		return x.Width
	}
	return nil
}

func (x *IntervalEvent) GetSampleCount() int64 {
	if x != nil && x.SampleCount != nil {
		return *x.SampleCount
	}
	return 0
}

func (x *IntervalEvent) GetMathFunction() *DvCodedText {
	if x != nil {
		return x.MathFunction
	}
	return nil
}

type ItemTree_ItemTableItem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Item:
	//
	//	*ItemTree_ItemTableItem_Cluster
	//	*ItemTree_ItemTableItem_Element
	Item          isItemTree_ItemTableItem_Item `protobuf_oneof:"item"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ItemTree_ItemTableItem) Reset() {
	*x = ItemTree_ItemTableItem{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ItemTree_ItemTableItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ItemTree_ItemTableItem) ProtoMessage() {}

func (x *ItemTree_ItemTableItem) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ItemTree_ItemTableItem.ProtoReflect.Descriptor instead.
func (*ItemTree_ItemTableItem) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{80, 0}
}

func (x *ItemTree_ItemTableItem) GetItem() isItemTree_ItemTableItem_Item {
	if x != nil {
		return x.Item
	}
	return nil
}

func (x *ItemTree_ItemTableItem) GetCluster() *Cluster {
	if x != nil {
		if x, ok := x.Item.(*ItemTree_ItemTableItem_Cluster); ok {
			return x.Cluster
		}
	}
	return nil
}

func (x *ItemTree_ItemTableItem) GetElement() *Element {
	if x != nil {
		if x, ok := x.Item.(*ItemTree_ItemTableItem_Element); ok {
			return x.Element
		}
	}
	return nil
}

type isItemTree_ItemTableItem_Item interface {
	isItemTree_ItemTableItem_Item()
}

type ItemTree_ItemTableItem_Cluster struct {
	Cluster *Cluster `protobuf:"bytes,1,opt,name=cluster,proto3,oneof"`
}

type ItemTree_ItemTableItem_Element struct {
	Element *Element `protobuf:"bytes,2,opt,name=element,proto3,oneof"`
}

func (*ItemTree_ItemTableItem_Cluster) isItemTree_ItemTableItem_Item() {}

func (*ItemTree_ItemTableItem_Element) isItemTree_ItemTableItem_Item() {}

type Cluster_ClusterItem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Item:
	//
	//	*Cluster_ClusterItem_Cluster
	//	*Cluster_ClusterItem_Element
	Item          isCluster_ClusterItem_Item `protobuf_oneof:"item"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Cluster_ClusterItem) Reset() {
	*x = Cluster_ClusterItem{}
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Cluster_ClusterItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Cluster_ClusterItem) ProtoMessage() {}

func (x *Cluster_ClusterItem) ProtoReflect() protoreflect.Message {
	mi := &file_openehr_v1_0_0_rm_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Cluster_ClusterItem.ProtoReflect.Descriptor instead.
func (*Cluster_ClusterItem) Descriptor() ([]byte, []int) {
	return file_openehr_v1_0_0_rm_proto_rawDescGZIP(), []int{81, 0}
}

func (x *Cluster_ClusterItem) GetItem() isCluster_ClusterItem_Item {
	if x != nil {
		return x.Item
	}
	return nil
}

func (x *Cluster_ClusterItem) GetCluster() *Cluster {
	if x != nil {
		if x, ok := x.Item.(*Cluster_ClusterItem_Cluster); ok {
			return x.Cluster
		}
	}
	return nil
}

func (x *Cluster_ClusterItem) GetElement() *Element {
	if x != nil {
		if x, ok := x.Item.(*Cluster_ClusterItem_Element); ok {
			return x.Element
		}
	}
	return nil
}

type isCluster_ClusterItem_Item interface {
	isCluster_ClusterItem_Item()
}

type Cluster_ClusterItem_Cluster struct {
	Cluster *Cluster `protobuf:"bytes,1,opt,name=cluster,proto3,oneof"`
}

type Cluster_ClusterItem_Element struct {
	Element *Element `protobuf:"bytes,2,opt,name=element,proto3,oneof"`
}

func (*Cluster_ClusterItem_Cluster) isCluster_ClusterItem_Item() {}

func (*Cluster_ClusterItem_Element) isCluster_ClusterItem_Item() {}

var File_openehr_v1_0_0_rm_proto protoreflect.FileDescriptor

const file_openehr_v1_0_0_rm_proto_rawDesc = "" +
	"\n" +
	"\x17openehr/v1.0.0/rm.proto\x12\baudit.v1\"\x9c\x04\n" +
	"\x03Ehr\x123\n" +
	"\tsystem_id\x18\x01 \x01(\v2\x16.audit.v1.HierObjectIdR\bsystemId\x12-\n" +
	"\x06ehr_id\x18\x02 \x01(\v2\x16.audit.v1.HierObjectIdR\x05ehrId\x129\n" +
	"\rcontributions\x18\x03 \x03(\v2\x13.audit.v1.ObjectRefR\rcontributions\x122\n" +
	"\n" +
	"ehr_status\x18\x04 \x01(\v2\x13.audit.v1.ObjectRefR\tehrStatus\x122\n" +
	"\n" +
	"ehr_access\x18\x05 \x01(\v2\x13.audit.v1.ObjectRefR\tehrAccess\x127\n" +
	"\fcompositions\x18\x06 \x03(\v2\x13.audit.v1.ObjectRefR\fcompositions\x126\n" +
	"\tdirectoyr\x18\a \x01(\v2\x13.audit.v1.ObjectRefH\x00R\tdirectoyr\x88\x01\x01\x127\n" +
	"\ftime_created\x18\b \x01(\v2\x14.audit.v1.DvDateTimeR\vtimeCreated\x12-\n" +
	"\afolders\x18\t \x03(\v2\x13.audit.v1.ObjectRefR\afolders\x12'\n" +
	"\x04tags\x18\n" +
	" \x03(\v2\x13.audit.v1.ObjectRefR\x04tagsB\f\n" +
	"\n" +
	"_directoyr\"\xa7\x05\n" +
	"\vComposition\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x120\n" +
	"\blanguage\x18\a \x01(\v2\x14.audit.v1.CodePhraseR\blanguage\x122\n" +
	"\tterritory\x18\b \x01(\v2\x14.audit.v1.CodePhraseR\tterritory\x121\n" +
	"\bcategory\x18\t \x01(\v2\x15.audit.v1.DvCodedTextR\bcategory\x125\n" +
	"\acontext\x18\n" +
	" \x01(\v2\x16.audit.v1.EventContextH\x03R\acontext\x88\x01\x01\x120\n" +
	"\bcomposer\x18\v \x01(\v2\x14.audit.v1.PartyProxyR\bcomposer\x12/\n" +
	"\acontent\x18\f \x03(\v2\x15.audit.v1.ContentItemR\acontentB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\n" +
	"\n" +
	"\b_context\"\xdb\x03\n" +
	"\fEventContext\x123\n" +
	"\n" +
	"start_time\x18\x01 \x01(\v2\x14.audit.v1.DvDateTimeR\tstartTime\x124\n" +
	"\bend_time\x18\x02 \x01(\v2\x14.audit.v1.DvDateTimeH\x00R\aendTime\x88\x01\x01\x12\x1f\n" +
	"\blocation\x18\x03 \x01(\tH\x01R\blocation\x88\x01\x01\x12/\n" +
	"\asetting\x18\x04 \x01(\v2\x15.audit.v1.DvCodedTextR\asetting\x12A\n" +
	"\rother_context\x18\x05 \x01(\v2\x17.audit.v1.ItemStructureH\x02R\fotherContext\x88\x01\x01\x12I\n" +
	"\x10party_identified\x18\x06 \x01(\v2\x19.audit.v1.PartyIdentifiedH\x03R\x0fpartyIdentified\x88\x01\x01\x12?\n" +
	"\x0eparticipations\x18\a \x03(\v2\x17.audit.v1.ParticipationR\x0eparticipationsB\v\n" +
	"\t_end_timeB\v\n" +
	"\t_locationB\x10\n" +
	"\x0e_other_contextB\x13\n" +
	"\x11_party_identified\"\xcc\x02\n" +
	"\vContentItem\x12-\n" +
	"\asection\x18\x01 \x01(\v2\x11.audit.v1.SectionH\x00R\asection\x12,\n" +
	"\x05entry\x18\x02 \x01(\v2\x14.audit.v1.AdminEntryH\x00R\x05entry\x129\n" +
	"\vobservation\x18\x03 \x01(\v2\x15.audit.v1.ObservationH\x00R\vobservation\x126\n" +
	"\n" +
	"evaluation\x18\x04 \x01(\v2\x14.audit.v1.EvaluationH\x00R\n" +
	"evaluation\x129\n" +
	"\vinstruction\x18\x05 \x01(\v2\x15.audit.v1.InstructionH\x00R\vinstruction\x12*\n" +
	"\x06action\x18\x06 \x01(\v2\x10.audit.v1.ActionH\x00R\x06actionB\x06\n" +
	"\x04item\"\x91\x03\n" +
	"\aSection\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x12+\n" +
	"\x05items\x18\a \x03(\v2\x15.audit.v1.ContentItemR\x05itemsB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_audit\"\x83\x06\n" +
	"\n" +
	"AdminEntry\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x120\n" +
	"\blanguage\x18\a \x01(\v2\x14.audit.v1.CodePhraseR\blanguage\x120\n" +
	"\bencoding\x18\b \x01(\v2\x14.audit.v1.CodePhraseR\bencoding\x12J\n" +
	"\x14other_participations\x18\t \x03(\v2\x17.audit.v1.ParticipationR\x13otherParticipations\x129\n" +
	"\vworkflow_id\x18\n" +
	" \x01(\v2\x13.audit.v1.ObjectRefH\x03R\n" +
	"workflowId\x88\x01\x01\x12.\n" +
	"\asubject\x18\v \x01(\v2\x14.audit.v1.PartyProxyR\asubject\x125\n" +
	"\bprovider\x18\f \x01(\v2\x14.audit.v1.PartyProxyH\x04R\bprovider\x88\x01\x01\x12+\n" +
	"\x04data\x18\r \x01(\v2\x17.audit.v1.ItemStructureR\x04dataB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\x0e\n" +
	"\f_workflow_idB\v\n" +
	"\t_provider\"\xe5\a\n" +
	"\vObservation\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x120\n" +
	"\blanguage\x18\a \x01(\v2\x14.audit.v1.CodePhraseR\blanguage\x120\n" +
	"\bencoding\x18\b \x01(\v2\x14.audit.v1.CodePhraseR\bencoding\x12J\n" +
	"\x14other_participations\x18\t \x03(\v2\x17.audit.v1.ParticipationR\x13otherParticipations\x129\n" +
	"\vworkflow_id\x18\n" +
	" \x01(\v2\x13.audit.v1.ObjectRefH\x03R\n" +
	"workflowId\x88\x01\x01\x12.\n" +
	"\asubject\x18\v \x01(\v2\x14.audit.v1.PartyProxyR\asubject\x125\n" +
	"\bprovider\x18\f \x01(\v2\x14.audit.v1.PartyProxyH\x04R\bprovider\x88\x01\x01\x128\n" +
	"\bprotocol\x18\r \x01(\v2\x17.audit.v1.ItemStructureH\x05R\bprotocol\x88\x01\x01\x12;\n" +
	"\fguideline_id\x18\x0e \x01(\v2\x13.audit.v1.ObjectRefH\x06R\vguidelineId\x88\x01\x01\x122\n" +
	"\x04data\x18\x0f \x01(\v2\x1e.audit.v1.HistoryItemStructureR\x04data\x129\n" +
	"\x05state\x18\x10 \x01(\v2\x1e.audit.v1.HistoryItemStructureH\aR\x05state\x88\x01\x01B\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\x0e\n" +
	"\f_workflow_idB\v\n" +
	"\t_providerB\v\n" +
	"\t_protocolB\x0f\n" +
	"\r_guideline_idB\b\n" +
	"\x06_state\"\x98\a\n" +
	"\n" +
	"Evaluation\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x120\n" +
	"\blanguage\x18\a \x01(\v2\x14.audit.v1.CodePhraseR\blanguage\x120\n" +
	"\bencoding\x18\b \x01(\v2\x14.audit.v1.CodePhraseR\bencoding\x12J\n" +
	"\x14other_participations\x18\t \x03(\v2\x17.audit.v1.ParticipationR\x13otherParticipations\x129\n" +
	"\vworkflow_id\x18\n" +
	" \x01(\v2\x13.audit.v1.ObjectRefH\x03R\n" +
	"workflowId\x88\x01\x01\x12.\n" +
	"\asubject\x18\v \x01(\v2\x14.audit.v1.PartyProxyR\asubject\x125\n" +
	"\bprovider\x18\f \x01(\v2\x14.audit.v1.PartyProxyH\x04R\bprovider\x88\x01\x01\x128\n" +
	"\bprotocol\x18\r \x01(\v2\x17.audit.v1.ItemStructureH\x05R\bprotocol\x88\x01\x01\x12;\n" +
	"\fguideline_id\x18\x0e \x01(\v2\x13.audit.v1.ObjectRefH\x06R\vguidelineId\x88\x01\x01\x12+\n" +
	"\x04data\x18\x0f \x01(\v2\x17.audit.v1.ItemStructureR\x04dataB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\x0e\n" +
	"\f_workflow_idB\v\n" +
	"\t_providerB\v\n" +
	"\t_protocolB\x0f\n" +
	"\r_guideline_id\"\xee\b\n" +
	"\vInstruction\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x120\n" +
	"\blanguage\x18\a \x01(\v2\x14.audit.v1.CodePhraseR\blanguage\x120\n" +
	"\bencoding\x18\b \x01(\v2\x14.audit.v1.CodePhraseR\bencoding\x12J\n" +
	"\x14other_participations\x18\t \x03(\v2\x17.audit.v1.ParticipationR\x13otherParticipations\x129\n" +
	"\vworkflow_id\x18\n" +
	" \x01(\v2\x13.audit.v1.ObjectRefH\x03R\n" +
	"workflowId\x88\x01\x01\x12.\n" +
	"\asubject\x18\v \x01(\v2\x14.audit.v1.PartyProxyR\asubject\x125\n" +
	"\bprovider\x18\f \x01(\v2\x14.audit.v1.PartyProxyH\x04R\bprovider\x88\x01\x01\x128\n" +
	"\bprotocol\x18\r \x01(\v2\x17.audit.v1.ItemStructureH\x05R\bprotocol\x88\x01\x01\x12;\n" +
	"\fguideline_id\x18\x0e \x01(\v2\x13.audit.v1.ObjectRefH\x06R\vguidelineId\x88\x01\x01\x12.\n" +
	"\tnarrative\x18\x0f \x01(\v2\x10.audit.v1.DvTextR\tnarrative\x12:\n" +
	"\vexpiry_time\x18\x10 \x01(\v2\x14.audit.v1.DvDateTimeH\aR\n" +
	"expiryTime\x88\x01\x01\x12>\n" +
	"\rwf_definition\x18\x11 \x01(\v2\x14.audit.v1.DvParsableH\bR\fwfDefinition\x88\x01\x01\x122\n" +
	"\n" +
	"activities\x18\x12 \x03(\v2\x12.audit.v1.ActivityR\n" +
	"activitiesB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\x0e\n" +
	"\f_workflow_idB\v\n" +
	"\t_providerB\v\n" +
	"\t_protocolB\x0f\n" +
	"\r_guideline_idB\x0e\n" +
	"\f_expiry_timeB\x10\n" +
	"\x0e_wf_definition\"\x8e\x04\n" +
	"\bActivity\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x121\n" +
	"\x06timing\x18\a \x01(\v2\x14.audit.v1.DvParsableH\x03R\x06timing\x88\x01\x01\x12.\n" +
	"\x13action_archetype_id\x18\b \x01(\tR\x11actionArchetypeId\x129\n" +
	"\vdescription\x18\t \x01(\v2\x17.audit.v1.ItemStructureR\vdescriptionB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\t\n" +
	"\a_timing\"\xf8\b\n" +
	"\x06Action\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x120\n" +
	"\blanguage\x18\a \x01(\v2\x14.audit.v1.CodePhraseR\blanguage\x120\n" +
	"\bencoding\x18\b \x01(\v2\x14.audit.v1.CodePhraseR\bencoding\x12J\n" +
	"\x14other_participations\x18\t \x03(\v2\x17.audit.v1.ParticipationR\x13otherParticipations\x129\n" +
	"\vworkflow_id\x18\n" +
	" \x01(\v2\x13.audit.v1.ObjectRefH\x03R\n" +
	"workflowId\x88\x01\x01\x12.\n" +
	"\asubject\x18\v \x01(\v2\x14.audit.v1.PartyProxyR\asubject\x125\n" +
	"\bprovider\x18\f \x01(\v2\x14.audit.v1.PartyProxyH\x04R\bprovider\x88\x01\x01\x128\n" +
	"\bprotocol\x18\r \x01(\v2\x17.audit.v1.ItemStructureH\x05R\bprotocol\x88\x01\x01\x12;\n" +
	"\fguideline_id\x18\x0e \x01(\v2\x13.audit.v1.ObjectRefH\x06R\vguidelineId\x88\x01\x01\x12(\n" +
	"\x04time\x18\x0f \x01(\v2\x14.audit.v1.DvDateTimeR\x04time\x12>\n" +
	"\x0eism_transition\x18\x10 \x01(\v2\x17.audit.v1.IsmTransitionR\rismTransition\x12R\n" +
	"\x13instruction_details\x18\x11 \x01(\v2\x1c.audit.v1.InstructionDetailsH\aR\x12instructionDetails\x88\x01\x01\x129\n" +
	"\vdescription\x18\x12 \x01(\v2\x17.audit.v1.ItemStructureR\vdescriptionB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\x0e\n" +
	"\f_workflow_idB\v\n" +
	"\t_providerB\v\n" +
	"\t_protocolB\x0f\n" +
	"\r_guideline_idB\x16\n" +
	"\x14_instruction_details\"\xc0\x01\n" +
	"\x12InstructionDetails\x12=\n" +
	"\x0einstruction_id\x18\x01 \x01(\v2\x16.audit.v1.LocatableRefR\rinstructionId\x12\x1f\n" +
	"\vactivity_id\x18\x02 \x01(\tR\n" +
	"activityId\x12;\n" +
	"\n" +
	"wf_details\x18\x03 \x01(\v2\x17.audit.v1.ItemStructureH\x00R\twfDetails\x88\x01\x01B\r\n" +
	"\v_wf_details\"\xa3\x02\n" +
	"\rIsmTransition\x12:\n" +
	"\rcurrent_state\x18\x01 \x01(\v2\x15.audit.v1.DvCodedTextR\fcurrentState\x12:\n" +
	"\n" +
	"transition\x18\x02 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\n" +
	"transition\x88\x01\x01\x12?\n" +
	"\rcareflow_step\x18\x03 \x01(\v2\x15.audit.v1.DvCodedTextH\x01R\fcareflowStep\x88\x01\x01\x12-\n" +
	"\x06reason\x18\x04 \x01(\v2\x10.audit.v1.DvTextH\x02R\x06reason\x88\x01\x01B\r\n" +
	"\v_transitionB\x10\n" +
	"\x0e_careflow_stepB\t\n" +
	"\a_reason\"\xa7\x01\n" +
	"\x12VersionedEhrAccess\x12(\n" +
	"\x03uid\x18\x01 \x01(\v2\x16.audit.v1.HierObjectIdR\x03uid\x12.\n" +
	"\bowner_id\x18\x02 \x01(\v2\x13.audit.v1.ObjectRefR\aownerId\x127\n" +
	"\ftime_created\x18\x03 \x01(\v2\x14.audit.v1.DvDateTimeR\vtimeCreated\"\xa7\x01\n" +
	"\x12VersionedEhrStatus\x12(\n" +
	"\x03uid\x18\x01 \x01(\v2\x16.audit.v1.HierObjectIdR\x03uid\x12.\n" +
	"\bowner_id\x18\x02 \x01(\v2\x13.audit.v1.ObjectRefR\aownerId\x127\n" +
	"\ftime_created\x18\x03 \x01(\v2\x14.audit.v1.DvDateTimeR\vtimeCreated\"\xa4\x01\n" +
	"\x0fVersionedFolder\x12(\n" +
	"\x03uid\x18\x01 \x01(\v2\x16.audit.v1.HierObjectIdR\x03uid\x12.\n" +
	"\bowner_id\x18\x02 \x01(\v2\x13.audit.v1.ObjectRefR\aownerId\x127\n" +
	"\ftime_created\x18\x03 \x01(\v2\x14.audit.v1.DvDateTimeR\vtimeCreated\"\xa3\x01\n" +
	"\x0eVersionedParty\x12(\n" +
	"\x03uid\x18\x01 \x01(\v2\x16.audit.v1.HierObjectIdR\x03uid\x12.\n" +
	"\bowner_id\x18\x02 \x01(\v2\x13.audit.v1.ObjectRefR\aownerId\x127\n" +
	"\ftime_created\x18\x03 \x01(\v2\x14.audit.v1.DvDateTimeR\vtimeCreated\"\x86\x03\n" +
	"\bObjectId\x12>\n" +
	"\x0ehier_object_id\x18\x01 \x01(\v2\x16.audit.v1.HierObjectIdH\x00R\fhierObjectId\x12G\n" +
	"\x11object_version_id\x18\x02 \x01(\v2\x19.audit.v1.ObjectVersionIdH\x00R\x0fobjectVersionId\x12:\n" +
	"\farchetype_id\x18\x03 \x01(\v2\x15.audit.v1.ArchetypeIdH\x00R\varchetypeId\x127\n" +
	"\vtemplate_id\x18\x04 \x01(\v2\x14.audit.v1.TemplateIdH\x00R\n" +
	"templateId\x12@\n" +
	"\x0eterminology_id\x18\x05 \x01(\v2\x17.audit.v1.TerminologyIdH\x00R\rterminologyId\x124\n" +
	"\n" +
	"generic_id\x18\x06 \x01(\v2\x13.audit.v1.GenericIdH\x00R\tgenericIdB\x04\n" +
	"\x02id\"\x9b\x01\n" +
	"\n" +
	"UidBasedId\x12>\n" +
	"\x0ehier_object_id\x18\x01 \x01(\v2\x16.audit.v1.HierObjectIdH\x00R\fhierObjectId\x12G\n" +
	"\x11object_version_id\x18\x02 \x01(\v2\x19.audit.v1.ObjectVersionIdH\x00R\x0fobjectVersionIdB\x04\n" +
	"\x02id\"$\n" +
	"\fHierObjectId\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\"'\n" +
	"\x0fObjectVersionId\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\"#\n" +
	"\vArchetypeId\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\"\"\n" +
	"\n" +
	"TemplateId\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\"%\n" +
	"\rTerminologyId\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\"9\n" +
	"\tGenericId\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\x12\x16\n" +
	"\x06scheme\x18\x02 \x01(\tR\x06scheme\"a\n" +
	"\tObjectRef\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespace\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x12\"\n" +
	"\x02id\x18\x03 \x01(\v2\x12.audit.v1.ObjectIdR\x02id\"`\n" +
	"\bPartyRef\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespace\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x12\"\n" +
	"\x02id\x18\x03 \x01(\v2\x12.audit.v1.ObjectIdR\x02id\"\x88\x01\n" +
	"\fLocatableRef\x12\x1c\n" +
	"\tnamespace\x18\x01 \x01(\tR\tnamespace\x12\x12\n" +
	"\x04type\x18\x02 \x01(\tR\x04type\x12$\n" +
	"\x02id\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdR\x02id\x12\x17\n" +
	"\x04path\x18\x04 \x01(\tH\x00R\x04path\x88\x01\x01B\a\n" +
	"\x05_path\"\x80\v\n" +
	"\tDataValue\x124\n" +
	"\n" +
	"dv_boolean\x18\x01 \x01(\v2\x13.audit.v1.DvBooleanH\x00R\tdvBoolean\x12.\n" +
	"\bdv_state\x18\x02 \x01(\v2\x11.audit.v1.DvStateH\x00R\advState\x12=\n" +
	"\rdv_identifier\x18\x03 \x01(\v2\x16.audit.v1.DvIdentifierH\x00R\fdvIdentifier\x12+\n" +
	"\adv_text\x18\x04 \x01(\v2\x10.audit.v1.DvTextH\x00R\x06dvText\x12;\n" +
	"\rdv_coded_text\x18\x05 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\vdvCodedText\x12:\n" +
	"\fdv_paragraph\x18\x06 \x01(\v2\x15.audit.v1.DvParagraphH\x00R\vdvParagraph\x12A\n" +
	"\x0fdv_interval_any\x18\a \x01(\v2\x17.audit.v1.DvIntervalAnyH\x00R\rdvIntervalAny\x12R\n" +
	"\x16dv_reference_range_any\x18\b \x01(\v2\x1b.audit.v1.ReferenceRangeAnyH\x00R\x13dvReferenceRangeAny\x124\n" +
	"\n" +
	"dv_ordinal\x18\t \x01(\v2\x13.audit.v1.DvOrdinalH\x00R\tdvOrdinal\x12.\n" +
	"\bdv_scale\x18\n" +
	" \x01(\v2\x11.audit.v1.DvScaleH\x00R\advScale\x127\n" +
	"\vdv_quantity\x18\v \x01(\v2\x14.audit.v1.DvQuantityH\x00R\n" +
	"dvQuantity\x12.\n" +
	"\bdv_count\x18\f \x01(\v2\x11.audit.v1.DvCountH\x00R\advCount\x12=\n" +
	"\rdv_proportion\x18\r \x01(\v2\x16.audit.v1.DvProportionH\x00R\fdvProportion\x12+\n" +
	"\adv_date\x18\x0e \x01(\v2\x10.audit.v1.DvDateH\x00R\x06dvDate\x12+\n" +
	"\adv_time\x18\x0f \x01(\v2\x10.audit.v1.DvTimeH\x00R\x06dvTime\x128\n" +
	"\fdv_date_time\x18\x10 \x01(\v2\x14.audit.v1.DvDateTimeH\x00R\n" +
	"dvDateTime\x127\n" +
	"\vdv_duration\x18\x11 \x01(\v2\x14.audit.v1.DvDurationH\x00R\n" +
	"dvDuration\x12l\n" +
	"\x1edv_periodic_time_specification\x18\x12 \x01(\v2%.audit.v1.DvPeriodicTimeSpecificationH\x00R\x1bdvPeriodicTimeSpecification\x12i\n" +
	"\x1ddv_general_time_specification\x18\x13 \x01(\v2$.audit.v1.DvGeneralTimeSpecificationH\x00R\x1advGeneralTimeSpecification\x12=\n" +
	"\rdv_multimedia\x18\x14 \x01(\v2\x16.audit.v1.DvMultimediaH\x00R\fdvMultimedia\x127\n" +
	"\vdv_parsable\x18\x15 \x01(\v2\x14.audit.v1.DvParsableH\x00R\n" +
	"dvParsable\x12(\n" +
	"\x06dv_uri\x18\x16 \x01(\v2\x0f.audit.v1.DvUriH\x00R\x05dvUri\x122\n" +
	"\n" +
	"dv_ehr_uri\x18\x17 \x01(\v2\x12.audit.v1.DvEhrUriH\x00R\bdvEhrUriB\a\n" +
	"\x05value\"!\n" +
	"\tDvBoolean\x12\x14\n" +
	"\x05value\x18\x01 \x01(\bR\x05value\"W\n" +
	"\aDvState\x12+\n" +
	"\x05value\x18\x01 \x01(\v2\x15.audit.v1.DvCodedTextR\x05value\x12\x1f\n" +
	"\vis_terminal\x18\x02 \x01(\bR\n" +
	"isTerminal\"\x96\x01\n" +
	"\fDvIdentifier\x12\x1b\n" +
	"\x06issuer\x18\x01 \x01(\tH\x00R\x06issuer\x88\x01\x01\x12\x1f\n" +
	"\bassigner\x18\x02 \x01(\tH\x01R\bassigner\x88\x01\x01\x12\x0e\n" +
	"\x02id\x18\x03 \x01(\tR\x02id\x12\x17\n" +
	"\x04type\x18\x04 \x01(\tH\x02R\x04type\x88\x01\x01B\t\n" +
	"\a_issuerB\v\n" +
	"\t_assignerB\a\n" +
	"\x05_type\"~\n" +
	"\n" +
	"DvTextType\x12+\n" +
	"\adv_text\x18\x01 \x01(\v2\x10.audit.v1.DvTextH\x00R\x06dvText\x12;\n" +
	"\rdv_coded_text\x18\x02 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\vdvCodedTextB\x06\n" +
	"\x04type\"\xcf\x02\n" +
	"\x06DvText\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\x122\n" +
	"\thyperlink\x18\x02 \x01(\v2\x0f.audit.v1.DvUriH\x00R\thyperlink\x88\x01\x01\x12#\n" +
	"\n" +
	"formatting\x18\x03 \x01(\tH\x01R\n" +
	"formatting\x88\x01\x01\x121\n" +
	"\bmappings\x18\x04 \x03(\v2\x15.audit.v1.TermMappingR\bmappings\x125\n" +
	"\blanguage\x18\x05 \x01(\v2\x14.audit.v1.CodePhraseH\x02R\blanguage\x88\x01\x01\x125\n" +
	"\bencoding\x18\x06 \x01(\v2\x14.audit.v1.CodePhraseH\x03R\bencoding\x88\x01\x01B\f\n" +
	"\n" +
	"_hyperlinkB\r\n" +
	"\v_formattingB\v\n" +
	"\t_languageB\v\n" +
	"\t_encoding\"\x8f\x03\n" +
	"\vDvCodedText\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\x122\n" +
	"\thyperlink\x18\x02 \x01(\v2\x0f.audit.v1.DvUriH\x00R\thyperlink\x88\x01\x01\x12#\n" +
	"\n" +
	"formatting\x18\x03 \x01(\tH\x01R\n" +
	"formatting\x88\x01\x01\x121\n" +
	"\bmappings\x18\x04 \x03(\v2\x15.audit.v1.TermMappingR\bmappings\x125\n" +
	"\blanguage\x18\x05 \x01(\v2\x14.audit.v1.CodePhraseH\x02R\blanguage\x88\x01\x01\x125\n" +
	"\bencoding\x18\x06 \x01(\v2\x14.audit.v1.CodePhraseH\x03R\bencoding\x88\x01\x01\x129\n" +
	"\rdefining_code\x18\a \x01(\v2\x14.audit.v1.CodePhraseR\fdefiningCodeB\f\n" +
	"\n" +
	"_hyperlinkB\r\n" +
	"\v_formattingB\v\n" +
	"\t_languageB\v\n" +
	"\t_encoding\"5\n" +
	"\vDvParagraph\x12&\n" +
	"\x05items\x18\x01 \x03(\v2\x10.audit.v1.DvTextR\x05items\"\xdb\x01\n" +
	"\rDvIntervalAny\x12\x14\n" +
	"\x05lower\x18\x01 \x01(\fR\x05lower\x12\x14\n" +
	"\x05upper\x18\x02 \x01(\fR\x05upper\x12'\n" +
	"\x0flower_unbounded\x18\x03 \x01(\bR\x0elowerUnbounded\x12'\n" +
	"\x0fupper_unbounded\x18\x04 \x01(\bR\x0eupperUnbounded\x12%\n" +
	"\x0elower_included\x18\x05 \x01(\bR\rlowerIncluded\x12%\n" +
	"\x0eupper_included\x18\x06 \x01(\bR\rupperIncluded\"\xdd\x01\n" +
	"\x0fDvIntervalInt64\x12\x14\n" +
	"\x05lower\x18\x01 \x01(\x03R\x05lower\x12\x14\n" +
	"\x05upper\x18\x02 \x01(\x03R\x05upper\x12'\n" +
	"\x0flower_unbounded\x18\x03 \x01(\bR\x0elowerUnbounded\x12'\n" +
	"\x0fupper_unbounded\x18\x04 \x01(\bR\x0eupperUnbounded\x12%\n" +
	"\x0elower_included\x18\x05 \x01(\bR\rlowerIncluded\x12%\n" +
	"\x0eupper_included\x18\x06 \x01(\bR\rupperIncluded\"\x8e\x02\n" +
	"\x14DvIntervalDvDateTime\x12*\n" +
	"\x05lower\x18\x01 \x01(\v2\x14.audit.v1.DvDateTimeR\x05lower\x12*\n" +
	"\x05upper\x18\x02 \x01(\v2\x14.audit.v1.DvDateTimeR\x05upper\x12'\n" +
	"\x0flower_unbounded\x18\x03 \x01(\bR\x0elowerUnbounded\x12'\n" +
	"\x0fupper_unbounded\x18\x04 \x01(\bR\x0eupperUnbounded\x12%\n" +
	"\x0elower_included\x18\x05 \x01(\bR\rlowerIncluded\x12%\n" +
	"\x0eupper_included\x18\x06 \x01(\bR\rupperIncluded\"\x8e\x02\n" +
	"\x14DvIntervalDvDuration\x12*\n" +
	"\x05lower\x18\x01 \x01(\v2\x14.audit.v1.DvDateTimeR\x05lower\x12*\n" +
	"\x05upper\x18\x02 \x01(\v2\x14.audit.v1.DvDateTimeR\x05upper\x12'\n" +
	"\x0flower_unbounded\x18\x03 \x01(\bR\x0elowerUnbounded\x12'\n" +
	"\x0fupper_unbounded\x18\x04 \x01(\bR\x0eupperUnbounded\x12%\n" +
	"\x0elower_included\x18\x05 \x01(\bR\rlowerIncluded\x12%\n" +
	"\x0eupper_included\x18\x06 \x01(\bR\rupperIncluded\"\x8e\x02\n" +
	"\x14DvIntervalDvQuantity\x12*\n" +
	"\x05lower\x18\x01 \x01(\v2\x14.audit.v1.DvQuantityR\x05lower\x12*\n" +
	"\x05upper\x18\x02 \x01(\v2\x14.audit.v1.DvQuantityR\x05upper\x12'\n" +
	"\x0flower_unbounded\x18\x03 \x01(\bR\x0elowerUnbounded\x12'\n" +
	"\x0fupper_unbounded\x18\x04 \x01(\bR\x0eupperUnbounded\x12%\n" +
	"\x0elower_included\x18\x05 \x01(\bR\rlowerIncluded\x12%\n" +
	"\x0eupper_included\x18\x06 \x01(\bR\rupperIncluded\"\x85\x02\n" +
	"\x11DvIntervalDvCount\x12'\n" +
	"\x05lower\x18\x01 \x01(\v2\x11.audit.v1.DvCountR\x05lower\x12'\n" +
	"\x05upper\x18\x02 \x01(\v2\x11.audit.v1.DvCountR\x05upper\x12'\n" +
	"\x0flower_unbounded\x18\x03 \x01(\bR\x0elowerUnbounded\x12'\n" +
	"\x0fupper_unbounded\x18\x04 \x01(\bR\x0eupperUnbounded\x12%\n" +
	"\x0elower_included\x18\x05 \x01(\bR\rlowerIncluded\x12%\n" +
	"\x0eupper_included\x18\x06 \x01(\bR\rupperIncluded\"\x94\x02\n" +
	"\x16DvIntervalDvProportion\x12,\n" +
	"\x05lower\x18\x01 \x01(\v2\x16.audit.v1.DvProportionR\x05lower\x12,\n" +
	"\x05upper\x18\x02 \x01(\v2\x16.audit.v1.DvProportionR\x05upper\x12'\n" +
	"\x0flower_unbounded\x18\x03 \x01(\bR\x0elowerUnbounded\x12'\n" +
	"\x0fupper_unbounded\x18\x04 \x01(\bR\x0eupperUnbounded\x12%\n" +
	"\x0elower_included\x18\x05 \x01(\bR\rlowerIncluded\x12%\n" +
	"\x0eupper_included\x18\x06 \x01(\bR\rupperIncluded\"r\n" +
	"\x11ReferenceRangeAny\x12.\n" +
	"\ameaning\x18\x01 \x01(\v2\x14.audit.v1.DvTextTypeR\ameaning\x12-\n" +
	"\x05range\x18\x02 \x01(\v2\x17.audit.v1.DvIntervalAnyR\x05range\"v\n" +
	"\x13ReferenceRangeInt64\x12.\n" +
	"\ameaning\x18\x01 \x01(\v2\x14.audit.v1.DvTextTypeR\ameaning\x12/\n" +
	"\x05range\x18\x02 \x01(\v2\x19.audit.v1.DvIntervalInt64R\x05range\"\xe3\x01\n" +
	"\x18ReferenceRangeDvDateTime\x12:\n" +
	"\x0fmeaning_dv_text\x18\x01 \x01(\v2\x10.audit.v1.DvTextH\x00R\rmeaningDvText\x12J\n" +
	"\x15meaning_dv_coded_text\x18\x02 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\x12meaningDvCodedText\x124\n" +
	"\x05range\x18\x03 \x01(\v2\x1e.audit.v1.DvIntervalDvDateTimeR\x05rangeB\t\n" +
	"\ameaning\"\xe3\x01\n" +
	"\x18ReferenceRangeDvQuantity\x12:\n" +
	"\x0fmeaning_dv_text\x18\x01 \x01(\v2\x10.audit.v1.DvTextH\x00R\rmeaningDvText\x12J\n" +
	"\x15meaning_dv_coded_text\x18\x02 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\x12meaningDvCodedText\x124\n" +
	"\x05range\x18\x03 \x01(\v2\x1e.audit.v1.DvIntervalDvQuantityR\x05rangeB\t\n" +
	"\ameaning\"\xdd\x01\n" +
	"\x15ReferenceRangeDvCount\x12:\n" +
	"\x0fmeaning_dv_text\x18\x01 \x01(\v2\x10.audit.v1.DvTextH\x00R\rmeaningDvText\x12J\n" +
	"\x15meaning_dv_coded_text\x18\x02 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\x12meaningDvCodedText\x121\n" +
	"\x05range\x18\x03 \x01(\v2\x1b.audit.v1.DvIntervalDvCountR\x05rangeB\t\n" +
	"\ameaning\"\xe7\x01\n" +
	"\x1aReferenceRangeDvProportion\x12:\n" +
	"\x0fmeaning_dv_text\x18\x01 \x01(\v2\x10.audit.v1.DvTextH\x00R\rmeaningDvText\x12J\n" +
	"\x15meaning_dv_coded_text\x18\x02 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\x12meaningDvCodedText\x126\n" +
	"\x05range\x18\x03 \x01(\v2 .audit.v1.DvIntervalDvProportionR\x05rangeB\t\n" +
	"\ameaning\"\xcb\x02\n" +
	"\tDvOrdinal\x12>\n" +
	"\rnormal_status\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\fnormalStatus\x88\x01\x01\x12A\n" +
	"\fnormal_range\x18\x02 \x01(\v2\x19.audit.v1.DvIntervalInt64H\x01R\vnormalRange\x88\x01\x01\x12S\n" +
	"\x16other_reference_ranges\x18\x03 \x03(\v2\x1d.audit.v1.ReferenceRangeInt64R\x14otherReferenceRanges\x12-\n" +
	"\x06symbol\x18\x04 \x01(\v2\x15.audit.v1.DvCodedTextR\x06symbol\x12\x14\n" +
	"\x05value\x18\x05 \x01(\x03R\x05valueB\x10\n" +
	"\x0e_normal_statusB\x0f\n" +
	"\r_normal_range\"\xc9\x02\n" +
	"\aDvScale\x12>\n" +
	"\rnormal_status\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\fnormalStatus\x88\x01\x01\x12A\n" +
	"\fnormal_range\x18\x02 \x01(\v2\x19.audit.v1.DvIntervalInt64H\x01R\vnormalRange\x88\x01\x01\x12S\n" +
	"\x16other_reference_ranges\x18\x03 \x03(\v2\x1d.audit.v1.ReferenceRangeInt64R\x14otherReferenceRanges\x12-\n" +
	"\x06symbol\x18\x04 \x01(\v2\x15.audit.v1.DvCodedTextR\x06symbol\x12\x14\n" +
	"\x05value\x18\x05 \x01(\x02R\x05valueB\x10\n" +
	"\x0e_normal_statusB\x0f\n" +
	"\r_normal_range\"\xb9\x05\n" +
	"\n" +
	"DvQuantity\x12>\n" +
	"\rnormal_status\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\fnormalStatus\x88\x01\x01\x12F\n" +
	"\fnormal_range\x18\x02 \x01(\v2\x1e.audit.v1.DvIntervalDvQuantityH\x01R\vnormalRange\x88\x01\x01\x12X\n" +
	"\x16other_reference_ranges\x18\x03 \x03(\v2\".audit.v1.ReferenceRangeDvQuantityR\x14otherReferenceRanges\x12.\n" +
	"\x10magnitude_status\x18\x04 \x01(\tH\x02R\x0fmagnitudeStatus\x88\x01\x01\x123\n" +
	"\x13accuracy_is_percent\x18\x05 \x01(\bH\x03R\x11accuracyIsPercent\x88\x01\x01\x12\x1f\n" +
	"\baccuracy\x18\x06 \x01(\x02H\x04R\baccuracy\x88\x01\x01\x12\x1c\n" +
	"\tmagnitude\x18\a \x01(\x02R\tmagnitude\x12!\n" +
	"\tprecision\x18\b \x01(\x03H\x05R\tprecision\x88\x01\x01\x12\x14\n" +
	"\x05units\x18\t \x01(\tR\x05units\x12&\n" +
	"\funits_system\x18\n" +
	" \x01(\tH\x06R\vunitsSystem\x88\x01\x01\x121\n" +
	"\x12units_display_name\x18\v \x01(\tH\aR\x10unitsDisplayName\x88\x01\x01B\x10\n" +
	"\x0e_normal_statusB\x0f\n" +
	"\r_normal_rangeB\x13\n" +
	"\x11_magnitude_statusB\x16\n" +
	"\x14_accuracy_is_percentB\v\n" +
	"\t_accuracyB\f\n" +
	"\n" +
	"_precisionB\x0f\n" +
	"\r_units_systemB\x15\n" +
	"\x13_units_display_name\"\xe6\x03\n" +
	"\aDvCount\x12>\n" +
	"\rnormal_status\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\fnormalStatus\x88\x01\x01\x12C\n" +
	"\fnormal_range\x18\x02 \x01(\v2\x1b.audit.v1.DvIntervalDvCountH\x01R\vnormalRange\x88\x01\x01\x12U\n" +
	"\x16other_reference_ranges\x18\x03 \x03(\v2\x1f.audit.v1.ReferenceRangeDvCountR\x14otherReferenceRanges\x12.\n" +
	"\x10magnitude_status\x18\x04 \x01(\tH\x02R\x0fmagnitudeStatus\x88\x01\x01\x123\n" +
	"\x13accuracy_is_percent\x18\x05 \x01(\bH\x03R\x11accuracyIsPercent\x88\x01\x01\x12\x1f\n" +
	"\baccuracy\x18\x06 \x01(\x02H\x04R\baccuracy\x88\x01\x01\x12\x1c\n" +
	"\tmagnitude\x18\a \x01(\x03R\tmagnitudeB\x10\n" +
	"\x0e_normal_statusB\x0f\n" +
	"\r_normal_rangeB\x13\n" +
	"\x11_magnitude_statusB\x16\n" +
	"\x14_accuracy_is_percentB\v\n" +
	"\t_accuracy\"\xdc\x04\n" +
	"\fDvProportion\x12>\n" +
	"\rnormal_status\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\fnormalStatus\x88\x01\x01\x12H\n" +
	"\fnormal_range\x18\x02 \x01(\v2 .audit.v1.DvIntervalDvProportionH\x01R\vnormalRange\x88\x01\x01\x12Z\n" +
	"\x16other_reference_ranges\x18\x03 \x03(\v2$.audit.v1.ReferenceRangeDvProportionR\x14otherReferenceRanges\x12.\n" +
	"\x10magnitude_status\x18\x04 \x01(\tH\x02R\x0fmagnitudeStatus\x88\x01\x01\x123\n" +
	"\x13accuracy_is_percent\x18\x05 \x01(\bH\x03R\x11accuracyIsPercent\x88\x01\x01\x12\x1f\n" +
	"\baccuracy\x18\x06 \x01(\x02H\x04R\baccuracy\x88\x01\x01\x12\x1c\n" +
	"\tnumerator\x18\a \x01(\x02R\tnumerator\x12 \n" +
	"\vdenominator\x18\b \x01(\x02R\vdenominator\x12\x12\n" +
	"\x04type\x18\t \x01(\x03R\x04type\x12!\n" +
	"\tprecision\x18\n" +
	" \x01(\x03H\x05R\tprecision\x88\x01\x01B\x10\n" +
	"\x0e_normal_statusB\x0f\n" +
	"\r_normal_rangeB\x13\n" +
	"\x11_magnitude_statusB\x16\n" +
	"\x14_accuracy_is_percentB\v\n" +
	"\t_accuracyB\f\n" +
	"\n" +
	"_precision\"\xb0\x03\n" +
	"\x06DvDate\x12>\n" +
	"\rnormal_status\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\fnormalStatus\x88\x01\x01\x12H\n" +
	"\fnormal_range\x18\x02 \x01(\v2 .audit.v1.DvIntervalDvProportionH\x01R\vnormalRange\x88\x01\x01\x12Z\n" +
	"\x16other_reference_ranges\x18\x03 \x03(\v2$.audit.v1.ReferenceRangeDvProportionR\x14otherReferenceRanges\x12.\n" +
	"\x10magnitude_status\x18\x04 \x01(\tH\x02R\x0fmagnitudeStatus\x88\x01\x01\x125\n" +
	"\baccuracy\x18\x05 \x01(\v2\x14.audit.v1.DvDurationH\x03R\baccuracy\x88\x01\x01\x12\x14\n" +
	"\x05value\x18\x06 \x01(\tR\x05valueB\x10\n" +
	"\x0e_normal_statusB\x0f\n" +
	"\r_normal_rangeB\x13\n" +
	"\x11_magnitude_statusB\v\n" +
	"\t_accuracy\"\xb0\x03\n" +
	"\x06DvTime\x12>\n" +
	"\rnormal_status\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\fnormalStatus\x88\x01\x01\x12H\n" +
	"\fnormal_range\x18\x02 \x01(\v2 .audit.v1.DvIntervalDvProportionH\x01R\vnormalRange\x88\x01\x01\x12Z\n" +
	"\x16other_reference_ranges\x18\x03 \x03(\v2$.audit.v1.ReferenceRangeDvProportionR\x14otherReferenceRanges\x12.\n" +
	"\x10magnitude_status\x18\x04 \x01(\tH\x02R\x0fmagnitudeStatus\x88\x01\x01\x125\n" +
	"\baccuracy\x18\x05 \x01(\v2\x14.audit.v1.DvDurationH\x03R\baccuracy\x88\x01\x01\x12\x14\n" +
	"\x05value\x18\x06 \x01(\tR\x05valueB\x10\n" +
	"\x0e_normal_statusB\x0f\n" +
	"\r_normal_rangeB\x13\n" +
	"\x11_magnitude_statusB\v\n" +
	"\t_accuracy\"\xb4\x03\n" +
	"\n" +
	"DvDateTime\x12>\n" +
	"\rnormal_status\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\fnormalStatus\x88\x01\x01\x12H\n" +
	"\fnormal_range\x18\x02 \x01(\v2 .audit.v1.DvIntervalDvProportionH\x01R\vnormalRange\x88\x01\x01\x12Z\n" +
	"\x16other_reference_ranges\x18\x03 \x03(\v2$.audit.v1.ReferenceRangeDvProportionR\x14otherReferenceRanges\x12.\n" +
	"\x10magnitude_status\x18\x04 \x01(\tH\x02R\x0fmagnitudeStatus\x88\x01\x01\x125\n" +
	"\baccuracy\x18\x05 \x01(\v2\x14.audit.v1.DvDurationH\x03R\baccuracy\x88\x01\x01\x12\x14\n" +
	"\x05value\x18\x06 \x01(\tR\x05valueB\x10\n" +
	"\x0e_normal_statusB\x0f\n" +
	"\r_normal_rangeB\x13\n" +
	"\x11_magnitude_statusB\v\n" +
	"\t_accuracy\"\xe7\x03\n" +
	"\n" +
	"DvDuration\x12>\n" +
	"\rnormal_status\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\fnormalStatus\x88\x01\x01\x12F\n" +
	"\fnormal_range\x18\x02 \x01(\v2\x1e.audit.v1.DvIntervalDvDateTimeH\x01R\vnormalRange\x88\x01\x01\x12X\n" +
	"\x16other_reference_ranges\x18\x03 \x03(\v2\".audit.v1.ReferenceRangeDvDateTimeR\x14otherReferenceRanges\x12.\n" +
	"\x10magnitude_status\x18\x04 \x01(\tH\x02R\x0fmagnitudeStatus\x88\x01\x01\x123\n" +
	"\x13accuracy_is_percent\x18\x05 \x01(\bH\x03R\x11accuracyIsPercent\x88\x01\x01\x12\x1f\n" +
	"\baccuracy\x18\x06 \x01(\x01H\x04R\baccuracy\x88\x01\x01\x12\x14\n" +
	"\x05value\x18\a \x01(\tR\x05valueB\x10\n" +
	"\x0e_normal_statusB\x0f\n" +
	"\r_normal_rangeB\x13\n" +
	"\x11_magnitude_statusB\x16\n" +
	"\x14_accuracy_is_percentB\v\n" +
	"\t_accuracy\"I\n" +
	"\x1bDvPeriodicTimeSpecification\x12*\n" +
	"\x05value\x18\x01 \x01(\v2\x14.audit.v1.DvParsableR\x05value\"H\n" +
	"\x1aDvGeneralTimeSpecification\x12*\n" +
	"\x05value\x18\x01 \x01(\v2\x14.audit.v1.DvParsableR\x05value\"\xa2\x05\n" +
	"\fDvMultimedia\x123\n" +
	"\acharset\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\acharset\x88\x01\x01\x125\n" +
	"\blanguage\x18\x02 \x01(\v2\x14.audit.v1.CodePhraseH\x01R\blanguage\x88\x01\x01\x12*\n" +
	"\x0ealternate_text\x18\x03 \x01(\tH\x02R\ralternateText\x88\x01\x01\x12&\n" +
	"\x03uri\x18\x04 \x01(\v2\x0f.audit.v1.DvUriH\x03R\x03uri\x88\x01\x01\x12\x17\n" +
	"\x04data\x18\x05 \x01(\fH\x04R\x04data\x88\x01\x01\x123\n" +
	"\n" +
	"media_type\x18\x06 \x01(\v2\x14.audit.v1.CodePhraseR\tmediaType\x12I\n" +
	"\x15compression_algorithm\x18\a \x01(\v2\x14.audit.v1.CodePhraseR\x14compressionAlgorithm\x12,\n" +
	"\x0fintegrity_check\x18\b \x01(\fH\x05R\x0eintegrityCheck\x88\x01\x01\x12?\n" +
	"\x19integrity_check_algorithm\x18\t \x01(\tH\x06R\x17integrityCheckAlgorithm\x88\x01\x01\x129\n" +
	"\tthumbnail\x18\n" +
	" \x01(\v2\x16.audit.v1.DvMultimediaH\aR\tthumbnail\x88\x01\x01\x12\x12\n" +
	"\x04size\x18\v \x01(\x03R\x04sizeB\n" +
	"\n" +
	"\b_charsetB\v\n" +
	"\t_languageB\x11\n" +
	"\x0f_alternate_textB\x06\n" +
	"\x04_uriB\a\n" +
	"\x05_dataB\x12\n" +
	"\x10_integrity_checkB\x1c\n" +
	"\x1a_integrity_check_algorithmB\f\n" +
	"\n" +
	"_thumbnail\"\xc5\x01\n" +
	"\n" +
	"DvParsable\x123\n" +
	"\acharset\x18\x01 \x01(\v2\x14.audit.v1.CodePhraseH\x00R\acharset\x88\x01\x01\x125\n" +
	"\blanguage\x18\x02 \x01(\v2\x14.audit.v1.CodePhraseH\x01R\blanguage\x88\x01\x01\x12\x14\n" +
	"\x05value\x18\x03 \x01(\tR\x05value\x12\x1c\n" +
	"\tformalism\x18\x04 \x01(\tR\tformalismB\n" +
	"\n" +
	"\b_charsetB\v\n" +
	"\t_language\"\x1d\n" +
	"\x05DvUri\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\" \n" +
	"\bDvEhrUri\x12\x14\n" +
	"\x05value\x18\x01 \x01(\tR\x05value\"\xac\x01\n" +
	"\n" +
	"CodePhrase\x12>\n" +
	"\x0eterminology_id\x18\x01 \x01(\v2\x17.audit.v1.TerminologyIdR\rterminologyId\x12\x1f\n" +
	"\vcode_string\x18\x02 \x01(\tR\n" +
	"codeString\x12*\n" +
	"\x0epreferred_term\x18\x03 \x01(\tH\x00R\rpreferredTerm\x88\x01\x01B\x11\n" +
	"\x0f_preferred_term\"\xc5\x01\n" +
	"\x18ReferenceRangeDvDuration\x12+\n" +
	"\adv_text\x18\x01 \x01(\v2\x10.audit.v1.DvTextH\x00R\x06dvText\x12;\n" +
	"\rdv_coded_text\x18\x02 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\vdvCodedText\x124\n" +
	"\x05range\x18\x03 \x01(\v2\x1e.audit.v1.DvIntervalDvDurationR\x05rangeB\t\n" +
	"\ameaning\"\x93\x01\n" +
	"\vTermMapping\x12\x14\n" +
	"\x05match\x18\x01 \x01(\tR\x05match\x124\n" +
	"\apurpose\x18\x02 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\apurpose\x88\x01\x01\x12,\n" +
	"\x06target\x18\x03 \x01(\v2\x14.audit.v1.CodePhraseR\x06targetB\n" +
	"\n" +
	"\b_purpose\"\xb1\x01\n" +
	"\n" +
	"Archetyped\x128\n" +
	"\farchetype_id\x18\x01 \x01(\v2\x15.audit.v1.ArchetypeIdR\varchetypeId\x12:\n" +
	"\vtemplate_id\x18\x02 \x01(\v2\x14.audit.v1.TemplateIdH\x00R\n" +
	"templateId\x88\x01\x01\x12\x1d\n" +
	"\n" +
	"rm_version\x18\x03 \x01(\tR\trmVersionB\x0e\n" +
	"\f_template_id\"\x84\x01\n" +
	"\x04Link\x12*\n" +
	"\ameaning\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\ameaning\x12$\n" +
	"\x04type\x18\x02 \x01(\v2\x10.audit.v1.DvTextR\x04type\x12*\n" +
	"\x06target\x18\x03 \x01(\v2\x12.audit.v1.DvEhrUriR\x06target\"\xe3\x03\n" +
	"\vFeederAudit\x12U\n" +
	"\x1boriginating_system_item_ids\x18\x01 \x03(\v2\x16.audit.v1.DvIdentifierR\x18originatingSystemItemIds\x12K\n" +
	"\x16feeder_system_item_ids\x18\x02 \x03(\v2\x16.audit.v1.DvIdentifierR\x13feederSystemItemIds\x12=\n" +
	"\rdv_multimedia\x18\x03 \x01(\v2\x16.audit.v1.DvMultimediaH\x00R\fdvMultimedia\x127\n" +
	"\vdv_parsable\x18\x04 \x01(\v2\x14.audit.v1.DvParsableH\x00R\n" +
	"dvParsable\x12V\n" +
	"\x18originating_system_audit\x18\x05 \x01(\v2\x1c.audit.v1.FeederAuditDetailsR\x16originatingSystemAudit\x12L\n" +
	"\x13feeder_system_audit\x18\x06 \x01(\v2\x1c.audit.v1.FeederAuditDetailsR\x11feederSystemAuditB\x12\n" +
	"\x10original_content\"\xbf\x03\n" +
	"\x12FeederAuditDetails\x12\x1b\n" +
	"\tsystem_id\x18\x01 \x01(\tR\bsystemId\x12:\n" +
	"\blocation\x18\x02 \x01(\v2\x19.audit.v1.PartyIdentifiedH\x00R\blocation\x88\x01\x01\x123\n" +
	"\asubject\x18\x03 \x01(\v2\x14.audit.v1.PartyProxyH\x01R\asubject\x88\x01\x01\x125\n" +
	"\bprovider\x18\x04 \x01(\v2\x14.audit.v1.PartyProxyH\x02R\bprovider\x88\x01\x01\x12-\n" +
	"\x04time\x18\x05 \x01(\v2\x14.audit.v1.DvDateTimeH\x03R\x04time\x88\x01\x01\x12\"\n" +
	"\n" +
	"version_id\x18\x06 \x01(\tH\x04R\tversionId\x88\x01\x01\x12A\n" +
	"\rother_details\x18\a \x01(\v2\x17.audit.v1.ItemStructureH\x05R\fotherDetails\x88\x01\x01B\v\n" +
	"\t_locationB\n" +
	"\n" +
	"\b_subjectB\v\n" +
	"\t_providerB\a\n" +
	"\x05_timeB\r\n" +
	"\v_version_idB\x10\n" +
	"\x0e_other_details\"\xd2\x01\n" +
	"\n" +
	"PartyProxy\x124\n" +
	"\n" +
	"party_self\x18\x01 \x01(\v2\x13.audit.v1.PartySelfH\x00R\tpartySelf\x12F\n" +
	"\x10party_identified\x18\x02 \x01(\v2\x19.audit.v1.PartyIdentifiedH\x00R\x0fpartyIdentified\x12=\n" +
	"\rparty_related\x18\x03 \x01(\v2\x16.audit.v1.PartyRelatedH\x00R\fpartyRelatedB\a\n" +
	"\x05proxy\"X\n" +
	"\tPartySelf\x12:\n" +
	"\fexternal_ref\x18\x01 \x01(\v2\x12.audit.v1.PartyRefH\x00R\vexternalRef\x88\x01\x01B\x0f\n" +
	"\r_external_ref\"\xba\x01\n" +
	"\x0fPartyIdentified\x12:\n" +
	"\fexternal_ref\x18\x01 \x01(\v2\x12.audit.v1.PartyRefH\x00R\vexternalRef\x88\x01\x01\x12\x17\n" +
	"\x04name\x18\x02 \x01(\tH\x01R\x04name\x88\x01\x01\x128\n" +
	"\videntifiers\x18\x03 \x03(\v2\x16.audit.v1.DvIdentifierR\videntifiersB\x0f\n" +
	"\r_external_refB\a\n" +
	"\x05_name\"\xf2\x01\n" +
	"\fPartyRelated\x12:\n" +
	"\fexternal_ref\x18\x01 \x01(\v2\x12.audit.v1.PartyRefH\x00R\vexternalRef\x88\x01\x01\x12\x17\n" +
	"\x04name\x18\x02 \x01(\tH\x01R\x04name\x88\x01\x01\x128\n" +
	"\videntifiers\x18\x03 \x03(\v2\x16.audit.v1.DvIdentifierR\videntifiers\x129\n" +
	"\frelationship\x18\x04 \x01(\v2\x15.audit.v1.DvCodedTextR\frelationshipB\x0f\n" +
	"\r_external_refB\a\n" +
	"\x05_name\"\xec\x01\n" +
	"\rParticipation\x12,\n" +
	"\bfunction\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\bfunction\x12.\n" +
	"\x04mode\x18\x02 \x01(\v2\x15.audit.v1.DvCodedTextH\x00R\x04mode\x88\x01\x01\x122\n" +
	"\tperformer\x18\x03 \x01(\v2\x14.audit.v1.PartyProxyR\tperformer\x127\n" +
	"\x04time\x18\x04 \x01(\v2\x1e.audit.v1.DvIntervalDvDateTimeH\x01R\x04time\x88\x01\x01B\a\n" +
	"\x05_modeB\a\n" +
	"\x05_time\"\xf1\x01\n" +
	"\rItemStructure\x127\n" +
	"\vitem_single\x18\x01 \x01(\v2\x14.audit.v1.ItemSingleH\x00R\n" +
	"itemSingle\x121\n" +
	"\titem_list\x18\x02 \x01(\v2\x12.audit.v1.ItemListH\x00R\bitemList\x124\n" +
	"\n" +
	"item_table\x18\x03 \x01(\v2\x13.audit.v1.ItemTableH\x00R\titemTable\x121\n" +
	"\titem_tree\x18\x04 \x01(\v2\x12.audit.v1.ItemTreeH\x00R\bitemTreeB\v\n" +
	"\tstructure\"\x8e\x03\n" +
	"\n" +
	"ItemSingle\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x12%\n" +
	"\x04item\x18\a \x01(\v2\x11.audit.v1.ElementR\x04itemB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_audit\"\x8e\x03\n" +
	"\bItemList\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x12'\n" +
	"\x05items\x18\a \x03(\v2\x11.audit.v1.ElementR\x05itemsB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_audit\"\x8d\x03\n" +
	"\tItemTable\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x12%\n" +
	"\x04rows\x18\a \x03(\v2\x11.audit.v1.ClusterR\x04rowsB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_audit\"\x94\x04\n" +
	"\bItemTree\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x126\n" +
	"\x05items\x18\a \x03(\v2 .audit.v1.ItemTree.ItemTableItemR\x05items\x1au\n" +
	"\rItemTableItem\x12-\n" +
	"\acluster\x18\x01 \x01(\v2\x11.audit.v1.ClusterH\x00R\acluster\x12-\n" +
	"\aelement\x18\x02 \x01(\v2\x11.audit.v1.ElementH\x00R\aelementB\x06\n" +
	"\x04itemB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_audit\"\x8e\x04\n" +
	"\aCluster\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x123\n" +
	"\x05items\x18\a \x03(\v2\x1d.audit.v1.Cluster.ClusterItemR\x05items\x1as\n" +
	"\vClusterItem\x12-\n" +
	"\acluster\x18\x01 \x01(\v2\x11.audit.v1.ClusterH\x00R\acluster\x12-\n" +
	"\aelement\x18\x02 \x01(\v2\x11.audit.v1.ElementH\x00R\aelementB\x06\n" +
	"\x04itemB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_audit\"\xb6\x04\n" +
	"\aElement\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x12=\n" +
	"\fnull_flavour\x18\a \x01(\v2\x15.audit.v1.DvCodedTextH\x03R\vnullFlavour\x88\x01\x01\x12.\n" +
	"\x05value\x18\b \x01(\v2\x13.audit.v1.DataValueH\x04R\x05value\x88\x01\x01\x126\n" +
	"\vnull_reason\x18\t \x01(\v2\x10.audit.v1.DvTextH\x05R\n" +
	"nullReason\x88\x01\x01B\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\x0f\n" +
	"\r_null_flavourB\b\n" +
	"\x06_valueB\x0e\n" +
	"\f_null_reason\"\x8e\x05\n" +
	"\x14HistoryItemStructure\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x12,\n" +
	"\x06origin\x18\a \x01(\v2\x14.audit.v1.DvDateTimeR\x06origin\x121\n" +
	"\x06period\x18\b \x01(\v2\x14.audit.v1.DvDurationH\x03R\x06period\x88\x01\x01\x125\n" +
	"\bduration\x18\t \x01(\v2\x14.audit.v1.DvDurationH\x04R\bduration\x88\x01\x01\x126\n" +
	"\asummary\x18\n" +
	" \x01(\v2\x17.audit.v1.ItemStructureH\x05R\asummary\x88\x01\x01\x12'\n" +
	"\x06events\x18\v \x03(\v2\x0f.audit.v1.EventR\x06eventsB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\t\n" +
	"\a_periodB\v\n" +
	"\t_durationB\n" +
	"\n" +
	"\b_summary\"\x8a\x01\n" +
	"\x05Event\x127\n" +
	"\vpoint_event\x18\x01 \x01(\v2\x14.audit.v1.PointEventH\x00R\n" +
	"pointEvent\x12@\n" +
	"\x0einterval_event\x18\x02 \x01(\v2\x17.audit.v1.IntervalEventH\x00R\rintervalEventB\x06\n" +
	"\x04type\"\xe3\x03\n" +
	"\n" +
	"PointEvent\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x12(\n" +
	"\x04time\x18\a \x01(\v2\x14.audit.v1.DvDateTimeR\x04time\x122\n" +
	"\x05state\x18\b \x01(\v2\x17.audit.v1.ItemStructureH\x03R\x05state\x88\x01\x01\x12\x12\n" +
	"\x04data\x18\t \x01(\fR\x04dataB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\b\n" +
	"\x06_state\"\x87\x05\n" +
	"\rIntervalEvent\x12$\n" +
	"\x04name\x18\x01 \x01(\v2\x10.audit.v1.DvTextR\x04name\x12*\n" +
	"\x11archetype_node_id\x18\x02 \x01(\tR\x0farchetypeNodeId\x12+\n" +
	"\x03uid\x18\x03 \x01(\v2\x14.audit.v1.UidBasedIdH\x00R\x03uid\x88\x01\x01\x12$\n" +
	"\x05links\x18\x04 \x03(\v2\x0e.audit.v1.LinkR\x05links\x12F\n" +
	"\x11archetype_details\x18\x05 \x01(\v2\x14.audit.v1.ArchetypedH\x01R\x10archetypeDetails\x88\x01\x01\x12=\n" +
	"\ffeeder_audit\x18\x06 \x01(\v2\x15.audit.v1.FeederAuditH\x02R\vfeederAudit\x88\x01\x01\x12(\n" +
	"\x04time\x18\a \x01(\v2\x14.audit.v1.DvDateTimeR\x04time\x122\n" +
	"\x05state\x18\b \x01(\v2\x17.audit.v1.ItemStructureH\x03R\x05state\x88\x01\x01\x12\x12\n" +
	"\x04data\x18\t \x01(\fR\x04data\x12*\n" +
	"\x05width\x18\n" +
	" \x01(\v2\x14.audit.v1.DvDurationR\x05width\x12&\n" +
	"\fsample_count\x18\v \x01(\x03H\x04R\vsampleCount\x88\x01\x01\x12:\n" +
	"\rmath_function\x18\f \x01(\v2\x15.audit.v1.DvCodedTextR\fmathFunctionB\x06\n" +
	"\x04_uidB\x14\n" +
	"\x12_archetype_detailsB\x0f\n" +
	"\r_feeder_auditB\b\n" +
	"\x06_stateB\x0f\n" +
	"\r_sample_countB?Z=github.com/freekieb7/gopenehr/exp/protobuf/gen/openehr/v1.1.0b\x06proto3"

var (
	file_openehr_v1_0_0_rm_proto_rawDescOnce sync.Once
	file_openehr_v1_0_0_rm_proto_rawDescData []byte
)

func file_openehr_v1_0_0_rm_proto_rawDescGZIP() []byte {
	file_openehr_v1_0_0_rm_proto_rawDescOnce.Do(func() {
		file_openehr_v1_0_0_rm_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_openehr_v1_0_0_rm_proto_rawDesc), len(file_openehr_v1_0_0_rm_proto_rawDesc)))
	})
	return file_openehr_v1_0_0_rm_proto_rawDescData
}

var file_openehr_v1_0_0_rm_proto_msgTypes = make([]protoimpl.MessageInfo, 89)
var file_openehr_v1_0_0_rm_proto_goTypes = []any{
	(*Ehr)(nil),                         // 0: audit.v1.Ehr
	(*Composition)(nil),                 // 1: audit.v1.Composition
	(*EventContext)(nil),                // 2: audit.v1.EventContext
	(*ContentItem)(nil),                 // 3: audit.v1.ContentItem
	(*Section)(nil),                     // 4: audit.v1.Section
	(*AdminEntry)(nil),                  // 5: audit.v1.AdminEntry
	(*Observation)(nil),                 // 6: audit.v1.Observation
	(*Evaluation)(nil),                  // 7: audit.v1.Evaluation
	(*Instruction)(nil),                 // 8: audit.v1.Instruction
	(*Activity)(nil),                    // 9: audit.v1.Activity
	(*Action)(nil),                      // 10: audit.v1.Action
	(*InstructionDetails)(nil),          // 11: audit.v1.InstructionDetails
	(*IsmTransition)(nil),               // 12: audit.v1.IsmTransition
	(*VersionedEhrAccess)(nil),          // 13: audit.v1.VersionedEhrAccess
	(*VersionedEhrStatus)(nil),          // 14: audit.v1.VersionedEhrStatus
	(*VersionedFolder)(nil),             // 15: audit.v1.VersionedFolder
	(*VersionedParty)(nil),              // 16: audit.v1.VersionedParty
	(*ObjectId)(nil),                    // 17: audit.v1.ObjectId
	(*UidBasedId)(nil),                  // 18: audit.v1.UidBasedId
	(*HierObjectId)(nil),                // 19: audit.v1.HierObjectId
	(*ObjectVersionId)(nil),             // 20: audit.v1.ObjectVersionId
	(*ArchetypeId)(nil),                 // 21: audit.v1.ArchetypeId
	(*TemplateId)(nil),                  // 22: audit.v1.TemplateId
	(*TerminologyId)(nil),               // 23: audit.v1.TerminologyId
	(*GenericId)(nil),                   // 24: audit.v1.GenericId
	(*ObjectRef)(nil),                   // 25: audit.v1.ObjectRef
	(*PartyRef)(nil),                    // 26: audit.v1.PartyRef
	(*LocatableRef)(nil),                // 27: audit.v1.LocatableRef
	(*DataValue)(nil),                   // 28: audit.v1.DataValue
	(*DvBoolean)(nil),                   // 29: audit.v1.DvBoolean
	(*DvState)(nil),                     // 30: audit.v1.DvState
	(*DvIdentifier)(nil),                // 31: audit.v1.DvIdentifier
	(*DvTextType)(nil),                  // 32: audit.v1.DvTextType
	(*DvText)(nil),                      // 33: audit.v1.DvText
	(*DvCodedText)(nil),                 // 34: audit.v1.DvCodedText
	(*DvParagraph)(nil),                 // 35: audit.v1.DvParagraph
	(*DvIntervalAny)(nil),               // 36: audit.v1.DvIntervalAny
	(*DvIntervalInt64)(nil),             // 37: audit.v1.DvIntervalInt64
	(*DvIntervalDvDateTime)(nil),        // 38: audit.v1.DvIntervalDvDateTime
	(*DvIntervalDvDuration)(nil),        // 39: audit.v1.DvIntervalDvDuration
	(*DvIntervalDvQuantity)(nil),        // 40: audit.v1.DvIntervalDvQuantity
	(*DvIntervalDvCount)(nil),           // 41: audit.v1.DvIntervalDvCount
	(*DvIntervalDvProportion)(nil),      // 42: audit.v1.DvIntervalDvProportion
	(*ReferenceRangeAny)(nil),           // 43: audit.v1.ReferenceRangeAny
	(*ReferenceRangeInt64)(nil),         // 44: audit.v1.ReferenceRangeInt64
	(*ReferenceRangeDvDateTime)(nil),    // 45: audit.v1.ReferenceRangeDvDateTime
	(*ReferenceRangeDvQuantity)(nil),    // 46: audit.v1.ReferenceRangeDvQuantity
	(*ReferenceRangeDvCount)(nil),       // 47: audit.v1.ReferenceRangeDvCount
	(*ReferenceRangeDvProportion)(nil),  // 48: audit.v1.ReferenceRangeDvProportion
	(*DvOrdinal)(nil),                   // 49: audit.v1.DvOrdinal
	(*DvScale)(nil),                     // 50: audit.v1.DvScale
	(*DvQuantity)(nil),                  // 51: audit.v1.DvQuantity
	(*DvCount)(nil),                     // 52: audit.v1.DvCount
	(*DvProportion)(nil),                // 53: audit.v1.DvProportion
	(*DvDate)(nil),                      // 54: audit.v1.DvDate
	(*DvTime)(nil),                      // 55: audit.v1.DvTime
	(*DvDateTime)(nil),                  // 56: audit.v1.DvDateTime
	(*DvDuration)(nil),                  // 57: audit.v1.DvDuration
	(*DvPeriodicTimeSpecification)(nil), // 58: audit.v1.DvPeriodicTimeSpecification
	(*DvGeneralTimeSpecification)(nil),  // 59: audit.v1.DvGeneralTimeSpecification
	(*DvMultimedia)(nil),                // 60: audit.v1.DvMultimedia
	(*DvParsable)(nil),                  // 61: audit.v1.DvParsable
	(*DvUri)(nil),                       // 62: audit.v1.DvUri
	(*DvEhrUri)(nil),                    // 63: audit.v1.DvEhrUri
	(*CodePhrase)(nil),                  // 64: audit.v1.CodePhrase
	(*ReferenceRangeDvDuration)(nil),    // 65: audit.v1.ReferenceRangeDvDuration
	(*TermMapping)(nil),                 // 66: audit.v1.TermMapping
	(*Archetyped)(nil),                  // 67: audit.v1.Archetyped
	(*Link)(nil),                        // 68: audit.v1.Link
	(*FeederAudit)(nil),                 // 69: audit.v1.FeederAudit
	(*FeederAuditDetails)(nil),          // 70: audit.v1.FeederAuditDetails
	(*PartyProxy)(nil),                  // 71: audit.v1.PartyProxy
	(*PartySelf)(nil),                   // 72: audit.v1.PartySelf
	(*PartyIdentified)(nil),             // 73: audit.v1.PartyIdentified
	(*PartyRelated)(nil),                // 74: audit.v1.PartyRelated
	(*Participation)(nil),               // 75: audit.v1.Participation
	(*ItemStructure)(nil),               // 76: audit.v1.ItemStructure
	(*ItemSingle)(nil),                  // 77: audit.v1.ItemSingle
	(*ItemList)(nil),                    // 78: audit.v1.ItemList
	(*ItemTable)(nil),                   // 79: audit.v1.ItemTable
	(*ItemTree)(nil),                    // 80: audit.v1.ItemTree
	(*Cluster)(nil),                     // 81: audit.v1.Cluster
	(*Element)(nil),                     // 82: audit.v1.Element
	(*HistoryItemStructure)(nil),        // 83: audit.v1.HistoryItemStructure
	(*Event)(nil),                       // 84: audit.v1.Event
	(*PointEvent)(nil),                  // 85: audit.v1.PointEvent
	(*IntervalEvent)(nil),               // 86: audit.v1.IntervalEvent
	(*ItemTree_ItemTableItem)(nil),      // 87: audit.v1.ItemTree.ItemTableItem
	(*Cluster_ClusterItem)(nil),         // 88: audit.v1.Cluster.ClusterItem
}
var file_openehr_v1_0_0_rm_proto_depIdxs = []int32{
	19,  // 0: audit.v1.Ehr.system_id:type_name -> audit.v1.HierObjectId
	19,  // 1: audit.v1.Ehr.ehr_id:type_name -> audit.v1.HierObjectId
	25,  // 2: audit.v1.Ehr.contributions:type_name -> audit.v1.ObjectRef
	25,  // 3: audit.v1.Ehr.ehr_status:type_name -> audit.v1.ObjectRef
	25,  // 4: audit.v1.Ehr.ehr_access:type_name -> audit.v1.ObjectRef
	25,  // 5: audit.v1.Ehr.compositions:type_name -> audit.v1.ObjectRef
	25,  // 6: audit.v1.Ehr.directoyr:type_name -> audit.v1.ObjectRef
	56,  // 7: audit.v1.Ehr.time_created:type_name -> audit.v1.DvDateTime
	25,  // 8: audit.v1.Ehr.folders:type_name -> audit.v1.ObjectRef
	25,  // 9: audit.v1.Ehr.tags:type_name -> audit.v1.ObjectRef
	33,  // 10: audit.v1.Composition.name:type_name -> audit.v1.DvText
	18,  // 11: audit.v1.Composition.uid:type_name -> audit.v1.UidBasedId
	68,  // 12: audit.v1.Composition.links:type_name -> audit.v1.Link
	67,  // 13: audit.v1.Composition.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 14: audit.v1.Composition.feeder_audit:type_name -> audit.v1.FeederAudit
	64,  // 15: audit.v1.Composition.language:type_name -> audit.v1.CodePhrase
	64,  // 16: audit.v1.Composition.territory:type_name -> audit.v1.CodePhrase
	34,  // 17: audit.v1.Composition.category:type_name -> audit.v1.DvCodedText
	2,   // 18: audit.v1.Composition.context:type_name -> audit.v1.EventContext
	71,  // 19: audit.v1.Composition.composer:type_name -> audit.v1.PartyProxy
	3,   // 20: audit.v1.Composition.content:type_name -> audit.v1.ContentItem
	56,  // 21: audit.v1.EventContext.start_time:type_name -> audit.v1.DvDateTime
	56,  // 22: audit.v1.EventContext.end_time:type_name -> audit.v1.DvDateTime
	34,  // 23: audit.v1.EventContext.setting:type_name -> audit.v1.DvCodedText
	76,  // 24: audit.v1.EventContext.other_context:type_name -> audit.v1.ItemStructure
	73,  // 25: audit.v1.EventContext.party_identified:type_name -> audit.v1.PartyIdentified
	75,  // 26: audit.v1.EventContext.participations:type_name -> audit.v1.Participation
	4,   // 27: audit.v1.ContentItem.section:type_name -> audit.v1.Section
	5,   // 28: audit.v1.ContentItem.entry:type_name -> audit.v1.AdminEntry
	6,   // 29: audit.v1.ContentItem.observation:type_name -> audit.v1.Observation
	7,   // 30: audit.v1.ContentItem.evaluation:type_name -> audit.v1.Evaluation
	8,   // 31: audit.v1.ContentItem.instruction:type_name -> audit.v1.Instruction
	10,  // 32: audit.v1.ContentItem.action:type_name -> audit.v1.Action
	33,  // 33: audit.v1.Section.name:type_name -> audit.v1.DvText
	18,  // 34: audit.v1.Section.uid:type_name -> audit.v1.UidBasedId
	68,  // 35: audit.v1.Section.links:type_name -> audit.v1.Link
	67,  // 36: audit.v1.Section.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 37: audit.v1.Section.feeder_audit:type_name -> audit.v1.FeederAudit
	3,   // 38: audit.v1.Section.items:type_name -> audit.v1.ContentItem
	33,  // 39: audit.v1.AdminEntry.name:type_name -> audit.v1.DvText
	18,  // 40: audit.v1.AdminEntry.uid:type_name -> audit.v1.UidBasedId
	68,  // 41: audit.v1.AdminEntry.links:type_name -> audit.v1.Link
	67,  // 42: audit.v1.AdminEntry.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 43: audit.v1.AdminEntry.feeder_audit:type_name -> audit.v1.FeederAudit
	64,  // 44: audit.v1.AdminEntry.language:type_name -> audit.v1.CodePhrase
	64,  // 45: audit.v1.AdminEntry.encoding:type_name -> audit.v1.CodePhrase
	75,  // 46: audit.v1.AdminEntry.other_participations:type_name -> audit.v1.Participation
	25,  // 47: audit.v1.AdminEntry.workflow_id:type_name -> audit.v1.ObjectRef
	71,  // 48: audit.v1.AdminEntry.subject:type_name -> audit.v1.PartyProxy
	71,  // 49: audit.v1.AdminEntry.provider:type_name -> audit.v1.PartyProxy
	76,  // 50: audit.v1.AdminEntry.data:type_name -> audit.v1.ItemStructure
	33,  // 51: audit.v1.Observation.name:type_name -> audit.v1.DvText
	18,  // 52: audit.v1.Observation.uid:type_name -> audit.v1.UidBasedId
	68,  // 53: audit.v1.Observation.links:type_name -> audit.v1.Link
	67,  // 54: audit.v1.Observation.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 55: audit.v1.Observation.feeder_audit:type_name -> audit.v1.FeederAudit
	64,  // 56: audit.v1.Observation.language:type_name -> audit.v1.CodePhrase
	64,  // 57: audit.v1.Observation.encoding:type_name -> audit.v1.CodePhrase
	75,  // 58: audit.v1.Observation.other_participations:type_name -> audit.v1.Participation
	25,  // 59: audit.v1.Observation.workflow_id:type_name -> audit.v1.ObjectRef
	71,  // 60: audit.v1.Observation.subject:type_name -> audit.v1.PartyProxy
	71,  // 61: audit.v1.Observation.provider:type_name -> audit.v1.PartyProxy
	76,  // 62: audit.v1.Observation.protocol:type_name -> audit.v1.ItemStructure
	25,  // 63: audit.v1.Observation.guideline_id:type_name -> audit.v1.ObjectRef
	83,  // 64: audit.v1.Observation.data:type_name -> audit.v1.HistoryItemStructure
	83,  // 65: audit.v1.Observation.state:type_name -> audit.v1.HistoryItemStructure
	33,  // 66: audit.v1.Evaluation.name:type_name -> audit.v1.DvText
	18,  // 67: audit.v1.Evaluation.uid:type_name -> audit.v1.UidBasedId
	68,  // 68: audit.v1.Evaluation.links:type_name -> audit.v1.Link
	67,  // 69: audit.v1.Evaluation.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 70: audit.v1.Evaluation.feeder_audit:type_name -> audit.v1.FeederAudit
	64,  // 71: audit.v1.Evaluation.language:type_name -> audit.v1.CodePhrase
	64,  // 72: audit.v1.Evaluation.encoding:type_name -> audit.v1.CodePhrase
	75,  // 73: audit.v1.Evaluation.other_participations:type_name -> audit.v1.Participation
	25,  // 74: audit.v1.Evaluation.workflow_id:type_name -> audit.v1.ObjectRef
	71,  // 75: audit.v1.Evaluation.subject:type_name -> audit.v1.PartyProxy
	71,  // 76: audit.v1.Evaluation.provider:type_name -> audit.v1.PartyProxy
	76,  // 77: audit.v1.Evaluation.protocol:type_name -> audit.v1.ItemStructure
	25,  // 78: audit.v1.Evaluation.guideline_id:type_name -> audit.v1.ObjectRef
	76,  // 79: audit.v1.Evaluation.data:type_name -> audit.v1.ItemStructure
	33,  // 80: audit.v1.Instruction.name:type_name -> audit.v1.DvText
	18,  // 81: audit.v1.Instruction.uid:type_name -> audit.v1.UidBasedId
	68,  // 82: audit.v1.Instruction.links:type_name -> audit.v1.Link
	67,  // 83: audit.v1.Instruction.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 84: audit.v1.Instruction.feeder_audit:type_name -> audit.v1.FeederAudit
	64,  // 85: audit.v1.Instruction.language:type_name -> audit.v1.CodePhrase
	64,  // 86: audit.v1.Instruction.encoding:type_name -> audit.v1.CodePhrase
	75,  // 87: audit.v1.Instruction.other_participations:type_name -> audit.v1.Participation
	25,  // 88: audit.v1.Instruction.workflow_id:type_name -> audit.v1.ObjectRef
	71,  // 89: audit.v1.Instruction.subject:type_name -> audit.v1.PartyProxy
	71,  // 90: audit.v1.Instruction.provider:type_name -> audit.v1.PartyProxy
	76,  // 91: audit.v1.Instruction.protocol:type_name -> audit.v1.ItemStructure
	25,  // 92: audit.v1.Instruction.guideline_id:type_name -> audit.v1.ObjectRef
	33,  // 93: audit.v1.Instruction.narrative:type_name -> audit.v1.DvText
	56,  // 94: audit.v1.Instruction.expiry_time:type_name -> audit.v1.DvDateTime
	61,  // 95: audit.v1.Instruction.wf_definition:type_name -> audit.v1.DvParsable
	9,   // 96: audit.v1.Instruction.activities:type_name -> audit.v1.Activity
	33,  // 97: audit.v1.Activity.name:type_name -> audit.v1.DvText
	18,  // 98: audit.v1.Activity.uid:type_name -> audit.v1.UidBasedId
	68,  // 99: audit.v1.Activity.links:type_name -> audit.v1.Link
	67,  // 100: audit.v1.Activity.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 101: audit.v1.Activity.feeder_audit:type_name -> audit.v1.FeederAudit
	61,  // 102: audit.v1.Activity.timing:type_name -> audit.v1.DvParsable
	76,  // 103: audit.v1.Activity.description:type_name -> audit.v1.ItemStructure
	33,  // 104: audit.v1.Action.name:type_name -> audit.v1.DvText
	18,  // 105: audit.v1.Action.uid:type_name -> audit.v1.UidBasedId
	68,  // 106: audit.v1.Action.links:type_name -> audit.v1.Link
	67,  // 107: audit.v1.Action.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 108: audit.v1.Action.feeder_audit:type_name -> audit.v1.FeederAudit
	64,  // 109: audit.v1.Action.language:type_name -> audit.v1.CodePhrase
	64,  // 110: audit.v1.Action.encoding:type_name -> audit.v1.CodePhrase
	75,  // 111: audit.v1.Action.other_participations:type_name -> audit.v1.Participation
	25,  // 112: audit.v1.Action.workflow_id:type_name -> audit.v1.ObjectRef
	71,  // 113: audit.v1.Action.subject:type_name -> audit.v1.PartyProxy
	71,  // 114: audit.v1.Action.provider:type_name -> audit.v1.PartyProxy
	76,  // 115: audit.v1.Action.protocol:type_name -> audit.v1.ItemStructure
	25,  // 116: audit.v1.Action.guideline_id:type_name -> audit.v1.ObjectRef
	56,  // 117: audit.v1.Action.time:type_name -> audit.v1.DvDateTime
	12,  // 118: audit.v1.Action.ism_transition:type_name -> audit.v1.IsmTransition
	11,  // 119: audit.v1.Action.instruction_details:type_name -> audit.v1.InstructionDetails
	76,  // 120: audit.v1.Action.description:type_name -> audit.v1.ItemStructure
	27,  // 121: audit.v1.InstructionDetails.instruction_id:type_name -> audit.v1.LocatableRef
	76,  // 122: audit.v1.InstructionDetails.wf_details:type_name -> audit.v1.ItemStructure
	34,  // 123: audit.v1.IsmTransition.current_state:type_name -> audit.v1.DvCodedText
	34,  // 124: audit.v1.IsmTransition.transition:type_name -> audit.v1.DvCodedText
	34,  // 125: audit.v1.IsmTransition.careflow_step:type_name -> audit.v1.DvCodedText
	33,  // 126: audit.v1.IsmTransition.reason:type_name -> audit.v1.DvText
	19,  // 127: audit.v1.VersionedEhrAccess.uid:type_name -> audit.v1.HierObjectId
	25,  // 128: audit.v1.VersionedEhrAccess.owner_id:type_name -> audit.v1.ObjectRef
	56,  // 129: audit.v1.VersionedEhrAccess.time_created:type_name -> audit.v1.DvDateTime
	19,  // 130: audit.v1.VersionedEhrStatus.uid:type_name -> audit.v1.HierObjectId
	25,  // 131: audit.v1.VersionedEhrStatus.owner_id:type_name -> audit.v1.ObjectRef
	56,  // 132: audit.v1.VersionedEhrStatus.time_created:type_name -> audit.v1.DvDateTime
	19,  // 133: audit.v1.VersionedFolder.uid:type_name -> audit.v1.HierObjectId
	25,  // 134: audit.v1.VersionedFolder.owner_id:type_name -> audit.v1.ObjectRef
	56,  // 135: audit.v1.VersionedFolder.time_created:type_name -> audit.v1.DvDateTime
	19,  // 136: audit.v1.VersionedParty.uid:type_name -> audit.v1.HierObjectId
	25,  // 137: audit.v1.VersionedParty.owner_id:type_name -> audit.v1.ObjectRef
	56,  // 138: audit.v1.VersionedParty.time_created:type_name -> audit.v1.DvDateTime
	19,  // 139: audit.v1.ObjectId.hier_object_id:type_name -> audit.v1.HierObjectId
	20,  // 140: audit.v1.ObjectId.object_version_id:type_name -> audit.v1.ObjectVersionId
	21,  // 141: audit.v1.ObjectId.archetype_id:type_name -> audit.v1.ArchetypeId
	22,  // 142: audit.v1.ObjectId.template_id:type_name -> audit.v1.TemplateId
	23,  // 143: audit.v1.ObjectId.terminology_id:type_name -> audit.v1.TerminologyId
	24,  // 144: audit.v1.ObjectId.generic_id:type_name -> audit.v1.GenericId
	19,  // 145: audit.v1.UidBasedId.hier_object_id:type_name -> audit.v1.HierObjectId
	20,  // 146: audit.v1.UidBasedId.object_version_id:type_name -> audit.v1.ObjectVersionId
	17,  // 147: audit.v1.ObjectRef.id:type_name -> audit.v1.ObjectId
	17,  // 148: audit.v1.PartyRef.id:type_name -> audit.v1.ObjectId
	18,  // 149: audit.v1.LocatableRef.id:type_name -> audit.v1.UidBasedId
	29,  // 150: audit.v1.DataValue.dv_boolean:type_name -> audit.v1.DvBoolean
	30,  // 151: audit.v1.DataValue.dv_state:type_name -> audit.v1.DvState
	31,  // 152: audit.v1.DataValue.dv_identifier:type_name -> audit.v1.DvIdentifier
	33,  // 153: audit.v1.DataValue.dv_text:type_name -> audit.v1.DvText
	34,  // 154: audit.v1.DataValue.dv_coded_text:type_name -> audit.v1.DvCodedText
	35,  // 155: audit.v1.DataValue.dv_paragraph:type_name -> audit.v1.DvParagraph
	36,  // 156: audit.v1.DataValue.dv_interval_any:type_name -> audit.v1.DvIntervalAny
	43,  // 157: audit.v1.DataValue.dv_reference_range_any:type_name -> audit.v1.ReferenceRangeAny
	49,  // 158: audit.v1.DataValue.dv_ordinal:type_name -> audit.v1.DvOrdinal
	50,  // 159: audit.v1.DataValue.dv_scale:type_name -> audit.v1.DvScale
	51,  // 160: audit.v1.DataValue.dv_quantity:type_name -> audit.v1.DvQuantity
	52,  // 161: audit.v1.DataValue.dv_count:type_name -> audit.v1.DvCount
	53,  // 162: audit.v1.DataValue.dv_proportion:type_name -> audit.v1.DvProportion
	54,  // 163: audit.v1.DataValue.dv_date:type_name -> audit.v1.DvDate
	55,  // 164: audit.v1.DataValue.dv_time:type_name -> audit.v1.DvTime
	56,  // 165: audit.v1.DataValue.dv_date_time:type_name -> audit.v1.DvDateTime
	57,  // 166: audit.v1.DataValue.dv_duration:type_name -> audit.v1.DvDuration
	58,  // 167: audit.v1.DataValue.dv_periodic_time_specification:type_name -> audit.v1.DvPeriodicTimeSpecification
	59,  // 168: audit.v1.DataValue.dv_general_time_specification:type_name -> audit.v1.DvGeneralTimeSpecification
	60,  // 169: audit.v1.DataValue.dv_multimedia:type_name -> audit.v1.DvMultimedia
	61,  // 170: audit.v1.DataValue.dv_parsable:type_name -> audit.v1.DvParsable
	62,  // 171: audit.v1.DataValue.dv_uri:type_name -> audit.v1.DvUri
	63,  // 172: audit.v1.DataValue.dv_ehr_uri:type_name -> audit.v1.DvEhrUri
	34,  // 173: audit.v1.DvState.value:type_name -> audit.v1.DvCodedText
	33,  // 174: audit.v1.DvTextType.dv_text:type_name -> audit.v1.DvText
	34,  // 175: audit.v1.DvTextType.dv_coded_text:type_name -> audit.v1.DvCodedText
	62,  // 176: audit.v1.DvText.hyperlink:type_name -> audit.v1.DvUri
	66,  // 177: audit.v1.DvText.mappings:type_name -> audit.v1.TermMapping
	64,  // 178: audit.v1.DvText.language:type_name -> audit.v1.CodePhrase
	64,  // 179: audit.v1.DvText.encoding:type_name -> audit.v1.CodePhrase
	62,  // 180: audit.v1.DvCodedText.hyperlink:type_name -> audit.v1.DvUri
	66,  // 181: audit.v1.DvCodedText.mappings:type_name -> audit.v1.TermMapping
	64,  // 182: audit.v1.DvCodedText.language:type_name -> audit.v1.CodePhrase
	64,  // 183: audit.v1.DvCodedText.encoding:type_name -> audit.v1.CodePhrase
	64,  // 184: audit.v1.DvCodedText.defining_code:type_name -> audit.v1.CodePhrase
	33,  // 185: audit.v1.DvParagraph.items:type_name -> audit.v1.DvText
	56,  // 186: audit.v1.DvIntervalDvDateTime.lower:type_name -> audit.v1.DvDateTime
	56,  // 187: audit.v1.DvIntervalDvDateTime.upper:type_name -> audit.v1.DvDateTime
	56,  // 188: audit.v1.DvIntervalDvDuration.lower:type_name -> audit.v1.DvDateTime
	56,  // 189: audit.v1.DvIntervalDvDuration.upper:type_name -> audit.v1.DvDateTime
	51,  // 190: audit.v1.DvIntervalDvQuantity.lower:type_name -> audit.v1.DvQuantity
	51,  // 191: audit.v1.DvIntervalDvQuantity.upper:type_name -> audit.v1.DvQuantity
	52,  // 192: audit.v1.DvIntervalDvCount.lower:type_name -> audit.v1.DvCount
	52,  // 193: audit.v1.DvIntervalDvCount.upper:type_name -> audit.v1.DvCount
	53,  // 194: audit.v1.DvIntervalDvProportion.lower:type_name -> audit.v1.DvProportion
	53,  // 195: audit.v1.DvIntervalDvProportion.upper:type_name -> audit.v1.DvProportion
	32,  // 196: audit.v1.ReferenceRangeAny.meaning:type_name -> audit.v1.DvTextType
	36,  // 197: audit.v1.ReferenceRangeAny.range:type_name -> audit.v1.DvIntervalAny
	32,  // 198: audit.v1.ReferenceRangeInt64.meaning:type_name -> audit.v1.DvTextType
	37,  // 199: audit.v1.ReferenceRangeInt64.range:type_name -> audit.v1.DvIntervalInt64
	33,  // 200: audit.v1.ReferenceRangeDvDateTime.meaning_dv_text:type_name -> audit.v1.DvText
	34,  // 201: audit.v1.ReferenceRangeDvDateTime.meaning_dv_coded_text:type_name -> audit.v1.DvCodedText
	38,  // 202: audit.v1.ReferenceRangeDvDateTime.range:type_name -> audit.v1.DvIntervalDvDateTime
	33,  // 203: audit.v1.ReferenceRangeDvQuantity.meaning_dv_text:type_name -> audit.v1.DvText
	34,  // 204: audit.v1.ReferenceRangeDvQuantity.meaning_dv_coded_text:type_name -> audit.v1.DvCodedText
	40,  // 205: audit.v1.ReferenceRangeDvQuantity.range:type_name -> audit.v1.DvIntervalDvQuantity
	33,  // 206: audit.v1.ReferenceRangeDvCount.meaning_dv_text:type_name -> audit.v1.DvText
	34,  // 207: audit.v1.ReferenceRangeDvCount.meaning_dv_coded_text:type_name -> audit.v1.DvCodedText
	41,  // 208: audit.v1.ReferenceRangeDvCount.range:type_name -> audit.v1.DvIntervalDvCount
	33,  // 209: audit.v1.ReferenceRangeDvProportion.meaning_dv_text:type_name -> audit.v1.DvText
	34,  // 210: audit.v1.ReferenceRangeDvProportion.meaning_dv_coded_text:type_name -> audit.v1.DvCodedText
	42,  // 211: audit.v1.ReferenceRangeDvProportion.range:type_name -> audit.v1.DvIntervalDvProportion
	64,  // 212: audit.v1.DvOrdinal.normal_status:type_name -> audit.v1.CodePhrase
	37,  // 213: audit.v1.DvOrdinal.normal_range:type_name -> audit.v1.DvIntervalInt64
	44,  // 214: audit.v1.DvOrdinal.other_reference_ranges:type_name -> audit.v1.ReferenceRangeInt64
	34,  // 215: audit.v1.DvOrdinal.symbol:type_name -> audit.v1.DvCodedText
	64,  // 216: audit.v1.DvScale.normal_status:type_name -> audit.v1.CodePhrase
	37,  // 217: audit.v1.DvScale.normal_range:type_name -> audit.v1.DvIntervalInt64
	44,  // 218: audit.v1.DvScale.other_reference_ranges:type_name -> audit.v1.ReferenceRangeInt64
	34,  // 219: audit.v1.DvScale.symbol:type_name -> audit.v1.DvCodedText
	64,  // 220: audit.v1.DvQuantity.normal_status:type_name -> audit.v1.CodePhrase
	40,  // 221: audit.v1.DvQuantity.normal_range:type_name -> audit.v1.DvIntervalDvQuantity
	46,  // 222: audit.v1.DvQuantity.other_reference_ranges:type_name -> audit.v1.ReferenceRangeDvQuantity
	64,  // 223: audit.v1.DvCount.normal_status:type_name -> audit.v1.CodePhrase
	41,  // 224: audit.v1.DvCount.normal_range:type_name -> audit.v1.DvIntervalDvCount
	47,  // 225: audit.v1.DvCount.other_reference_ranges:type_name -> audit.v1.ReferenceRangeDvCount
	64,  // 226: audit.v1.DvProportion.normal_status:type_name -> audit.v1.CodePhrase
	42,  // 227: audit.v1.DvProportion.normal_range:type_name -> audit.v1.DvIntervalDvProportion
	48,  // 228: audit.v1.DvProportion.other_reference_ranges:type_name -> audit.v1.ReferenceRangeDvProportion
	64,  // 229: audit.v1.DvDate.normal_status:type_name -> audit.v1.CodePhrase
	42,  // 230: audit.v1.DvDate.normal_range:type_name -> audit.v1.DvIntervalDvProportion
	48,  // 231: audit.v1.DvDate.other_reference_ranges:type_name -> audit.v1.ReferenceRangeDvProportion
	57,  // 232: audit.v1.DvDate.accuracy:type_name -> audit.v1.DvDuration
	64,  // 233: audit.v1.DvTime.normal_status:type_name -> audit.v1.CodePhrase
	42,  // 234: audit.v1.DvTime.normal_range:type_name -> audit.v1.DvIntervalDvProportion
	48,  // 235: audit.v1.DvTime.other_reference_ranges:type_name -> audit.v1.ReferenceRangeDvProportion
	57,  // 236: audit.v1.DvTime.accuracy:type_name -> audit.v1.DvDuration
	64,  // 237: audit.v1.DvDateTime.normal_status:type_name -> audit.v1.CodePhrase
	42,  // 238: audit.v1.DvDateTime.normal_range:type_name -> audit.v1.DvIntervalDvProportion
	48,  // 239: audit.v1.DvDateTime.other_reference_ranges:type_name -> audit.v1.ReferenceRangeDvProportion
	57,  // 240: audit.v1.DvDateTime.accuracy:type_name -> audit.v1.DvDuration
	64,  // 241: audit.v1.DvDuration.normal_status:type_name -> audit.v1.CodePhrase
	38,  // 242: audit.v1.DvDuration.normal_range:type_name -> audit.v1.DvIntervalDvDateTime
	45,  // 243: audit.v1.DvDuration.other_reference_ranges:type_name -> audit.v1.ReferenceRangeDvDateTime
	61,  // 244: audit.v1.DvPeriodicTimeSpecification.value:type_name -> audit.v1.DvParsable
	61,  // 245: audit.v1.DvGeneralTimeSpecification.value:type_name -> audit.v1.DvParsable
	64,  // 246: audit.v1.DvMultimedia.charset:type_name -> audit.v1.CodePhrase
	64,  // 247: audit.v1.DvMultimedia.language:type_name -> audit.v1.CodePhrase
	62,  // 248: audit.v1.DvMultimedia.uri:type_name -> audit.v1.DvUri
	64,  // 249: audit.v1.DvMultimedia.media_type:type_name -> audit.v1.CodePhrase
	64,  // 250: audit.v1.DvMultimedia.compression_algorithm:type_name -> audit.v1.CodePhrase
	60,  // 251: audit.v1.DvMultimedia.thumbnail:type_name -> audit.v1.DvMultimedia
	64,  // 252: audit.v1.DvParsable.charset:type_name -> audit.v1.CodePhrase
	64,  // 253: audit.v1.DvParsable.language:type_name -> audit.v1.CodePhrase
	23,  // 254: audit.v1.CodePhrase.terminology_id:type_name -> audit.v1.TerminologyId
	33,  // 255: audit.v1.ReferenceRangeDvDuration.dv_text:type_name -> audit.v1.DvText
	34,  // 256: audit.v1.ReferenceRangeDvDuration.dv_coded_text:type_name -> audit.v1.DvCodedText
	39,  // 257: audit.v1.ReferenceRangeDvDuration.range:type_name -> audit.v1.DvIntervalDvDuration
	34,  // 258: audit.v1.TermMapping.purpose:type_name -> audit.v1.DvCodedText
	64,  // 259: audit.v1.TermMapping.target:type_name -> audit.v1.CodePhrase
	21,  // 260: audit.v1.Archetyped.archetype_id:type_name -> audit.v1.ArchetypeId
	22,  // 261: audit.v1.Archetyped.template_id:type_name -> audit.v1.TemplateId
	33,  // 262: audit.v1.Link.meaning:type_name -> audit.v1.DvText
	33,  // 263: audit.v1.Link.type:type_name -> audit.v1.DvText
	63,  // 264: audit.v1.Link.target:type_name -> audit.v1.DvEhrUri
	31,  // 265: audit.v1.FeederAudit.originating_system_item_ids:type_name -> audit.v1.DvIdentifier
	31,  // 266: audit.v1.FeederAudit.feeder_system_item_ids:type_name -> audit.v1.DvIdentifier
	60,  // 267: audit.v1.FeederAudit.dv_multimedia:type_name -> audit.v1.DvMultimedia
	61,  // 268: audit.v1.FeederAudit.dv_parsable:type_name -> audit.v1.DvParsable
	70,  // 269: audit.v1.FeederAudit.originating_system_audit:type_name -> audit.v1.FeederAuditDetails
	70,  // 270: audit.v1.FeederAudit.feeder_system_audit:type_name -> audit.v1.FeederAuditDetails
	73,  // 271: audit.v1.FeederAuditDetails.location:type_name -> audit.v1.PartyIdentified
	71,  // 272: audit.v1.FeederAuditDetails.subject:type_name -> audit.v1.PartyProxy
	71,  // 273: audit.v1.FeederAuditDetails.provider:type_name -> audit.v1.PartyProxy
	56,  // 274: audit.v1.FeederAuditDetails.time:type_name -> audit.v1.DvDateTime
	76,  // 275: audit.v1.FeederAuditDetails.other_details:type_name -> audit.v1.ItemStructure
	72,  // 276: audit.v1.PartyProxy.party_self:type_name -> audit.v1.PartySelf
	73,  // 277: audit.v1.PartyProxy.party_identified:type_name -> audit.v1.PartyIdentified
	74,  // 278: audit.v1.PartyProxy.party_related:type_name -> audit.v1.PartyRelated
	26,  // 279: audit.v1.PartySelf.external_ref:type_name -> audit.v1.PartyRef
	26,  // 280: audit.v1.PartyIdentified.external_ref:type_name -> audit.v1.PartyRef
	31,  // 281: audit.v1.PartyIdentified.identifiers:type_name -> audit.v1.DvIdentifier
	26,  // 282: audit.v1.PartyRelated.external_ref:type_name -> audit.v1.PartyRef
	31,  // 283: audit.v1.PartyRelated.identifiers:type_name -> audit.v1.DvIdentifier
	34,  // 284: audit.v1.PartyRelated.relationship:type_name -> audit.v1.DvCodedText
	33,  // 285: audit.v1.Participation.function:type_name -> audit.v1.DvText
	34,  // 286: audit.v1.Participation.mode:type_name -> audit.v1.DvCodedText
	71,  // 287: audit.v1.Participation.performer:type_name -> audit.v1.PartyProxy
	38,  // 288: audit.v1.Participation.time:type_name -> audit.v1.DvIntervalDvDateTime
	77,  // 289: audit.v1.ItemStructure.item_single:type_name -> audit.v1.ItemSingle
	78,  // 290: audit.v1.ItemStructure.item_list:type_name -> audit.v1.ItemList
	79,  // 291: audit.v1.ItemStructure.item_table:type_name -> audit.v1.ItemTable
	80,  // 292: audit.v1.ItemStructure.item_tree:type_name -> audit.v1.ItemTree
	33,  // 293: audit.v1.ItemSingle.name:type_name -> audit.v1.DvText
	18,  // 294: audit.v1.ItemSingle.uid:type_name -> audit.v1.UidBasedId
	68,  // 295: audit.v1.ItemSingle.links:type_name -> audit.v1.Link
	67,  // 296: audit.v1.ItemSingle.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 297: audit.v1.ItemSingle.feeder_audit:type_name -> audit.v1.FeederAudit
	82,  // 298: audit.v1.ItemSingle.item:type_name -> audit.v1.Element
	33,  // 299: audit.v1.ItemList.name:type_name -> audit.v1.DvText
	18,  // 300: audit.v1.ItemList.uid:type_name -> audit.v1.UidBasedId
	68,  // 301: audit.v1.ItemList.links:type_name -> audit.v1.Link
	67,  // 302: audit.v1.ItemList.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 303: audit.v1.ItemList.feeder_audit:type_name -> audit.v1.FeederAudit
	82,  // 304: audit.v1.ItemList.items:type_name -> audit.v1.Element
	33,  // 305: audit.v1.ItemTable.name:type_name -> audit.v1.DvText
	18,  // 306: audit.v1.ItemTable.uid:type_name -> audit.v1.UidBasedId
	68,  // 307: audit.v1.ItemTable.links:type_name -> audit.v1.Link
	67,  // 308: audit.v1.ItemTable.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 309: audit.v1.ItemTable.feeder_audit:type_name -> audit.v1.FeederAudit
	81,  // 310: audit.v1.ItemTable.rows:type_name -> audit.v1.Cluster
	33,  // 311: audit.v1.ItemTree.name:type_name -> audit.v1.DvText
	18,  // 312: audit.v1.ItemTree.uid:type_name -> audit.v1.UidBasedId
	68,  // 313: audit.v1.ItemTree.links:type_name -> audit.v1.Link
	67,  // 314: audit.v1.ItemTree.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 315: audit.v1.ItemTree.feeder_audit:type_name -> audit.v1.FeederAudit
	87,  // 316: audit.v1.ItemTree.items:type_name -> audit.v1.ItemTree.ItemTableItem
	33,  // 317: audit.v1.Cluster.name:type_name -> audit.v1.DvText
	18,  // 318: audit.v1.Cluster.uid:type_name -> audit.v1.UidBasedId
	68,  // 319: audit.v1.Cluster.links:type_name -> audit.v1.Link
	67,  // 320: audit.v1.Cluster.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 321: audit.v1.Cluster.feeder_audit:type_name -> audit.v1.FeederAudit
	88,  // 322: audit.v1.Cluster.items:type_name -> audit.v1.Cluster.ClusterItem
	33,  // 323: audit.v1.Element.name:type_name -> audit.v1.DvText
	18,  // 324: audit.v1.Element.uid:type_name -> audit.v1.UidBasedId
	68,  // 325: audit.v1.Element.links:type_name -> audit.v1.Link
	67,  // 326: audit.v1.Element.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 327: audit.v1.Element.feeder_audit:type_name -> audit.v1.FeederAudit
	34,  // 328: audit.v1.Element.null_flavour:type_name -> audit.v1.DvCodedText
	28,  // 329: audit.v1.Element.value:type_name -> audit.v1.DataValue
	33,  // 330: audit.v1.Element.null_reason:type_name -> audit.v1.DvText
	33,  // 331: audit.v1.HistoryItemStructure.name:type_name -> audit.v1.DvText
	18,  // 332: audit.v1.HistoryItemStructure.uid:type_name -> audit.v1.UidBasedId
	68,  // 333: audit.v1.HistoryItemStructure.links:type_name -> audit.v1.Link
	67,  // 334: audit.v1.HistoryItemStructure.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 335: audit.v1.HistoryItemStructure.feeder_audit:type_name -> audit.v1.FeederAudit
	56,  // 336: audit.v1.HistoryItemStructure.origin:type_name -> audit.v1.DvDateTime
	57,  // 337: audit.v1.HistoryItemStructure.period:type_name -> audit.v1.DvDuration
	57,  // 338: audit.v1.HistoryItemStructure.duration:type_name -> audit.v1.DvDuration
	76,  // 339: audit.v1.HistoryItemStructure.summary:type_name -> audit.v1.ItemStructure
	84,  // 340: audit.v1.HistoryItemStructure.events:type_name -> audit.v1.Event
	85,  // 341: audit.v1.Event.point_event:type_name -> audit.v1.PointEvent
	86,  // 342: audit.v1.Event.interval_event:type_name -> audit.v1.IntervalEvent
	33,  // 343: audit.v1.PointEvent.name:type_name -> audit.v1.DvText
	18,  // 344: audit.v1.PointEvent.uid:type_name -> audit.v1.UidBasedId
	68,  // 345: audit.v1.PointEvent.links:type_name -> audit.v1.Link
	67,  // 346: audit.v1.PointEvent.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 347: audit.v1.PointEvent.feeder_audit:type_name -> audit.v1.FeederAudit
	56,  // 348: audit.v1.PointEvent.time:type_name -> audit.v1.DvDateTime
	76,  // 349: audit.v1.PointEvent.state:type_name -> audit.v1.ItemStructure
	33,  // 350: audit.v1.IntervalEvent.name:type_name -> audit.v1.DvText
	18,  // 351: audit.v1.IntervalEvent.uid:type_name -> audit.v1.UidBasedId
	68,  // 352: audit.v1.IntervalEvent.links:type_name -> audit.v1.Link
	67,  // 353: audit.v1.IntervalEvent.archetype_details:type_name -> audit.v1.Archetyped
	69,  // 354: audit.v1.IntervalEvent.feeder_audit:type_name -> audit.v1.FeederAudit
	56,  // 355: audit.v1.IntervalEvent.time:type_name -> audit.v1.DvDateTime
	76,  // 356: audit.v1.IntervalEvent.state:type_name -> audit.v1.ItemStructure
	57,  // 357: audit.v1.IntervalEvent.width:type_name -> audit.v1.DvDuration
	34,  // 358: audit.v1.IntervalEvent.math_function:type_name -> audit.v1.DvCodedText
	81,  // 359: audit.v1.ItemTree.ItemTableItem.cluster:type_name -> audit.v1.Cluster
	82,  // 360: audit.v1.ItemTree.ItemTableItem.element:type_name -> audit.v1.Element
	81,  // 361: audit.v1.Cluster.ClusterItem.cluster:type_name -> audit.v1.Cluster
	82,  // 362: audit.v1.Cluster.ClusterItem.element:type_name -> audit.v1.Element
	363, // [363:363] is the sub-list for method output_type
	363, // [363:363] is the sub-list for method input_type
	363, // [363:363] is the sub-list for extension type_name
	363, // [363:363] is the sub-list for extension extendee
	0,   // [0:363] is the sub-list for field type_name
}

func init() { file_openehr_v1_0_0_rm_proto_init() }
func file_openehr_v1_0_0_rm_proto_init() {
	if File_openehr_v1_0_0_rm_proto != nil {
		return
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[0].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[1].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[2].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[3].OneofWrappers = []any{
		(*ContentItem_Section)(nil),
		(*ContentItem_Entry)(nil),
		(*ContentItem_Observation)(nil),
		(*ContentItem_Evaluation)(nil),
		(*ContentItem_Instruction)(nil),
		(*ContentItem_Action)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[4].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[5].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[6].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[7].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[8].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[9].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[10].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[11].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[12].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[17].OneofWrappers = []any{
		(*ObjectId_HierObjectId)(nil),
		(*ObjectId_ObjectVersionId)(nil),
		(*ObjectId_ArchetypeId)(nil),
		(*ObjectId_TemplateId)(nil),
		(*ObjectId_TerminologyId)(nil),
		(*ObjectId_GenericId)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[18].OneofWrappers = []any{
		(*UidBasedId_HierObjectId)(nil),
		(*UidBasedId_ObjectVersionId)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[27].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[28].OneofWrappers = []any{
		(*DataValue_DvBoolean)(nil),
		(*DataValue_DvState)(nil),
		(*DataValue_DvIdentifier)(nil),
		(*DataValue_DvText)(nil),
		(*DataValue_DvCodedText)(nil),
		(*DataValue_DvParagraph)(nil),
		(*DataValue_DvIntervalAny)(nil),
		(*DataValue_DvReferenceRangeAny)(nil),
		(*DataValue_DvOrdinal)(nil),
		(*DataValue_DvScale)(nil),
		(*DataValue_DvQuantity)(nil),
		(*DataValue_DvCount)(nil),
		(*DataValue_DvProportion)(nil),
		(*DataValue_DvDate)(nil),
		(*DataValue_DvTime)(nil),
		(*DataValue_DvDateTime)(nil),
		(*DataValue_DvDuration)(nil),
		(*DataValue_DvPeriodicTimeSpecification)(nil),
		(*DataValue_DvGeneralTimeSpecification)(nil),
		(*DataValue_DvMultimedia)(nil),
		(*DataValue_DvParsable)(nil),
		(*DataValue_DvUri)(nil),
		(*DataValue_DvEhrUri)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[31].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[32].OneofWrappers = []any{
		(*DvTextType_DvText)(nil),
		(*DvTextType_DvCodedText)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[33].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[34].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[45].OneofWrappers = []any{
		(*ReferenceRangeDvDateTime_MeaningDvText)(nil),
		(*ReferenceRangeDvDateTime_MeaningDvCodedText)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[46].OneofWrappers = []any{
		(*ReferenceRangeDvQuantity_MeaningDvText)(nil),
		(*ReferenceRangeDvQuantity_MeaningDvCodedText)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[47].OneofWrappers = []any{
		(*ReferenceRangeDvCount_MeaningDvText)(nil),
		(*ReferenceRangeDvCount_MeaningDvCodedText)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[48].OneofWrappers = []any{
		(*ReferenceRangeDvProportion_MeaningDvText)(nil),
		(*ReferenceRangeDvProportion_MeaningDvCodedText)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[49].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[50].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[51].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[52].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[53].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[54].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[55].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[56].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[57].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[60].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[61].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[64].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[65].OneofWrappers = []any{
		(*ReferenceRangeDvDuration_DvText)(nil),
		(*ReferenceRangeDvDuration_DvCodedText)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[66].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[67].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[69].OneofWrappers = []any{
		(*FeederAudit_DvMultimedia)(nil),
		(*FeederAudit_DvParsable)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[70].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[71].OneofWrappers = []any{
		(*PartyProxy_PartySelf)(nil),
		(*PartyProxy_PartyIdentified)(nil),
		(*PartyProxy_PartyRelated)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[72].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[73].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[74].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[75].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[76].OneofWrappers = []any{
		(*ItemStructure_ItemSingle)(nil),
		(*ItemStructure_ItemList)(nil),
		(*ItemStructure_ItemTable)(nil),
		(*ItemStructure_ItemTree)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[77].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[78].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[79].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[80].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[81].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[82].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[83].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[84].OneofWrappers = []any{
		(*Event_PointEvent)(nil),
		(*Event_IntervalEvent)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[85].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[86].OneofWrappers = []any{}
	file_openehr_v1_0_0_rm_proto_msgTypes[87].OneofWrappers = []any{
		(*ItemTree_ItemTableItem_Cluster)(nil),
		(*ItemTree_ItemTableItem_Element)(nil),
	}
	file_openehr_v1_0_0_rm_proto_msgTypes[88].OneofWrappers = []any{
		(*Cluster_ClusterItem_Cluster)(nil),
		(*Cluster_ClusterItem_Element)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_openehr_v1_0_0_rm_proto_rawDesc), len(file_openehr_v1_0_0_rm_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   89,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_openehr_v1_0_0_rm_proto_goTypes,
		DependencyIndexes: file_openehr_v1_0_0_rm_proto_depIdxs,
		MessageInfos:      file_openehr_v1_0_0_rm_proto_msgTypes,
	}.Build()
	File_openehr_v1_0_0_rm_proto = out.File
	file_openehr_v1_0_0_rm_proto_goTypes = nil
	file_openehr_v1_0_0_rm_proto_depIdxs = nil
}
