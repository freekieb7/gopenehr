syntax = "proto3";

package example.proto.openehr.v1;

option go_package = "example.com/protobuf/gen/proto/openehr/v1.1.0";

// +------------------------------------------------------------+
// | EHR                                                        |
// +------------------------------------------------------------+

// The EHR object is the root object and access point of an EHR for a subject of care.
message Ehr {
    // The identifier of the logical EHR management system in which this EHR was created.
    HierObjectId system_id = 1;
    // The unique identifier of this EHR.
    HierObjectId ehr_id = 2;
    // List of contributions causing changes to this EHR. Each contribution contains a list of versions, which may include references to any number of VERSION instances, i.e. items of type VERSIONED_COMPOSITION and VERSIONED_FOLDER.
    repeated ObjectRef contributions = 3;
    // Reference to EHR_STATUS object for this EHR.
    ObjectRef ehr_status = 4;
    // Reference to EHR_ACCESS object for this EHR.
    ObjectRef ehr_access = 5;
    // Master list of all Versioned Composition references in this EHR.
    repeated ObjectRef compositions = 6;
    // Optional directory structure for this EHR. If present, this is a reference to the first member of folders.
    optional ObjectRef directory = 7;
    // Time of creation of the EHR.
    DvDateTime time_created = 8;
    // Optional additional Folder structures for this EHR. If set, the directory attribute refers to the first member.
    repeated ObjectRef folders = 9;
}

// Version container for EHR_ACCESS instance.
message VersionedEhrAccess {
    // Unique identifier of this version container in the form of a UID with no extension. 
    // This id will be the same in all instances of the same container in a distributed environment, 
    // meaning that it can be understood as the uid of the virtual version tree.
    HierObjectId uid = 1;
    // Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
    ObjectRef owner_id = 2;
    // Time of initial creation of this versioned object.
    DvDateTime time_created = 3;
}

// EHR-wide access control object. All access decisions to data in the EHR must be made in accordance with the policies and rules in this object.
message EhrAccess {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Access control settings for the EHR. Instance is a subtype of the type ACCESS_CONTROL_SETTINGS, allowing for the use of different access control schemes.
    // BAD specification, ACCESS_CONTROL_SETTINGS is an abstract and no inheritors are defined in openEHR specs.
    // optional AccessControlSettings access_control_settings = 7;
}

// A versioned EhrStatus object
message VersionedEhrStatus {
    // Unique identifier of this version container in the form of a UID with no extension. 
    // This id will be the same in all instances of the same container in a distributed environment, 
    // meaning that it can be understood as the uid of the virtual version tree.
    HierObjectId uid = 1;
    // Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
    ObjectRef owner_id = 2;
    // Time of initial creation of this versioned object.
    DvDateTime time_created = 3;
}

// Version container for EHR_STATUS instance.
message EhrStatus {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // The subject of this EHR. The external_ref attribute can be used to contain a direct reference to the subject in a demographic or identity service. Alternatively, the association between patients and their records may be done elsewhere for security reasons.
    PartySelf subject = 8;
    // True if this EHR should be included in population queries, i.e. if this EHR is considered active in the population.
    bool is_queryable = 9;
    // True if the EHR, other than the EHR_STATUS object, is allowed to be written to. The EHR_STATUS object itself can always be written to.
    bool is_modifiable = 10;
    // Any other details of the EHR summary object, in the form of an archetyped ITEM_STRUCTURE.
    optional ItemStructure other_details = 11;
}

// Version-controlled composition abstraction, defined by inheriting VERSIONED_OBJECT<COMPOSITION>.
message VersionedComposition {
    // Unique identifier of this version container in the form of a UID with no extension. 
    // This id will be the same in all instances of the same container in a distributed environment, 
    // meaning that it can be understood as the uid of the virtual version tree.
    HierObjectId uid = 1;
    // Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
    ObjectRef owner_id = 2;
    // Time of initial creation of this versioned object.
    DvDateTime time_created = 3;
}

// Content of one version in a VERSIONED_COMPOSITION. A Composition is considered the unit of modification of the record, the unit of transmission in record Extracts, and the unit of attestation by authorising clinicians. In this latter sense, it may be considered equivalent to a signed document.
message Composition {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Mandatory indicator of the localised language in which this Composition is written. 
    // Coded from openEHR Code Set languages. 
    // The language of an Entry if different from the Composition is indicated in ENTRY.language.
    CodePhrase language = 7;
    // Name of territory in which this Composition was written. 
    // Coded from openEHR countries code set, which is an expression of the ISO 3166 standard.
    CodePhrase territory = 8;
    // Temporal category of this Composition, i.e.
    //
    // - 431|persistent| - of potential life-time validity;
    // - 451|episodic| - valid over the life of a care episode;
    // - 433|event| - valid at the time of recording (long-term validity requires subsequent clinical assessment).
    //
    // or any other code defined in the openEHR terminology group 'category'.
    DvCodedText category = 9;
    // The clinical session context of this Composition, i.e. the contextual attributes of the clinical session.
    optional EventContext context = 10;
    // The person primarily responsible for the content of the Composition (but not necessarily its committal into the EHR system). 
    // This is the identifier which should appear on the screen. 
    // It may or may not be the person who entered the data. 
    // When it is the patient, the special self instance of PARTY_PROXY will be used.
    PartyProxy composer = 11;
    // The content of this Composition.
    repeated ContentItem content = 12;
}

// Documents the context information of a healthcare event involving the subject of care and the health system. The context information recorded here are independent of the attributes recorded in the version audit, which document the system interaction context, i.e. the context of a user interacting with the health record system. Healthcare events include patient contacts, and any other business activity, such as pathology investigations which take place on behalf of the patient.
message EventContext {
    // Start time of the clinical session or other kind of event during which a provider performs a service of any kind for the patient.
    DvDateTime start_time = 1;
    // Optional end time of the clinical session.
    optional DvDateTime end_time = 2;
    // The actual location where the session occurred, e.g. 'microbiology lab 2', 'home', 'ward A3' and so on.
    optional string location = 3;
    // The setting in which the clinical session took place. Coded using the openEHR Terminology, setting group.
    DvCodedText setting = 4;
    // Other optional context which will be archetyped.
    optional ItemStructure other_context = 5;
    // The health care facility under whose care the event took place. This is the most specific workgroup or delivery unit within a care delivery enterprise that has an official identifier in the health system, and can be used to ensure medico-legal accountability.
    optional PartyIdentified health_care_facility = 6;
    // Parties involved in the healthcare event. These would normally include the physician(s) and often the patient (but not the latter if the clinical session is a pathology test for example).
    repeated Participation participations = 7; 
}   

// Abstract ancestor of all concrete content types.
message ContentItem {
    oneof item {
        Section section = 1;
        AdminEntry entry = 2;
        Observation observation = 3;
        Evaluation evaluation = 4;
        Instruction instruction = 5;
        Action action = 6;
    }
}

// Represents a heading in a heading structure, or section tree. Created according to archetyped structures for typical headings such as SOAP, physical examination, but also pathology result heading structures. Should not be used instead of ENTRY hierarchical structures.
message Section {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Ordered list of content items under this section, which may include:
    // 
    // - more SECTIONs;
    // - ENTRYs.
    repeated ContentItem items = 7;
}

// Entry subtype for administrative information, i.e. information about setting up the clinical process, but not itself clinically relevant. Archetypes will define contained information.
// 
// Used for administrative details of admission, episode, ward location, discharge, appointment (if not stored in a practice management or appointments system).
// 
// Not to be used for any clinically significant information.
message AdminEntry {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
    CodePhrase language = 7;
    // Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
    CodePhrase encoding = 8;
    // Other participations at ENTRY level.
    repeated Participation other_participations = 9;
    // Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
    optional ObjectRef workflow_id = 10;
    // Id of human subject of this ENTRY, e.g.:
    // 
    // - organ donor
    // - foetus
    // - a family member
    // - another clinically relevant person.
    PartyProxy subject = 11;
    // Optional identification of provider of the information in this ENTRY, which might be:
    //
    // - the patient
    // - a patient agent, e.g. parent, guardian
    // - the clinician
    // - a device or software
    //
    // Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
    optional PartyProxy provider = 12;
    // Content of the Admin Entry. The data of the Entry; modelled in archetypes.
    ItemStructure data = 13;
}

// Entry subtype for all clinical data in the past or present, i.e. which (by the time it is recorded) has already occurred. OBSERVATION data is expressed using the class HISTORY<T>, which guarantees that it is situated in time. OBSERVATION is used for all notionally objective (i.e. measured in some way) observations of phenomena, and patient-reported phenomena, e.g. pain.
// 
// Not to be used for recording opinion or future statements of any kind, including instructions, intentions, plans etc.
message Observation {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
    CodePhrase language = 7;
    // Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
    CodePhrase encoding = 8;
    // Other participations at ENTRY level.
    repeated Participation other_participations = 9;
    // Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
    optional ObjectRef workflow_id = 10;
    // Id of human subject of this ENTRY, e.g.:
    // 
    // - organ donor
    // - foetus
    // - a family member
    // - another clinically relevant person.
    PartyProxy subject = 11;
    // Optional identification of provider of the information in this ENTRY, which might be:
    //
    // - the patient
    // - a patient agent, e.g. parent, guardian
    // - the clinician
    // - a device or software
    //
    // Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
    optional PartyProxy provider = 12;
    // Description of the method (i.e. how) the information in this entry was arrived at. For OBSERVATIONs, this is a description of the method or instrument used. For EVALUATIONs, how the evaluation was arrived at. For INSTRUCTIONs, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process.
    optional ItemStructure protocol = 13;
    // Optional external identifier of guideline creating this Entry if relevant.
    optional ObjectRef guideline_id = 14;
    // The data of this observation, in the form of a history of values which may be of any complexity.
    HistoryItemStructure data = 15;
    // Optional recording of the state of subject of this observation during the observation process, in the form of a separate history of values which may be of any complexity. State may also be recorded within the History of the data attribute.
    optional HistoryItemStructure state = 16;
}

// Entry type for evaluation statements. Used for all kinds of statements which evaluate other information, such as interpretations of observations, diagnoses, differential diagnoses, hypotheses, risk assessments, goals and plans.
// 
// Should not be used for actionable statements such as medication orders - these are represented using the INSTRUCTION type.
message Evaluation {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
    CodePhrase language = 7;
    // Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
    CodePhrase encoding = 8;
    // Other participations at ENTRY level.
    repeated Participation other_participations = 9;
    // Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
    optional ObjectRef workflow_id = 10;
    // Id of human subject of this ENTRY, e.g.:
    // 
    // - organ donor
    // - foetus
    // - a family member
    // - another clinically relevant person.
    PartyProxy subject = 11;
    // Optional identification of provider of the information in this ENTRY, which might be:
    //
    // - the patient
    // - a patient agent, e.g. parent, guardian
    // - the clinician
    // - a device or software
    //
    // Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
    optional PartyProxy provider = 12;
    // Description of the method (i.e. how) the information in this entry was arrived at. For OBSERVATIONs, this is a description of the method or instrument used. For EVALUATIONs, how the evaluation was arrived at. For INSTRUCTIONs, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process.
    optional ItemStructure protocol = 13;
    // Optional external identifier of guideline creating this Entry if relevant.
    optional ObjectRef guideline_id = 14;
    // The data of this evaluation, in the form of a spatial data structure.
    ItemStructure data = 15;
}

// Used to specify actions in the future. Enables simple and complex specifications to be expressed, including in a fully-computable workflow form. Used for any actionable statement such as medication and therapeutic orders, monitoring, recall and review. Enough details must be provided for the specification to be directly executed by an actor, either human or machine.
// 
// Not to be used for plan items which are only specified in general terms.
message Instruction {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
    CodePhrase language = 7;
    // Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
    CodePhrase encoding = 8;
    // Other participations at ENTRY level.
    repeated Participation other_participations = 9;
    // Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
    optional ObjectRef workflow_id = 10;
    // Id of human subject of this ENTRY, e.g.:
    // 
    // - organ donor
    // - foetus
    // - a family member
    // - another clinically relevant person.
    PartyProxy subject = 11;
    // Optional identification of provider of the information in this ENTRY, which might be:
    //
    // - the patient
    // - a patient agent, e.g. parent, guardian
    // - the clinician
    // - a device or software
    //
    // Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
    optional PartyProxy provider = 12;
    // Description of the method (i.e. how) the information in this entry was arrived at. For OBSERVATIONs, this is a description of the method or instrument used. For EVALUATIONs, how the evaluation was arrived at. For INSTRUCTIONs, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process.
    optional ItemStructure protocol = 13;
    // Optional external identifier of guideline creating this Entry if relevant.
    optional ObjectRef guideline_id = 14;
    // Mandatory human-readable version of what the Instruction is about.
    DvText narrative = 15;
    // Optional expiry date/time to assist determination of when an Instruction can be assumed to have expired. This helps prevent false listing of Instructions as Active when they clearly must have been terminated in some way or other.
    optional DvDateTime expiry_time = 16;
    // Optional workflow engine executable expression of the Instruction.
    optional DvParsable wf_definition = 17;
    // List of all activities in Instruction.
    repeated Activity activities = 18;
}

// Defines a single activity within an Instruction, such as a medication administration.
message Activity {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Timing of the activity, in the form of a parsable string. If used, the preferred syntax is ISO8601 'R' format, but other formats may be used including HL7 GTS.
    //
    // May be omitted if:
    // - timing is represented structurally in the description attribute (e.g. via archetyped elements), or
    // - unavailable, e.g. imported legacy data; in such cases, the INSTRUCTION.narrative should carry text that indicates the timing of its activities.
    optional DvParsable timing = 7;
    // Perl-compliant regular expression pattern, enclosed in '//' delimiters, indicating the valid identifiers of archetypes for Actions corresponding to this Activity specification.
    // 
    // Defaults to /.*/, meaning any archetype.
    string action_archetype_id = 8;
    // Description of the activity, in the form of an archetyped structure.
    ItemStructure description = 9;
}

// Used to record a clinical action that has been performed, which may have been ad hoc, or due to the execution of an Activity in an Instruction workflow. Every Action corresponds to a careflow step of some kind or another.
message Action {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Mandatory indicator of the localised language in which this Entry is written. Coded from openEHR Code Set languages .
    CodePhrase language = 7;
    // Name of character set in which text values in this Entry are encoded. Coded from openEHR Code Set character sets.
    CodePhrase encoding = 8;
    // Other participations at ENTRY level.
    repeated Participation other_participations = 9;
    // Identifier of externally held workflow engine data for this workflow execution, for this subject of care.
    optional ObjectRef workflow_id = 10;
    // Id of human subject of this ENTRY, e.g.:
    // 
    // - organ donor
    // - foetus
    // - a family member
    // - another clinically relevant person.
    PartyProxy subject = 11;
    // Optional identification of provider of the information in this ENTRY, which might be:
    //
    // - the patient
    // - a patient agent, e.g. parent, guardian
    // - the clinician
    // - a device or software
    //
    // Generally only used when the recorder needs to make it explicit. Otherwise, Composition composer and other participants are assumed.
    optional PartyProxy provider = 12;
    // Description of the method (i.e. how) the information in this entry was arrived at. For OBSERVATIONs, this is a description of the method or instrument used. For EVALUATIONs, how the evaluation was arrived at. For INSTRUCTIONs, how to execute the Instruction. This may take the form of references to guidelines, including manually followed and executable; knowledge references such as a paper in Medline; clinical reasons within a larger care process.
    optional ItemStructure protocol = 13;
    // Optional external identifier of guideline creating this Entry if relevant.
    optional ObjectRef guideline_id = 14;
    // Point in time at which this action completed.
    DvDateTime time = 15;
    // Details of transition in the Instruction state machine caused by this Action.
    IsmTransition ism_transition = 16;
    // Details of the Instruction that caused this Action to be performed, if there was one.
    optional InstructionDetails instruction_details = 17;
    // Description of the action that has been performed, in the form of an archetyped structure.
    ItemStructure description = 18;
}

// Used to record details of the Instruction causing an Action.
message InstructionDetails {
    // Reference to causing Instruction.
    LocatableRef instruction_id = 1;
    // Identifier of Activity within Instruction, in the form of its archetype path.
    string activity_id = 2;
    // Various workflow engine state details, potentially including such things as:
    // 
    // - condition that fired to cause this Action to be done (with actual variables substituted);
    // - list of notifications which actually occurred (with all variables substituted);
    // - other workflow engine state.
    // 
    // This specification does not currently define the actual structure or semantics of this field.
    optional ItemStructure wf_details = 3;
}

// Model of a transition in the Instruction State Machine, caused by a careflow step. The attributes document the careflow step as well as the ISM transition.
message IsmTransition {
    // The ISM current state. Coded by openEHR terminology group Instruction states.
    DvCodedText current_state = 1;
    // The ISM transition which occurred to arrive in the current_state. Coded by openEHR terminology group Instruction transitions.
    optional DvCodedText transition = 2;
    // The step in the careflow process which occurred as part of generating this action, e.g. dispense , start_administration. This attribute represents the clinical label for the activity, as opposed to current_state which represents the state machine (ISM) computable form. Defined in archetype.
    optional DvCodedText careflow_step = 3;
    // Optional possibility of adding one or more reasons for this careflow step having been taken. Multiple reasons may occur in medication management for example.
    repeated DvText reason = 4;
}

// +------------------------------------------------------------+
// | DEMOGRAPHICS                                               |
// +------------------------------------------------------------+

// Static type formed by binding generic parameter of VERSIONED_OBJECT<T> to PARTY.
message VersionedParty {
    // Unique identifier of this version container in the form of a UID with no extension. 
    // This id will be the same in all instances of the same container in a distributed environment, 
    // meaning that it can be understood as the uid of the virtual version tree.
    HierObjectId uid = 1;
    // Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
    ObjectRef owner_id = 2;
    // Time of initial creation of this versioned object.
    DvDateTime time_created = 3;
}

// Generic description of a role performed by an Actor. The role corresponds to a competency of the Party. Roles are used to define the responsibilities undertaken by a Party for a purpose. Roles should have credentials qualifying the performer to perform the role.
message Role {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Identities used by the party to identify itself, such as legal name, stage names, aliases, nicknames and so on.
    repeated PartyIdentity identifiers = 7;
    // Contacts for this party.
    repeated Contact contacts = 8;
    // All other details for this Party.
    optional ItemStructure details = 9;
    // References to relationships in which this Party takes part as target.
    repeated LocatableRef reverse_relationships = 10;
    // Relationships in which this Party takes part as source.
    repeated PartyRelationship relationships = 11;
    // Valid time interval for this role.
    optional DvIntervalDvDate time_validity = 12;
    // Reference to Version container of Actor playing the role.
    PartyRef performer = 13;
    // The capabilities of this role.
    repeated Capability capabilities = 14;
}

// Generic description of a relationship between parties.
message PartyRelationship {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // The detailed description of the relationship.
    optional ItemStructure details = 7;
    // Target of relationship.
    PartyRef target = 8;
    // Valid time interval for this relationship.
    optional DvIntervalDvDate time_validity = 9;
    // Source of relationship.
    PartyRef source = 10;
}

// An identity owned by a Party, such as a person name or company name, and which is used by the Party to identify itself. Actual structure is archetyped.
message PartyIdentity {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // The actual identity details, in the form of an archetyped structure.
    ItemStructure details = 7;
}

// Description of a means of contact of a Party. Actual structure is archetyped.
message Contact {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // A set of address alternatives for this contact purpose and time validity combination.
    repeated Address addresses = 7;
    // Valid time interval for this contact descriptor.
    optional DvIntervalDvDate time_validity = 8;
}

// Address of contact, which may be electronic or geographic.
message Address {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Archetypable structured address.
    ItemStructure details = 7;
}

// Capability of a role, such as ehr modifier , health care provider . Capability should be backed up by credentials.
message Capability {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // The qualifications of the performer of the role for this capability. This might include professional qualifications and official identifications such as provider numbers etc.
    ItemStructure credentials = 7;
    // Valid time interval for the credentials of this capability.
    optional DvIntervalDvDate valid_time = 8;
}

// Generic description of persons. Provides a dedicated type to which Person archetypes can be targeted.
message Person {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Identities used by the party to identify itself, such as legal name, stage names, aliases, nicknames and so on.
    repeated PartyIdentity identifiers = 7;
    // Contacts for this party.
    repeated Contact contacts = 8;
    // All other details for this Party.
    optional ItemStructure details = 9;
    // References to relationships in which this Party takes part as target.
    repeated LocatableRef reverse_relationships = 10;
    // Relationships in which this Party takes part as source.
    repeated PartyRelationship relationships = 11;
    // Languages which can be used to communicate with this actor, in preferred order of use (if known, else order irrelevant).
    repeated DvText languages = 12;
    // Identifiers of the Version container for each Role played by this Party.
    repeated PartyRef roles = 13;
}

// Generic description of organisations. An organisation is a legally constituted body whose existence (in general) outlives the existence of parties considered to be part of it.
message Organisation {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Identities used by the party to identify itself, such as legal name, stage names, aliases, nicknames and so on.
    repeated PartyIdentity identifiers = 7;
    // Contacts for this party.
    repeated Contact contacts = 8;
    // All other details for this Party.
    optional ItemStructure details = 9;
    // References to relationships in which this Party takes part as target.
    repeated LocatableRef reverse_relationships = 10;
    // Relationships in which this Party takes part as source.
    repeated PartyRelationship relationships = 11;
    // Languages which can be used to communicate with this actor, in preferred order of use (if known, else order irrelevant).
    repeated DvText languages = 12;
    // Identifiers of the Version container for each Role played by this Party.
    repeated PartyRef roles = 13;
}

// A group is a real world group of parties which is created by another party, usually an organisation, for some specific purpose. A typical clinical example is that of the specialist care team, e.g. cardiology team . The members of the group usually work together.
message Group {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Identities used by the party to identify itself, such as legal name, stage names, aliases, nicknames and so on.
    repeated PartyIdentity identifiers = 7;
    // Contacts for this party.
    repeated Contact contacts = 8;
    // All other details for this Party.
    optional ItemStructure details = 9;
    // References to relationships in which this Party takes part as target.
    repeated LocatableRef reverse_relationships = 10;
    // Relationships in which this Party takes part as source.
    repeated PartyRelationship relationships = 11;
    // Languages which can be used to communicate with this actor, in preferred order of use (if known, else order irrelevant).
    repeated DvText languages = 12;
    // Identifiers of the Version container for each Role played by this Party.
    repeated PartyRef roles = 13;
}

// Generic concept of any kind of agent, including devices, software systems, but not humans or organisations.
message Agent {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Identities used by the party to identify itself, such as legal name, stage names, aliases, nicknames and so on.
    repeated PartyIdentity identifiers = 7;
    // Contacts for this party.
    repeated Contact contacts = 8;
    // All other details for this Party.
    optional ItemStructure details = 9;
    // References to relationships in which this Party takes part as target.
    repeated LocatableRef reverse_relationships = 10;
    // Relationships in which this Party takes part as source.
    repeated PartyRelationship relationships = 11;
    // Languages which can be used to communicate with this actor, in preferred order of use (if known, else order irrelevant).
    repeated DvText languages = 12;
    // Identifiers of the Version container for each Role played by this Party.
    repeated PartyRef roles = 13;
}


// +------------------------------------------------------------+
// | COMMON                                                     |
// +------------------------------------------------------------+

// Archetypes act as the configuration basis for the particular structures of instances defined by the reference model. 
// To enable archetypes to be used to create valid data, key classes in the reference model act as root points for archetyping; accordingly, these classes have the archetype_details attribute set.
//
// An instance of the class ARCHETYPED contains the relevant archetype identification information, allowing generating archetypes to be matched up with data instances.
message Archetyped {
    // Globally unique archetype identifier.
    ArchetypeId archetype_id = 1;
    // Globally unique template identifier, if a template was active at this point in the structure. 
    // Normally, a template would only be used at the top of a top-level structure, but the possibility exists for templates at lower levels.
    optional TemplateId template_id = 2;
    // Version of the openEHR reference model used to create this object. 
    // Expressed in terms of the release version string, e.g. 1.0, 1.2.4.
    string rm_version = 3;
}

// The LINK type defines a logical relationship between two items, such as two ENTRYs or an ENTRY and a COMPOSITION. 
// Links can be used across compositions, and across EHRs. 
// Links can potentially be used between interior (i.e. non archetype root) nodes, although this probably should be prevented in archetypes. 
// Multiple LINKs can be attached to the root object of any archetyped structure to give the effect of a 1N link.
//
// 1:1 and 1:N relationships between archetyped content elements (e.g. ENTRYs) can be expressed by using one, or more than one, respectively, LINKs. 
// Chains of links can be used to see problem threads or other logical groupings of items.
//
// Links should be between archetyped structures only, i.e. between objects representing complete domain concepts because relationships between sub-elements of whole concepts are not necessarily meaningful, and may be downright confusing. 
// Sensible links only exist between whole ENTRYs, SECTIONs, COMPOSITIONs and so on.
message Link {
    // Used to describe the relationship, usually in clinical terms, such as in response to (the relationship between test results and an order), follow-up to and so on. 
    // Such relationships can represent any clinically meaningful connection between pieces of information. 
    // Values for meaning include those described in Annex C, ENV 13606 pt 2 under the categories of generic, documenting and reporting, organisational, clinical, circumstantial, and view management.
    DvText meaning = 1;
    // The type attribute is used to indicate a clinical or domain-level meaning for the kind of link, for example problem or issue. 
    // If type values are designed appropriately, they can be used by the requestor of EHR extracts to categorise links which must be followed and which can be broken when the extract is created.
    DvText type = 2;
    // The logical to object in the link relation, as per the linguistic sense of the meaning attribute.
    DvEhrUri target = 3;
}

// The FEEDER_AUDIT class defines the semantics of an audit trail which is constructed to describe the origin of data that have been transformed into openEHR form and committed to the system.
message FeederAudit {
    // Identifiers used for the item in the originating system, e.g. filler and placer ids.
    repeated DvIdentifier originating_system_item_ids = 1;
    // Identifiers used for the item in the feeder system, where the feeder system is distinct from the originating system.
    repeated DvIdentifier feeder_system_item_ids = 2;
    // Optional inline inclusion of or reference to original content corresponding to the openEHR content at this node. 
    // Typically a URI reference to a document or message in a persistent store associated with the EHR.
    oneof original_content {
        DvMultimedia dv_multimedia = 3;
        DvParsable dv_parsable = 4;
    }
    // Any audit information for the information item from the originating system.
    FeederAuditDetails originating_system_audit = 5;
    // Any audit information for the information item from the feeder system, if different from the originating system.
    FeederAuditDetails feeder_system_audit = 6;
}

// Audit details for any system in a feeder system chain. 
// Audit details here means the general notion of who/where/when the information item to which the audit is attached was created. 
// None of the attributes is defined as mandatory, however, in different scenarios, various combinations of attributes will usually be mandatory. 
// This can be controlled by specifying feeder audit details in legacy archetypes.
message FeederAuditDetails {
    // Identifier of the system which handled the information item. 
    // This is the IT system owned by the organisation legally responsible for handling the data, and at which the data were previously created or passed by an earlier system.
    string system_id = 1;
    // Identifier of the particular site/facility within an organisation which handled the item. 
    // For computability, this identifier needs to be e.g. a PKI identifier which can be included in the identifier list of the PARTY_IDENTIFIED object.
    optional PartyIdentified location = 2;
    // Identifiers for subject of the received information item.
    optional PartyProxy subject = 3;
    // Optional provider(s) who created, committed, forwarded or otherwise handled the item.
    optional PartyProxy provider = 4;
    // Time of handling the item. For an originating system, this will be time of creation, for an intermediate feeder system, this will be a time of accession or other time of handling, where available.
    optional DvDateTime time = 5;
    // Any identifier used in the system such as "interim" , "final" , or numeric versions if available.
    optional string version_id = 6;
    // Optional attribute to carry any custom meta-data. May be archetyped.
    optional ItemStructure other_details = 7;
}

// Abstract concept of a proxy description of a party, including an optional link to data for this party in a demographic or other identity management system. Sub- typed into PARTY_IDENTIFIED and PARTY_SELF.
message PartyProxy {
    oneof proxy {
        PartySelf party_self = 1;
        PartyIdentified party_identified = 2;
        PartyRelated party_related = 3;
    }
}

// Party proxy representing the subject of the record. Used to indicate that the party is the owner of the record. May or may not have external_ref set.
message PartySelf {
    // Optional reference to more detailed demographic or identification information for this party, in an external system.
    optional PartyRef external_ref = 1;
}

// Proxy data for an identified party other than the subject of the record, minimally consisting of human-readable identifier(s), such as name, formal (and possibly computable) identifiers such as NHS number, and an optional link to external data. There must be at least one of name, identifier or external_ref present.
//
// Used to describe parties where only identifiers may be known, and there is no entry at all in the demographic system (or even no demographic system). Typically for health care providers, e.g. name and provider number of an institution.
//
// Should not be used to include patient identifying information.
message PartyIdentified {
    // Optional reference to more detailed demographic or identification information for this party, in an external system.
    optional PartyRef external_ref = 1;
    // Optional human-readable name (in String form).
    optional string name = 2;
    // One or more formal identifiers (possibly computable).
    repeated DvIdentifier identifiers = 3;
}

// Proxy data for an identified party other than the subject of the record, minimally consisting of human-readable identifier(s), such as name, formal (and possibly computable) identifiers such as NHS number, and an optional link to external data. There must be at least one of name, identifier or external_ref present.
//
// Used to describe parties where only identifiers may be known, and there is no entry at all in the demographic system (or even no demographic system). Typically for health care providers, e.g. name and provider number of an institution.
//
// Should not be used to include patient identifying information.
message PartyRelated {
    // Optional reference to more detailed demographic or identification information for this party, in an external system.
    optional PartyRef external_ref = 1;
    // Optional human-readable name (in String form).
    optional string name = 2;
    // One or more formal identifiers (possibly computable).
    repeated DvIdentifier identifiers = 3;
    // Relationship of subject of this ENTRY to the subject of the record. 
    // May be coded. If it is the patient, coded as self.
    DvCodedText relationship = 4;
}

// Model of a participation of a Party (any Actor or Role) in an activity. Used to represent any participation of a Party in some activity, which is not explicitly in the model, e.g. assisting nurse. Can be used to record past or future participations.
//
// Should not be used in place of more permanent relationships between demographic entities.
message Participation {
    // The function of the Party in this participation (note that a given party might participate in more than one way in a particular activity). This attribute should be coded, but cannot be limited to the HL7v3:ParticipationFunction vocabulary, since it is too limited and hospital-oriented.
    DvText function = 1;
    // Optional field for recording the 'mode' of the performer / activity interaction, e.g. present, by telephone, by email etc.
    optional DvCodedText mode = 2;
    // The id and possibly demographic system link of the party participating in the activity.
    PartyProxy performer = 3;
    // The time interval during which the participation took place, if it is used in an observational context (i.e. recording facts about the past); or the intended time interval of the participation when used in future contexts, such as EHR Instructions.
    optional DvIntervalDvDateTime time = 4;
}

// The set of attributes required to document the committal of an information item to a repository.
message AuditDetails {
    // Identifier of the logical EHR system where the change was committed. This is almost always owned by the organisation legally responsible for the EHR, and is distinct from any application, or any hosting infrastructure.
    string system_id = 1;
    // Time of committal of the item.
    DvDateTime time_committed = 2;
    // Type of change. Coded using the openEHR Terminology audit change type group.
    DvCodedText change_type = 3;
    // Reason for committal. This may be used to qualify the value in the change_type field. For example, if the change affects only the EHR directory, this field might be used to indicate 'Folder "episode 2018-02-16" added' or similar.
    DvText description = 4;
    // Identity and optional reference into identity management service, of user who committed the item.
    PartyProxy party_proxy = 5;
}

// Record an attestation of a party (the committer) to item(s) of record content. An attestation is an explicit signing by one healthcare agent of particular content for various particular purposes, including:
// - for authorisation of a controlled substance or procedure (e.g. sectioning of patient under mental health act);
// - witnessing of content by senior clinical professional;
// - indicating acknowledgement of content by intended recipient, e.g. GP who ordered a test result.
message Attestation {
    // Identifier of the logical EHR system where the change was committed. This is almost always owned by the organisation legally responsible for the EHR, and is distinct from any application, or any hosting infrastructure.
    string system_id = 1;
    // Time of committal of the item.
    DvDateTime time_committed = 2;
    // Type of change. Coded using the openEHR Terminology audit change type group.
    DvCodedText change_type = 3;
    // Reason for committal. This may be used to qualify the value in the change_type field. For example, if the change affects only the EHR directory, this field might be used to indicate 'Folder "episode 2018-02-16" added' or similar.
    DvText description = 4;
    // Identity and optional reference into identity management service, of user who committed the item.
    PartyProxy party_proxy = 5;
    // Optional visual representation of content attested e.g. screen image.
    optional DvMultimedia attested_view = 6;
    // Proof of attestation.
    optional string proof = 7;
    // Items attested, expressed as fully qualified runtime paths to the items in question. Although not recommended, these may include fine-grained items which have been attested in some other system. Otherwise it is assumed to be for the entire VERSION with which it is associated.
    repeated DvEhrUri items = 8;
    // Reason of this attestation. Optionally coded by the openEHR Terminology group attestation reason ; includes values like authorisation , witness etc.
    DvText reason = 9;
    // True if this attestation is outstanding; False means it has been completed.
    bool is_pending = 10;
}

// Purpose Defines the notion of a revision history of audit items, each associated with the version for which that audit was committed. The list is in most-recent-first order.
message RevisionHistory {
    repeated RevisionHistoryItem items = 1;
}

// An entry in a revision history, corresponding to a version from a versioned container. Consists of AUDIT_DETAILS instances with revision identifier of the revision to which the AUDIT_DETAILS instance belongs.
message RevisionHistoryItem {
    // Version identifier for this revision.
    ObjectVersionId version_id = 1;
    // The audits for this revision; there will always be at least one commit audit (which may itself be an ATTESTATION), there may also be further attestations.
    repeated AuditDetails audits = 2;
}

// Version-controlled composition abstraction, defined by inheriting VERSIONED_OBJECT<COMPOSITION>.
message VersionedFolder {
    // Unique identifier of this version container in the form of a UID with no extension. 
    // This id will be the same in all instances of the same container in a distributed environment, 
    // meaning that it can be understood as the uid of the virtual version tree.
    HierObjectId uid = 1;
 
 
    // Reference to object to which this version container belongs, e.g. the id of the containing EHR or other relevant owning entity.
    ObjectRef owner_id = 2;
    // Time of initial creation of this versioned object.
    DvDateTime time_created = 3;
}

// The concept of a named folder.
message Folder {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // The list of references to other (usually) versioned objects logically in this folder.
    repeated ObjectRef items = 7;
    // Sub-folders of this FOLDER.
    repeated ObjectRef folders = 8;
    // Archetypable meta-data for FOLDER.
    optional ItemStructure details = 9;
}

// A Version containing locally created content and optional attestations.
message OriginalVersionEhrStatus {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // Stored version of inheritance precursor.
    ObjectVersionId uid = 4;
    // Stored version of inheritance precursor.
    optional ObjectVersionId preceding_version_uid = 5;
    // Identifiers of other versions whose content was merged into this version, if any.
    repeated ObjectVersionId other_version_uids = 6;
    // Lifecycle state of the content item in this version; coded by openEHR vocabulary version lifecycle state.
    DvCodedText lifecycle_state = 7;
    // Set of attestations relating to this version.
    repeated Attestation attestations = 8;
    // Data content of this Version.
    optional EhrStatus data = 9;
}

// A Version containing locally created content and optional attestations.
message OriginalVersionEhrAccess {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // Stored version of inheritance precursor.
    ObjectVersionId uid = 4;
    // Stored version of inheritance precursor.
    optional ObjectVersionId preceding_version_uid = 5;
    // Identifiers of other versions whose content was merged into this version, if any.
    repeated ObjectVersionId other_version_uids = 6;
    // Lifecycle state of the content item in this version; coded by openEHR vocabulary version lifecycle state.
    DvCodedText lifecycle_state = 7;
    // Set of attestations relating to this version.
    repeated Attestation attestations = 8;
    // Data content of this Version.
    optional EhrAccess data = 9;
}

// A Version containing locally created content and optional attestations.
message OriginalVersionComposition {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // Stored version of inheritance precursor.
    ObjectVersionId uid = 4;
    // Stored version of inheritance precursor.
    optional ObjectVersionId preceding_version_uid = 5;
    // Identifiers of other versions whose content was merged into this version, if any.
    repeated ObjectVersionId other_version_uids = 6;
    // Lifecycle state of the content item in this version; coded by openEHR vocabulary version lifecycle state.
    DvCodedText lifecycle_state = 7;
    // Set of attestations relating to this version.
    repeated Attestation attestations = 8;
    // Data content of this Version.
    optional Composition data = 9;
}

// A Version containing locally created content and optional attestations.
message OriginalVersionFolder {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // Stored version of inheritance precursor.
    ObjectVersionId uid = 4;
    // Stored version of inheritance precursor.
    optional ObjectVersionId preceding_version_uid = 5;
    // Identifiers of other versions whose content was merged into this version, if any.
    repeated ObjectVersionId other_version_uids = 6;
    // Lifecycle state of the content item in this version; coded by openEHR vocabulary version lifecycle state.
    DvCodedText lifecycle_state = 7;
    // Set of attestations relating to this version.
    repeated Attestation attestations = 8;
    // Data content of this Version.
    optional Folder data = 9;
}

// A Version containing locally created content and optional attestations.
message OriginalVersionRole {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // Stored version of inheritance precursor.
    ObjectVersionId uid = 4;
    // Stored version of inheritance precursor.
    optional ObjectVersionId preceding_version_uid = 5;
    // Identifiers of other versions whose content was merged into this version, if any.
    repeated ObjectVersionId other_version_uids = 6;
    // Lifecycle state of the content item in this version; coded by openEHR vocabulary version lifecycle state.
    DvCodedText lifecycle_state = 7;
    // Set of attestations relating to this version.
    repeated Attestation attestations = 8;
    // Data content of this Version.
    optional Role data = 9;
}

// A Version containing locally created content and optional attestations.
message OriginalVersionPerson {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // Stored version of inheritance precursor.
    ObjectVersionId uid = 4;
    // Stored version of inheritance precursor.
    optional ObjectVersionId preceding_version_uid = 5;
    // Identifiers of other versions whose content was merged into this version, if any.
    repeated ObjectVersionId other_version_uids = 6;
    // Lifecycle state of the content item in this version; coded by openEHR vocabulary version lifecycle state.
    DvCodedText lifecycle_state = 7;
    // Set of attestations relating to this version.
    repeated Attestation attestations = 8;
    // Data content of this Version.
    optional Person data = 9;
}

// A Version containing locally created content and optional attestations.
message OriginalVersionOrganisation {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // Stored version of inheritance precursor.
    ObjectVersionId uid = 4;
    // Stored version of inheritance precursor.
    optional ObjectVersionId preceding_version_uid = 5;
    // Identifiers of other versions whose content was merged into this version, if any.
    repeated ObjectVersionId other_version_uids = 6;
    // Lifecycle state of the content item in this version; coded by openEHR vocabulary version lifecycle state.
    DvCodedText lifecycle_state = 7;
    // Set of attestations relating to this version.
    repeated Attestation attestations = 8;
    // Data content of this Version.
    optional Organisation data = 9;
}

// A Version containing locally created content and optional attestations.
message OriginalVersionGroup {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // Stored version of inheritance precursor.
    ObjectVersionId uid = 4;
    // Stored version of inheritance precursor.
    optional ObjectVersionId preceding_version_uid = 5;
    // Identifiers of other versions whose content was merged into this version, if any.
    repeated ObjectVersionId other_version_uids = 6;
    // Lifecycle state of the content item in this version; coded by openEHR vocabulary version lifecycle state.
    DvCodedText lifecycle_state = 7;
    // Set of attestations relating to this version.
    repeated Attestation attestations = 8;
    // Data content of this Version.
    optional Group data = 9;
}

// A Version containing locally created content and optional attestations.
message OriginalVersionAgent {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // Stored version of inheritance precursor.
    ObjectVersionId uid = 4;
    // Stored version of inheritance precursor.
    optional ObjectVersionId preceding_version_uid = 5;
    // Identifiers of other versions whose content was merged into this version, if any.
    repeated ObjectVersionId other_version_uids = 6;
    // Lifecycle state of the content item in this version; coded by openEHR vocabulary version lifecycle state.
    DvCodedText lifecycle_state = 7;
    // Set of attestations relating to this version.
    repeated Attestation attestations = 8;
    // Data content of this Version.
    optional Agent data = 9;
}

// Versions whose content is an ORIGINAL_VERSION copied from another location; this class inherits commit_audit and contribution from VERSION<T>, providing imported versions with their own audit trail and Contribution, distinct from those of the imported ORIGINAL_VERSION.
message ImportedVersionEhrStatus {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // The ORIGINAL_VERSION object that was imported.
    OriginalVersionEhrStatus original_version = 4;
}

// Versions whose content is an ORIGINAL_VERSION copied from another location; this class inherits commit_audit and contribution from VERSION<T>, providing imported versions with their own audit trail and Contribution, distinct from those of the imported ORIGINAL_VERSION.
message ImportedVersionEhrAccess {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // The ORIGINAL_VERSION object that was imported.
    OriginalVersionEhrAccess original_version = 4;
}

// Versions whose content is an ORIGINAL_VERSION copied from another location; this class inherits commit_audit and contribution from VERSION<T>, providing imported versions with their own audit trail and Contribution, distinct from those of the imported ORIGINAL_VERSION.
message ImportedVersionComposition {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // The ORIGINAL_VERSION object that was imported.
    OriginalVersionComposition original_version = 4;
}

// Versions whose content is an ORIGINAL_VERSION copied from another location; this class inherits commit_audit and contribution from VERSION<T>, providing imported versions with their own audit trail and Contribution, distinct from those of the imported ORIGINAL_VERSION.
message ImportedVersionFolder {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // The ORIGINAL_VERSION object that was imported.
    OriginalVersionFolder original_version = 4;
}

// Versions whose content is an ORIGINAL_VERSION copied from another location; this class inherits commit_audit and contribution from VERSION<T>, providing imported versions with their own audit trail and Contribution, distinct from those of the imported ORIGINAL_VERSION.
message ImportedVersionRole {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // The ORIGINAL_VERSION object that was imported.
    OriginalVersionRole original_version = 4;
}

// Versions whose content is an ORIGINAL_VERSION copied from another location; this class inherits commit_audit and contribution from VERSION<T>, providing imported versions with their own audit trail and Contribution, distinct from those of the imported ORIGINAL_VERSION.
message ImportedVersionPerson {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // The ORIGINAL_VERSION object that was imported.
    OriginalVersionPerson original_version = 4;
}

// Versions whose content is an ORIGINAL_VERSION copied from another location; this class inherits commit_audit and contribution from VERSION<T>, providing imported versions with their own audit trail and Contribution, distinct from those of the imported ORIGINAL_VERSION.
message ImportedVersionOrganisation {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // The ORIGINAL_VERSION object that was imported.
    OriginalVersionOrganisation original_version = 4;
}

// Versions whose content is an ORIGINAL_VERSION copied from another location; this class inherits commit_audit and contribution from VERSION<T>, providing imported versions with their own audit trail and Contribution, distinct from those of the imported ORIGINAL_VERSION.
message ImportedVersionGroup {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // The ORIGINAL_VERSION object that was imported.
    OriginalVersionGroup original_version = 4;
}

// Versions whose content is an ORIGINAL_VERSION copied from another location; this class inherits commit_audit and contribution from VERSION<T>, providing imported versions with their own audit trail and Contribution, distinct from those of the imported ORIGINAL_VERSION.
message ImportedVersionAgent {
    // Contribution in which this version was added.
    ObjectRef contribution = 1;
    // OpenPGP digital signature or digest of content committed in this Version.
    optional string signature = 2;
    // Audit trail corresponding to the committal of this version to the VERSIONED_OBJECT.
    AuditDetails commit_audit = 3;
    // The ORIGINAL_VERSION object that was imported.
    OriginalVersionAgent original_version = 4;
}

// Documents a Contribution (change set) of one or more versions added to a change-controlled repository.
message Contribution {
    // Unique identifier for this Contribution.
    HierObjectId uid = 1;
    // Set of references to Versions causing changes to this EHR. Each contribution contains a list of versions, which may include paths pointing to any number of versionable items, i.e. items of types such as COMPOSITION and FOLDER.
    repeated ObjectRef versions = 2;
    // Audit trail corresponding to the committal of this Contribution.
    AuditDetails audit = 3;
}

// Class providing details of a natural language translation.
message TranslationDetails {
    // Language of the translation.
    CodePhrase language = 1;
    // Translator name and other demographic details.
    map<string, string> author = 2;
    // Accreditation of translator, usually a national translators registration or association membership id.
    optional string accrediton = 3;
    // Any other meta-data.
    map<string, string> other_details = 4;
}

// Defines the descriptive meta-data of a resource.
message ResourceDescription {
    // Original author of this resource, with all relevant details, including organisation.
    map<string, string> original_author = 1;
    // Other contributors to the resource, probably listed in 'name <email>' form.
    repeated string other_contributors = 2;
    // Lifecycle state of the resource, typically including states such as: initial | submitted | experimental | awaiting_approval | approved | superseded | obsolete.
    string lifecycle_state = 3;
    // URI of package to which this resource belongs.
    optional resource_package_uri = 4;
    // Additional non language-senstive resource meta-data, as a list of name/value pairs.
    map<string, string> other_details = 5;
    // Reference to owning resource.
    AuthoredResource parent_resource = 6;
    // Details of all parts of resource description that are natural language-dependent, keyed by language code.
    map<string, ResourceDescriptionItem> translations = 7;
}

// Language-specific detail of resource description. When a resource is translated for use in another language environment, each RESOURCE_DESCRIPTION_ITEM needs to be copied and translated into the new language.
message ResourceDescriptionItem {
    // The localised language in which the items in this description item are written. Coded from openEHR code set languages.
    CodePhrase language = 1;
    // Purpose of the resource.
    string purpose = 2;
    // Keywords which characterise this resource, used e.g. for indexing and searching.
    repeated string keywords = 3;
    // Description of the uses of the resource, i.e. contexts in which it could be used.
    optional string use = 4;
    // Description of any misuses of the resource, i.e. contexts in which it should not be used.
    optional string misuse = 5;
    // Optional copyright statement for the resource as a knowledge resource.
    optional string copyright = 6;
    // URIs of original clinical document(s) or description of which resource is a formalisation, in the language of this description item; keyed by meaning.
    map<string, string> original_resource_uri = 7;
    // Additional language-senstive resource metadata, as a list of name/value pairs.
    map<string, string> other_details = 8;
}

// +--------------------------------------------------------+
// | Data structures                                        |
// +--------------------------------------------------------+

// Abstract parent class of all spatial data types.
message ItemStructure {
    oneof structure {
        ItemSingle item_single = 1;
        ItemList item_list = 2;
        ItemTable item_table = 3;
        ItemTree item_tree = 4;
    }
}

// Logical single value data structure. 
// Used to represent any data which is logically a single value, such as a persons height or weight.
message ItemSingle {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    //
    Element item = 7;
}

// Logical list data structure, where each item has a value and can be referred to by a name and a positional index in the list. The list may be empty.
// 
// ITEM_LIST is used to represent any data which is logically a list of values, such as blood pressure, most protocols, many blood tests etc.
// 
// Not to be used for time-based lists, which should be represented with the proper temporal class, i.e. HISTORY.
message ItemList {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Physical representation of the list.
    repeated Element items = 7;
}

// Logical relational database style table data structure, in which columns are named and ordered with respect to each other. Implemented using Cluster-per-row encoding. Each row Cluster must have an identical number of Elements, each of which in turn must have identical names and value types in the corresponding positions in each row.
// 
// Some columns may be designated key' columns, containing key data for each row, in the manner of relational tables. This allows row-naming, where each row represents a body site, a blood antigen etc. All values in a column have the same data type.
// 
// Used for representing any data which is logically a table of values, such as blood pressure, most protocols, many blood tests etc.
// 
// Misuse: Not to be used for time-based data, which should be represented with the temporal class HISTORY. The table may be empty.
message ItemTable {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Physical representation of the table as a list of CLUSTERs, each containing the data of one row of the table.
    repeated Cluster rows = 7;
}

// Logical tree data structure. The tree may be empty. Used for representing data which are logically a tree such as audiology results, microbiology results, biochemistry results.
message ItemTree {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // The items comprising the ITEM_TREE. Can include 0 or more CLUSTERs and/or 0 or more individual ELEMENTs.
    repeated ItemTableItem items = 7;

    message ItemTableItem {
        oneof item {
            Cluster cluster = 1;
            Element element = 2;
        }
    }
}

// The grouping variant of ITEM, which may contain further instances of ITEM, in an ordered list.
message Cluster {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Ordered list of items - CLUSTER or ELEMENT objects - under this CLUSTER.
    repeated ClusterItem items = 7;

    message ClusterItem {
        oneof item {
            Cluster cluster = 1;
            Element element = 2;
        }
    }
}

// The leaf variant of ITEM, to which a DATA_VALUE instance is attached.
message Element {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Flavour of null value, e.g. 253|unknown|, 271|no information|, 272|masked|, and 273|not applicable|.
    optional DvCodedText null_flavour = 7;
    // Property representing leaf value object of ELEMENT. In real data, any concrete subtype of DATA_VALUE can be used.
    optional DataValue value = 8;
    // Optional specific reason for null value; if set, null_flavour must be set. 
    // Null reason may apply only to a minority of clinical data, commonly needed in reporting contexts.
    optional DvText null_reason = 9;
}

// Root object of a linear history, i.e. time series structure. This is a generic class whose type parameter must be a descendant of ITEM_STRUCTURE, ensuring that each Event in the events of a given instance is of the same structural type, i.e. ITEM_TREE, ITEM_LIST etc.
// 
// For a periodic series of events, period will be set, and the time of each Event in the History must correspond; i.e. the EVENT.offset must be a multiple of period for each Event. Missing events in a period History are however allowed.
message HistoryItemStructure {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Time origin of this event history. The first event is not necessarily at the origin point.
    DvDateTime origin = 7;
    // Period between samples in this segment if periodic.
    optional DvDuration period = 8;
    // Duration of the entire History; either corresponds to the duration of all the events, and/or the duration represented by the summary, if it exists.
    optional DvDuration duration = 9;
    // Optional summary data that aggregates, organizes, reduces and transforms the event series. This may be a text or image that presents a graphical presentation, or some data that assists with the interpretation of the data.
    optional ItemStructure summary = 10;
    // The events in the series. This attribute is of a generic type whose parameter must be a descendant of ITEM_SUTRUCTURE.
    repeated Event events = 11; 
}

// Defines the abstract notion of a single event in a series. This class is generic, allowing types to be generated which are locked to particular spatial types, such as EVENT<ITEM_LIST>. Subtypes express point or intveral data.
message Event {
    oneof type {
        PointEvent point_event = 1;
        IntervalEvent interval_event = 2;
    }
}

// Defines a single point event in a series.
message PointEvent {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Time of this event. If the width is non-zero, it is the time point of the trailing edge of the event.
    DvDateTime time = 7;
    // Optional state data for this event.
    optional ItemStructure state = 8;
    // The data of this event.
    bytes data = 9;
}

// Defines a single interval event in a series.
message IntervalEvent {
    // Runtime name of this fragment, used to build runtime paths. 
    // This is the term provided via a clinical application or batch process to name this EHR construct: its retention in the EHR faithfully preserves the original label by which this entry was known to end users.
    DvText name = 1;
    // Design-time archetype identifier of this node taken from its generating archetype; used to build archetype paths. 
    // Always in the form of an at-code, e.g. at0005. 
    // This value enables a 'standardised' name for this node to be generated, by referring to the generating archetype local terminology.
    //
    // At an archetype root point, the value of this attribute is always the stringified form of the archetype_id found in the archetype_details object.
    string archetype_node_id = 2;
    // Optional globally unique object identifier for root points of archetyped structures.
    optional UidBasedId uid = 3;
    // Links to other archetyped structures (data whose root object inherits from ARCHETYPED, such as ENTRY, SECTION and so on). 
    // Links may be to structures in other compositions.
    repeated Link links = 4;
    // Details of archetyping used on this node.
    optional Archetyped archetype_details = 5;
    // Audit trail from non-openEHR system of original commit of information forming the content of this node, or from a conversion gateway which has synthesised this node.
    optional FeederAudit feeder_audit = 6;
    // Time of this event. If the width is non-zero, it is the time point of the trailing edge of the event.
    DvDateTime time = 7;
    // Optional state data for this event.
    optional ItemStructure state = 8;
    // The data of this event.
    bytes data = 9;
    // Duration of the time interval during which the values recorded under data are true and, if set, the values recorded under state are true. Void if an instantaneous event.
    DvDuration width = 10;
    // Optional count of original samples to which this event corresponds.
    optional int64 sample_count = 11;
    // Mathematical function of the data of this event, e.g. maximum, mean etc. Coded using openEHR vocabulary event math function. Default value 640|actual|, meaning 'actual value'.
    DvCodedText math_function = 12;
}

// +--------------------------------------------------------+
// | Data types                                             |
// +--------------------------------------------------------+

// Abstract parent of all DV_ data value types. Serves as a common ancestor of all data value types in openEHR models.
message DataValue {
    oneof value {
        DvBoolean dv_boolean = 1;
        DvState dv_state = 2;
        DvIdentifier dv_identifier = 3;
        DvText dv_text = 4;
        DvCodedText dv_coded_text = 5;
        DvParagraph dv_paragraph = 6;
        DvIntervalAny dv_interval_any = 7;
        ReferenceRangeAny dv_reference_range_any = 8;
        DvOrdinal dv_ordinal = 9;
        DvScale dv_scale = 10;
        DvQuantity dv_quantity = 11;
        DvCount dv_count = 12;
        DvProportion dv_proportion = 13;
        DvDate dv_date = 14;
        DvTime dv_time = 15;
        DvDateTime dv_date_time = 16;
        DvDuration dv_duration = 17;
        DvPeriodicTimeSpecification dv_periodic_time_specification = 18;
        DvGeneralTimeSpecification dv_general_time_specification = 19;
        DvMultimedia dv_multimedia = 20;
        DvParsable dv_parsable = 21;
        DvUri dv_uri = 22;
        DvEhrUri dv_ehr_uri = 23;
    }
}

// Items which are truly boolean data, such as true/false or yes/no answers. For such data, it is important to devise the meanings (usually questions in subjective data) carefully, so that the only allowed results are in fact true or false.
//
// Misuse: The DV_BOOLEAN class should not be used as a replacement for naively modelled enumerated types such as male/female etc. Such values should be coded, and in any case the enumeration often has more than two values.
message DvBoolean {
    // Boolean value of this item. Actual values may be language or implementation dependent.
    bool value = 1;
}

// For representing state values which obey a defined state machine, such as a variable representing the states of an instruction or care process.
//
// DV_STATE is expressed as a String but its values are driven by archetype-defined state machines. 
// This provides a powerful way of capturing stateful complex processes in simple data.
message DvState {
    // The state name. 
    // State names are determined by a state/event table defined in archetypes, and coded using openEHR Terminology or local archetype terms, as specified by the archetype.
    DvCodedText value = 1;
    // Indicates whether this state is a terminal state, such as "aborted", "completed" etc. from which no further transitions are possible.
    bool is_terminal = 2;
}

// Type for representing identifiers of real-world entities. 
// Typical identifiers include drivers licence number, social security number, veterans affairs number, prescription id, order id, and so on.
//
// DV_IDENTIFIER is used to represent any identifier of a real thing, issued by some authority or agency.
//
// Misuse: DV_IDENTIFIER is not used to express identifiers generated by the infrastructure to refer to information items; the types OBJECT_ID and OBJECT_REF and subtypes are defined for this purpose.
message DvIdentifier {
    // Optional authority which issues the kind of id used in the id field of this object.
    optional string issuer = 1;
    // Optional organisation that assigned the id to the item being identified.
    optional string assigner = 2;
    // The identifier value. Often structured, according to the definition of the issuing authoritys rules.
    string id = 3;
    // Optional identifier type, such as prescription , or Social Security Number . One day a controlled vocabulary might be possible for this.
    optional string type = 4;
}

// Abstract parent of DV_TEXT and DV_CODED_TEXT, the two text-related data value types.
message DvTextType {
    oneof type {
        DvText dv_text = 1;
        DvCodedText dv_coded_text = 2;
    }
}

// A text item, which may contain any amount of legal characters arranged as e.g. words, sentences etc (i.e. one DV_TEXT may be more than one word). Visual formatting and hyperlinks may be included via markdown.
//
// If the formatting field is set, the value field is affected as follows:
//
// - formatting = "plain": plain text, may contain newlines;
//
// - formatting = "plain_no_newlines": plain text with no newlines;
//
// - formatting = "markdown": text in markdown format; use of CommonMark strongly recommended.
//
// A DV_TEXT can be coded by adding mappings to it.
message DvText {
    // Displayable rendition of the item, regardless of its underlying structure. 
    // For DV_CODED_TEXT, this is the rubric of the complete term as provided by the terminology service.
    string value = 1;
    // DEPRECATED: this field is deprecated; use markdown link/text in the value attribute, and "markdown" as the value of the formatting field.
    // Original usage, prior to RM Release 1.0.4: Optional link sitting behind a section of plain text or coded term item.
    optional DvUri hyperlink = 2;
    // If set, contains one of the following values:
    // 
    // - "plain": use for plain text, possibly containing newlines, but otherwise unformatted (same as Void);
    // - "plain_no_newlines": use for text containing no newlines or other formatting;
    // - "markdown": use for markdown formatted text, strongly recommended in the format of the CommonMark specification.
    // 
    // DEPRECATED usage: contains a string of the form "name:value; name:value" , e.g. "font-weight : bold; font-family : Arial; font-size : 12pt;". Values taken from W3C CSS2 properties lists for background and font .
    optional string formatting = 3;
    // Terms from other terminologies most closely matching this term, typically used where the originator (e.g. pathology lab) of information uses a local terminology but also supplies one or more equivalents from well known terminologies (e.g. LOINC).
    repeated TermMapping mappings = 4;
    // Optional indicator of the localised language in which the value is written. 
    // Coded from openEHR Code Set languages. 
    // Only used when either the text object is in a different language from the enclosing ENTRY, or else the text object is being used outside of an ENTRY or other enclosing structure which indicates the language.
    optional CodePhrase language = 5;
    // Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set character sets. 
    // Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. 
    // This attribute allows for variations from these assumptions.
    optional CodePhrase encoding = 6;
}

// Represents a coded term mapped to a DV_TEXT, and the relative match of the target term with respect to the mapped item. 
// Plain or coded text items may appear in the EHR for which one or mappings in alternative terminologies are required. 
// Mappings are only used to enable computer processing, so they can only be instances of DV_CODED_TEXT.
// 
// Used for adding classification terms (e.g. adding ICD classifiers to SNOMED descriptive terms), or mapping into equivalents in other terminologies (e.g. across nursing vocabularies).
message TermMapping {
    // The relative match of the target term with respect to the mapped text item. Result meanings:
    //
    // - '>': the mapping is to a broader term e.g. orginal text = arbovirus infection , target = viral infection
    // - '=': the mapping is to a (supposedly) equivalent to the original item
    // - '<': the mapping is to a narrower term. e.g. original text = diabetes , mapping = diabetes mellitus .
    // - '?': the kind of mapping is unknown.
    //
    // The first three values are taken from the ISO standards 2788 ( Guide to Establishment and development of monolingual thesauri) and 5964 (Guide to Establishment and development of multilingual thesauri).
    string match = 1;
    // Purpose of the mapping e.g. 'automated data mining', 'billing', 'interoperability'.
    optional DvCodedText purpose = 2;
    // The target term of the mapping.
    CodePhrase target = 3;
}

// A fully coordinated (i.e. all coordination has been performed) term from a terminology service (as distinct from a particular terminology).
message CodePhrase {
    // Identifier of the distinct terminology from which the code_string (or its elements) was extracted.
    TerminologyId terminology_id = 1;
    // The key used by the terminology service to identify a concept or coordination of concepts. 
    // This string is most likely parsable inside the terminology service, but nothing can be assumed about its syntax outside that context.
    string code_string = 2;
    // Optional attribute to carry preferred term corresponding to the code or expression in code_string. 
    // Typical use in integration situations which create mappings, and representing data for which both a (non-preferred) actual term and a preferred term are both required.
    optional string preferred_term = 3;
}

// A text item whose value must be the rubric from a controlled terminology, the key (i.e. the 'code') of which is the defining_code attribute. In other words: a DV_CODED_TEXT is a combination of a CODE_PHRASE (effectively a code) and the rubric of that term, from a terminology service, in the language in which the data were authored.
//
// Since DV_CODED_TEXT is a subtype of DV_TEXT, it can be used in place of it, effectively allowing the type DV_TEXT to mean a text item, which may optionally be coded.
//
// Misuse: If the intention is to represent a term code attached in some way to a fragment of plain text, DV_CODED_TEXT should not be used; instead use a DV_TEXT and a TERM_MAPPING to a CODE_PHRASE.
message DvCodedText {
    // Displayable rendition of the item, regardless of its underlying structure. 
    // For DV_CODED_TEXT, this is the rubric of the complete term as provided by the terminology service.
    string value = 1;
    // DEPRECATED: this field is deprecated; use markdown link/text in the value attribute, and "markdown" as the value of the formatting field.
    // Original usage, prior to RM Release 1.0.4: Optional link sitting behind a section of plain text or coded term item.
    optional DvUri hyperlink = 2;
    // If set, contains one of the following values:
    // 
    // - "plain": use for plain text, possibly containing newlines, but otherwise unformatted (same as Void);
    // - "plain_no_newlines": use for text containing no newlines or other formatting;
    // - "markdown": use for markdown formatted text, strongly recommended in the format of the CommonMark specification.
    // 
    // DEPRECATED usage: contains a string of the form "name:value; name:value" , e.g. "font-weight : bold; font-family : Arial; font-size : 12pt;". Values taken from W3C CSS2 properties lists for background and font .
    optional string formatting = 3;
    // Terms from other terminologies most closely matching this term, typically used where the originator (e.g. pathology lab) of information uses a local terminology but also supplies one or more equivalents from well known terminologies (e.g. LOINC).
    repeated TermMapping mappings = 4;
    // Optional indicator of the localised language in which the value is written. 
    // Coded from openEHR Code Set languages. 
    // Only used when either the text object is in a different language from the enclosing ENTRY, or else the text object is being used outside of an ENTRY or other enclosing structure which indicates the language.
    optional CodePhrase language = 5;
    // Name of character encoding scheme in which this value is encoded. Coded from openEHR Code Set character sets. 
    // Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. 
    // This attribute allows for variations from these assumptions.
    optional CodePhrase encoding = 6;
    // The term of which the value attribute is the textual rendition (i.e. rubric).
    CodePhrase defining_code = 7;
}

// DEPRECATED: use markdown formatted DV_TEXT instead.
// 
// Original definition:
// 
// A logical composite text value consisting of a series of DV_TEXTs, i.e. plain text (optionally coded) potentially with simple formatting, to form a larger tract of prose, which may be interpreted for display purposes as a paragraph.
// 
// DV_PARAGRAPH is the standard way for constructing longer text items in summaries, reports and so on.
message DvParagraph {
    // Items making up the paragraph, each of which is a text item (which may have its own formatting, and/or have hyperlinks).
    repeated DvText items = 1;
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
// 
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
// 
// The basic semantics are derived from the class Interval<T>, described in the support RM.
message DvIntervalAny {
    // Lower bound. lower bound.
    bytes lower = 1;
    // Upper bound. Upper bound.
    bytes upper = 2;
    // lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
    bool lower_unbounded = 3;
    // upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
    bool upper_unbounded = 4;
    // lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
    bool lower_included = 5;
    // upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
    bool upper_included = 6;
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
// 
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
// 
// The basic semantics are derived from the class Interval<T>, described in the support RM.
message DvIntervalInt64 {
    // Lower bound. lower bound.
    int64 lower = 1;
    // Upper bound. Upper bound.
    int64 upper = 2;
    // lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
    bool lower_unbounded = 3;
    // upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
    bool upper_unbounded = 4;
    // lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
    bool lower_included = 5;
    // upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
    bool upper_included = 6;
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
// 
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
// 
// The basic semantics are derived from the class Interval<T>, described in the support RM.
message DvIntervalDvDate {
    // Lower bound. lower bound.
    DvDate lower = 1;
    // Upper bound. Upper bound.
    DvDate upper = 2;
    // lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
    bool lower_unbounded = 3;
    // upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
    bool upper_unbounded = 4;
    // lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
    bool lower_included = 5;
    // upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
    bool upper_included = 6;
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
// 
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
// 
// The basic semantics are derived from the class Interval<T>, described in the support RM.
message DvIntervalDvDateTime {
    // Lower bound. lower bound.
    DvDateTime lower = 1;
    // Upper bound. Upper bound.
    DvDateTime upper = 2;
    // lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
    bool lower_unbounded = 3;
    // upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
    bool upper_unbounded = 4;
    // lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
    bool lower_included = 5;
    // upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
    bool upper_included = 6;
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
// 
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
// 
// The basic semantics are derived from the class Interval<T>, described in the support RM.
message DvIntervalDvDuration {
    // Lower bound. lower bound.
    DvDateTime lower = 1;
    // Upper bound. Upper bound.
    DvDateTime upper = 2;
    // lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
    bool lower_unbounded = 3;
    // upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
    bool upper_unbounded = 4;
    // lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
    bool lower_included = 5;
    // upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
    bool upper_included = 6;
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
// 
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
// 
// The basic semantics are derived from the class Interval<T>, described in the support RM.
message DvIntervalDvQuantity {
    // Lower bound. lower bound.
    DvQuantity lower = 1;
    // Upper bound. Upper bound.
    DvQuantity upper = 2;
    // lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
    bool lower_unbounded = 3;
    // upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
    bool upper_unbounded = 4;
    // lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
    bool lower_included = 5;
    // upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
    bool upper_included = 6;
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
// 
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
// 
// The basic semantics are derived from the class Interval<T>, described in the support RM.
message DvIntervalDvCount {
    // Lower bound. lower bound.
    DvCount lower = 1;
    // Upper bound. Upper bound.
    DvCount upper = 2;
    // lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
    bool lower_unbounded = 3;
    // upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
    bool upper_unbounded = 4;
    // lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
    bool lower_included = 5;
    // upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
    bool upper_included = 6;
}

// Generic class defining an interval (i.e. range) of a comparable type. An interval is a contiguous subrange of a comparable base type. Used to define intervals of dates, times, quantities (whose units match) and so on. The type parameter, T, must be a descendant of the type DV_ORDERED, which is necessary (but not sufficient) for instances to be compared (strictly_comparable is also needed).
// 
// Without the DV_INTERVAL class, quite a few more DV_ classes would be needed to express logical intervals, namely interval versions of all the date/time classes, and of quantity classes. Further, it allows the semantics of intervals to be stated in one place unequivocally, including the conditions for strict comparison.
// 
// The basic semantics are derived from the class Interval<T>, described in the support RM.
message DvIntervalDvProportion {
    // Lower bound. lower bound.
    DvProportion lower = 1;
    // Upper bound. Upper bound.
    DvProportion upper = 2;
    // lower boundary open (i.e. = -infinity). lower boundary open (i.e. = -infinity)
    bool lower_unbounded = 3;
    // upper boundary open (i.e. = +infinity). upper boundary open (i.e. = +infinity)
    bool upper_unbounded = 4;
    // lower boundary value included in range if not lower_unbounded. lower boundary value included in range if not lower_unbounded.
    bool lower_included = 5;
    // upper boundary value included in range if not upper_unbounded. upper boundary value included in range if not upper_unbounded.
    bool upper_included = 6;
}

// Defines a named range to be associated with any DV_ORDERED datum. 
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges. 
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
message ReferenceRangeAny {
    // Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
    DvTextType meaning = 1;
    // The data range for this meaning, e.g. critical etc.
    DvIntervalAny range = 2;
}

// Defines a named range to be associated with any DV_ORDERED datum. 
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges. 
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
message ReferenceRangeInt64 {
    // Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
    DvTextType meaning = 1;
    // The data range for this meaning, e.g. critical etc.
    DvIntervalInt64 range = 2;
}

// Defines a named range to be associated with any DV_ORDERED datum. 
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges. 
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
message ReferenceRangeDvDateTime {
    // Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
    oneof meaning {
        DvText meaning_dv_text = 1;
        DvCodedText meaning_dv_coded_text = 2;
    };
    // The data range for this meaning, e.g. critical etc.
    DvIntervalDvDateTime range = 3;
}

// Defines a named range to be associated with any DV_ORDERED datum. 
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges. 
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
message ReferenceRangeDvDuration {
    // Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
    oneof meaning {
        DvText dv_text = 1;
        DvCodedText dv_coded_text = 2;
    };
    // The data range for this meaning, e.g. critical etc.
    DvIntervalDvDuration range = 3;
}

// Defines a named range to be associated with any DV_ORDERED datum. 
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges. 
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
message ReferenceRangeDvQuantity {
    // Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
    oneof meaning {
        DvText meaning_dv_text = 1;
        DvCodedText meaning_dv_coded_text = 2;
    };
    // The data range for this meaning, e.g. critical etc.
    DvIntervalDvQuantity range = 3;
}

// Defines a named range to be associated with any DV_ORDERED datum. 
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges. 
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
message ReferenceRangeDvCount {
    // Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
    oneof meaning {
        DvText meaning_dv_text = 1;
        DvCodedText meaning_dv_coded_text = 2;
    };
    // The data range for this meaning, e.g. critical etc.
    DvIntervalDvCount range = 3;
}

// Defines a named range to be associated with any DV_ORDERED datum. 
// Each such range is particular to the patient and context, e.g. sex, age, and any other factor which affects ranges. 
// May be used to represent normal, therapeutic, dangerous, critical etc ranges.
message ReferenceRangeDvProportion {
    // Term whose value indicates the meaning of this range, e.g. normal, critical, therapeutic etc.
    oneof meaning {
        DvText meaning_dv_text = 1;
        DvCodedText meaning_dv_coded_text = 2;
    };
    // The data range for this meaning, e.g. critical etc.
    DvIntervalDvProportion range = 3;
}

// A data type that represents integral score values, e.g. pain, Apgar values, etc, where there is:
//
// a) implied ordering, b) no implication that the distance between each value is constant, and c) the total number of values is finite; d) integer values only.
// 
// Note that although the term 'ordinal' in mathematics means natural numbers only, here any integer is allowed, since negative and zero values are often used by medical professionals for values around a neutral point. Examples of sets of ordinal values:
// 
// - -3, -2, -1, 0, 1, 2, 3 reflex response values
// - 0, 1, 2 Apgar values
// 
// This class is used for recording any clinical datum which is customarily recorded using symbolic values. Example: the results on a urinalysis strip, e.g. {neg, trace, +, , +} are used for leucocytes, protein, nitrites etc; for non-haemolysed blood {neg, trace, moderate}; for haemolysed blood {small, moderate, large}.
// 
// For scores or scales that include Real numbers (or might in the future, i.e. not fixed for all time, such as Apgar), use DV_SCALE. DV_SCALE may also be used in future for representing purely Integer-based scales, however, the DV_ORDINAL type should continue to be supported in software implementations in order to accommodate existing data that are instances of this type.
message DvOrdinal {
    // Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
    optional CodePhrase normal_status = 1;
    // Optional normal range.
    optional DvIntervalInt64 normal_range = 2;
    // Optional tagged other reference ranges for this value in its particular measurement context.
    repeated ReferenceRangeInt64 other_reference_ranges = 3;
    // Coded textual representation of this value in the enumeration, which may be strings made from + symbols, or other enumerations of terms such as mild, moderate, severe, or even the same number series as the values, e.g. 1, 2, 3.
    DvCodedText symbol = 4;
    // Value in ordered enumeration of values. Any integer value can be used.
    int64 value = 5;
}

// A data type that represents scale values, where there is:
// 
// a) implied ordering, b) no implication that the distance between each value is constant, and c) the total number of values is finite; d) non-integer values are allowed.
// 
// Example:
// 
// Borg CR 10 Scale
// 
// 0    No Breathlessness at all
// 0.5  Very Very Slight (Just Noticeable)
// 1    Very Slight
// 2    Slight Breathlessness
// 3    Moderate
// ... etc
// 
// For scores that include only Integers, DV_SCALE may also be used, but DV_ORDINAL should be supported to accommodate existing data instances of that type.
message DvScale {
    // Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
    optional CodePhrase normal_status = 1;
    // Optional normal range.
    optional DvIntervalInt64 normal_range = 2;
    // Optional tagged other reference ranges for this value in its particular measurement context.
    repeated ReferenceRangeInt64 other_reference_ranges = 3;
    // Coded textual representation of this value in the scale range, which may be strings made from symbols or other enumerations of terms such as no breathlessness, very very slight, slight breathlessness. Codes come from archetypes.
    // 
    // In some cases, a scale may include values that have no code/symbol. In this case, the symbol will be a DV-CODED_TEXT including the terminology_id and a blank String value for code_string.
    DvCodedText symbol = 4;
    // Real number value of Scale item.
    float value = 5;
}  

// Quantitified type representing scientific quantities, i.e. quantities expressed as a magnitude and units. Units are expressed in the UCUM syntax (Unified Code for Units of Measure (UCUM), by Gunther Schadow and Clement J. McDonald of The Regenstrief Institute) (case-sensitive form) by default, or another system if units_system is set.
// 
// Can also be used for time durations, where it is more convenient to treat these as simply a number of seconds rather than days, months, years (in the latter case, DV_DURATION may be used).
message DvQuantity {
    // Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
    optional CodePhrase normal_status = 1;
    // Optional normal range.
    optional DvIntervalDvQuantity normal_range = 2;
    // Optional tagged other reference ranges for this value in its particular measurement context.
    repeated ReferenceRangeDvQuantity other_reference_ranges = 3;
    // Optional status of magnitude with values:
    // 
    // - "=" : magnitude is a point value
    // - "<" : value is < magnitude
    // - ">" : value is > magnitude
    // - "<=" : value is <= magnitude
    // - ">=" : value is >= magnitude   
    // - "~" : value is approximately magnitude
    // 
    // If not present, assumed meaning is "=" .
    optional string magnitude_status = 4;
    // If True, indicates that when this object was created, accuracy was recorded as a percent value; if False, as an absolute quantity value.
    optional bool accuracy_is_percent = 5;
    // Accuracy of measurement, expressed either as a half-range percent value (accuracy_is_percent = True) or a half-range quantity. A value of 0 means that accuracy is 100%, i.e. no error.
    // 
    // A value of unknown_accuracy_value means that accuracy was not recorded.
    optional float accuracy = 6;
    // Numeric magnitude of the quantity.
    float magnitude = 7;
    // Precision to which the value of the quantity is expressed, in terms of number of decimal places. The value 0 implies an integral quantity. The value -1 implies no limit, i.e. any number of decimal places.
    optional int64 precision = 8;
    // Quantity units, expressed as a code or syntax string from either UCUM (the default) or the units system specified in units_system, when set.
    // 
    // In either case, the value is the code or syntax - normally formed of standard ASCII - which is in principal not the same as the display string, although in simple cases such as 'm' (for meters) it will be.
    // 
    // If the units_display_name field is set, this may be used for display. If not, the implementations must effect the resolution of the units value to a display form locally, e.g. by lookup of reference tables, request to a terminology service etc.
    // 
    // Example values from UCUM: "kg/m^2", mm[Hg]", "ms-1", "km/h".
    string units = 9;
    // Optional field used to specify a units system from which codes in units are defined. Value is a URI identifying a terminology containing units concepts from the (HL7 FHIR terminologies list).
    // 
    // If not set, the UCUM standard (case-sensitive codes) is assumed as the units system.
    optional string units_system = 10;
    // Optional field containing the displayable form of the units field, e.g. 'C'.
    // 
    // If not set, the application environment needs to determine the displayable form.
    optional string units_display_name = 11;
}

// Countable quantities. Used for countable types such as pregnancies and steps (taken by a physiotherapy patient), number of cigarettes smoked in a day.
// 
// Misuse: Not to be used for amounts of physical entities (which all have units).
message DvCount {
    // Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
    optional CodePhrase normal_status = 1;
    // Optional normal range.
    optional DvIntervalDvCount normal_range = 2;
    // Optional tagged other reference ranges for this value in its particular measurement context.
    repeated ReferenceRangeDvCount other_reference_ranges = 3;
    // Optional status of magnitude with values:
    // 
    // - "=" : magnitude is a point value
    // - "<" : value is < magnitude
    // - ">" : value is > magnitude
    // - "<=" : value is <= magnitude
    // - ">=" : value is >= magnitude   
    // - "~" : value is approximately magnitude
    // 
    // If not present, assumed meaning is "=" .
    optional string magnitude_status = 4;
    // If True, indicates that when this object was created, accuracy was recorded as a percent value; if False, as an absolute quantity value.
    optional bool accuracy_is_percent = 5;
    // Accuracy of measurement, expressed either as a half-range percent value (accuracy_is_percent = True) or a half-range quantity. A value of 0 means that accuracy is 100%, i.e. no error.
    // 
    // A value of unknown_accuracy_value means that accuracy was not recorded.
    optional float accuracy = 6;
    // 
    int64 magnitude = 7;
}

// Models a ratio of values, i.e. where the numerator and denominator are both pure numbers. The valid_proportion_kind property of the PROPORTION_KIND class is used to control the type attribute to be one of a defined set.
// 
// Used for recording titers (e.g. 1:128), concentration ratios, e.g. Na:K (unitary denominator), albumin:creatinine ratio, and percentages, e.g. red cell distirbution width (RDW).
// 
// Misuse: Should not be used to represent things like blood pressure which are often written using a '/' character, giving the misleading impression that the item is a ratio, when in fact it is a structured value. Similarly, visual acuity, often written as (e.g.) "6/24" in clinical notes is not a ratio but an ordinal (which includes non-numeric symbols like CF = count fingers etc). Should not be used for formulations.
message DvProportion {
    // Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
    optional CodePhrase normal_status = 1;
    // Optional normal range.
    optional DvIntervalDvProportion normal_range = 2;
    // Optional tagged other reference ranges for this value in its particular measurement context.
    repeated ReferenceRangeDvProportion other_reference_ranges = 3;
    // Optional status of magnitude with values:
    // 
    // - "=" : magnitude is a point value
    // - "<" : value is < magnitude
    // - ">" : value is > magnitude
    // - "<=" : value is <= magnitude
    // - ">=" : value is >= magnitude   
    // - "~" : value is approximately magnitude
    // 
    // If not present, assumed meaning is "=" .
    optional string magnitude_status = 4;
    // If True, indicates that when this object was created, accuracy was recorded as a percent value; if False, as an absolute quantity value.
    optional bool accuracy_is_percent = 5;
    // Accuracy of measurement, expressed either as a half-range percent value (accuracy_is_percent = True) or a half-range quantity. A value of 0 means that accuracy is 100%, i.e. no error.
    // 
    // A value of unknown_accuracy_value means that accuracy was not recorded.
    optional float accuracy = 6;
    // Numerator of ratio
    float numerator = 7;
    // Denominator of ratio.
    float denominator = 8;
    // Indicates semantic type of proportion, including percent, unitary etc.
    int64 type = 9;
    // Indicates semantic type of proportion, including percent, unitary etc.
    optional int64 precision = 10;
}

// Represents an absolute point in time, as measured on the Gregorian calendar, and specified only to the day. Semantics defined by ISO 8601. Used for recording dates in real world time. The partial form is used for approximate birth dates, dates of death, etc.
message DvDate {
    // Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
    optional CodePhrase normal_status = 1;
    // Optional normal range.
    optional DvIntervalDvProportion normal_range = 2;
    // Optional tagged other reference ranges for this value in its particular measurement context.
    repeated ReferenceRangeDvProportion other_reference_ranges = 3;
    // Optional status of magnitude with values:
    // 
    // - "=" : magnitude is a point value
    // - "<" : value is < magnitude
    // - ">" : value is > magnitude
    // - "<=" : value is <= magnitude
    // - ">=" : value is >= magnitude   
    // - "~" : value is approximately magnitude
    // 
    // If not present, assumed meaning is "=" .
    optional string magnitude_status = 4;
    // Time accuracy, expressed as a duration.
    optional DvDuration accuracy = 5;
    // ISO8601 date string.
    string value = 6;
}

// Represents an absolute point in time from an origin usually interpreted as meaning the start of the current day, specified to a fraction of a second. Semantics defined by ISO 8601.
// 
// Used for recording real world times, rather than scientifically measured fine amounts of time. The partial form is used for approximate times of events and substance administrations.
message DvTime {
    // Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
    optional CodePhrase normal_status = 1;
    // Optional normal range.
    optional DvIntervalDvProportion normal_range = 2;
    // Optional tagged other reference ranges for this value in its particular measurement context.
    repeated ReferenceRangeDvProportion other_reference_ranges = 3;
    // Optional status of magnitude with values:
    // 
    // - "=" : magnitude is a point value
    // - "<" : value is < magnitude
    // - ">" : value is > magnitude
    // - "<=" : value is <= magnitude
    // - ">=" : value is >= magnitude   
    // - "~" : value is approximately magnitude
    // 
    // If not present, assumed meaning is "=" .
    optional string magnitude_status = 4;
    // Time accuracy, expressed as a duration.
    optional DvDuration accuracy = 5;
    // ISO8601 time string.
    string value = 6;
}

// Represents an absolute point in time, specified to the second. Semantics defined by ISO 8601.
// 
// Used for recording a precise point in real world time, and for approximate time stamps, e.g. the origin of a HISTORY in an OBSERVATION which is only partially known.
message DvDateTime {
    // Optional normal status indicator of value with respect to normal range for this value. Often included by lab, even if the normal range itself is not included. Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
    optional CodePhrase normal_status = 1;
    // Optional normal range.
    optional DvIntervalDvProportion normal_range = 2;
    // Optional tagged other reference ranges for this value in its particular measurement context.
    repeated ReferenceRangeDvProportion other_reference_ranges = 3;
    // Optional status of magnitude with values:
    // 
    // - "=" : magnitude is a point value
    // - "<" : value is < magnitude
    // - ">" : value is > magnitude
    // - "<=" : value is <= magnitude
    // - ">=" : value is >= magnitude   
    // - "~" : value is approximately magnitude
    // 
    // If not present, assumed meaning is "=" .
    optional string magnitude_status = 4;
    // Time accuracy, expressed as a duration.
    optional DvDuration accuracy = 5;
    // ISO8601 date/time string.
    string value = 6;
}

// Represents a period of time with respect to a notional point in time, which is not specified. 
// A sign may be used to indicate the duration is backwards in time rather than forwards.
//
// Used for recording the duration of something in the real world, particularly when there is a need a) to represent the duration in customary format, i.e. days, hours, minutes etc, and b) if it will be used in computational operations with date/time quantities, i.e. additions, subtractions etc.
//
// Misuse: Durations cannot be used to represent points in time, or intervals of time.
message DvDuration {
    // Optional normal status indicator of value with respect to normal range for this value. 
    // Often included by lab, even if the normal range itself is not included. 
    // Coded by ordinals in series HHH, HH, H, (nothing), L, LL, LLL; see openEHR terminology group normal_status.
    optional CodePhrase normal_status = 1;
    // Optional normal range.
    optional DvIntervalDvDateTime normal_range = 2;
    // Optional tagged other reference ranges for this value in its particular measurement context.
    repeated ReferenceRangeDvDateTime other_reference_ranges = 3;
    // Optional status of magnitude with values:
    //
    // - "=" : magnitude is a point value
    // - "<" : value is < magnitude
    // - ">" : value is > magnitude
    // - "<=" : value is <= magnitude
    // - ">=" : value is >= magnitude
    // - "~" : value is approximately magnitude
    //
    // If not present, assumed meaning is "=" .
    optional string magnitude_status = 4;
    // If True, indicates that when this object was created, accuracy was recorded as a percent value; if False, as an absolute quantity value.
    optional bool accuracy_is_percent = 5;
    // Accuracy of measurement, expressed either as a half-range percent value (accuracy_is_percent = True) or a half-range quantity. A value of 0 means that accuracy is 100%, i.e. no error.
    //
    // A value of unknown_accuracy_value means that accuracy was not recorded.
    optional double accuracy = 6;
    // ISO8601 duration string, including described deviations to support negative values and weeks.
    string value = 7;
}

// Specifies points in time in a general syntax. Based on the HL7v3 GTS data type.
message DvPeriodicTimeSpecification {
    // The specification, in the HL7v3 syntax for PIVL or EIVL types.
    DvParsable value = 1;
}

// Specifies periodic points in time, linked to the calendar (phase-linked), or a real world repeating event, such as breakfast (event-linked). Based on the HL7v3 data types PIVL<T> and EIVL<T>.
// 
// Used in therapeutic prescriptions, expressed as INSTRUCTIONs in the openEHR model.
message DvGeneralTimeSpecification {
    // The specification, in the HL7v3 syntax for PIVL or EIVL types.
    DvParsable value = 1;
}

// A specialisation of DV_ENCAPSULATED for audiovisual and bio-signal types. 
// Includes further metadata relating to multimedia types which are not applicable to other subtypes of DV_ENCAPSULATED.
message DvMultimedia {
    // Name of character encoding scheme in which this value is encoded. 
    // Coded from openEHR Code Set character sets . 
    // Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. 
    // This attribute allows for variations from these assumptions.
    optional CodePhrase charset = 1;
    // Optional indicator of the localised language in which the data is written, if relevant. 
    // Coded from openEHR Code Set languages.
    optional CodePhrase language = 2;
    // Text to display in lieu of multimedia display/replay.
    optional string alternate_text = 3;
    // URI reference to electronic information stored outside the record as a file, database entry etc, if supplied as a reference.
    optional DvUri uri = 4;
    // The actual data found at uri, if supplied inline.
    optional bytes data = 5;
    // Data media type coded from openEHR code set media types (interface for the IANA MIME types code set).
    CodePhrase media_type = 6;
    // Compression type, a coded value from the openEHR Integrity check code set. Void means no compression.
    CodePhrase compression_algorithm = 7;
    // Binary cryptographic integrity checksum.
    optional bytes integrity_check = 8;
    // Type of integrity check, a coded value from the openEHR Integrity check code set.
    optional string integrity_check_algorithm = 9;
    // The thumbnail for this item, if one exists; mainly for graphics formats.
    optional DvMultimedia thumbnail = 10;
    // Original size in bytes of unencoded encapsulated data. I.e. encodings such as base64, hexadecimal etc do not change the value of this attribute.
    int64 size = 11;
}

// Encapsulated data expressed as a parsable String. The internal model of the data item is not described in the openEHR model in common with other encapsulated types, but in this case, the form of the data is assumed to be plaintext, rather than compressed or other types of large binary data.
message DvParsable {
    // Name of character encoding scheme in which this value is encoded. 
    // Coded from openEHR Code Set character sets . 
    // Unicode is the default assumption in openEHR, with UTF-8 being the assumed encoding. 
    // This attribute allows for variations from these assumptions.
    optional CodePhrase charset = 1;
    // Optional indicator of the localised language in which the data is written, if relevant. 
    // Coded from openEHR Code Set languages.
    optional CodePhrase language = 2;
    // The string, which may validly be empty in some syntaxes.
    string value = 3;
    // Name of the formalism, e.g. GLIF 1.0 , Proforma etc.
    string formalism = 4;
}

// A reference to an object which structurally conforms to the Universal Resource Identifier (URI) RFC-3986 standard. 
// The reference is contained in the value attribute, which is a String. 
// So-called 'plain-text URIs' that contain RFC-3986 forbidden characters such as spaces etc, are allowed on the basis that they need to be RFC-3986 encoded prior to use in e.g. REST APIs or other contexts relying on machine-level conformance.
message DvUri {
    // Value of URI as a String. 
    // 'Plain-text' URIs are allowed, enabling better readability, but must be RFC-3986 encoded in use.
    string value = 1;
}

// A DV_EHR_URI is a DV_URI which has the scheme name 'ehr', and which can only reference items in EHRs.
//
// Used to reference items in an EHR, which may be the same as the current EHR (containing this link), or another.
message DvEhrUri {
    // Value of URI as a String. 'Plain-text' URIs are allowed, enabling better readability, but must be RFC-3986 encoded in use.
    string value = 1;
}

// +--------------------------------------------------------+
// | BASE TYPES                                             |
// +--------------------------------------------------------+

// Model of ISOs Object Identifier (oid) as defined by the standard ISO/IEC 8824. Oids are formed from integers separated by dots. Each non-leaf node in an Oid starting from the left corresponds to an assigning authority, and identifies that authoritys namespace, inside which the remaining part of the identifier is locally unique.
message IsoOid {
    // The value of the id.
    string value = 1;
}

// Model of the DCE Universal Unique Identifier or UUID which takes the form of hexadecimal integers separated by hyphens, following the pattern 8-4-4-4-12 as defined by the Open Group, CDE 1.1 Remote Procedure Call specification, Appendix A. Also known as a GUID.
message Uuid {
    // The value of the id.
    string value = 1;
}

// Model of a reverse internet domain, as used to uniquely identify an internet domain. In the form of a dot-separated string in the reverse order of a domain name, specified by IETF RFC 1034.
message InternetId {
    // The value of the id.
    string value = 1;
}

// Ancestor class of identifiers of informational objects. Ids may be completely meaningless, in which case their only job is to refer to something, or may carry some information to do with the identified object.
// 
// Object ids are used inside an object to identify that object. To identify another object in another service, use an OBJECT_REF, or else use a UID for local objects identified by UID. If none of the subtypes is suitable, direct instances of this class may be used.
message ObjectId {
    oneof id {
        HierObjectId hier_object_id = 1;
        ObjectVersionId object_version_id = 2;
        ArchetypeId archetype_id = 3;
        TemplateId template_id = 4;
        TerminologyId terminology_id = 5;
        GenericId generic_id = 6;
    }
}

// Abstract model of UID-based identifiers consisting of a root part and an optional extension; lexical form: root '::' extension.
message UidBasedId {
    oneof id {
        HierObjectId hier_object_id = 1;
        ObjectVersionId object_version_id = 2;
    }
}


// Concrete type corresponding to hierarchical identifiers of the form defined by UID_BASED_ID.
message HierObjectId {
    // Lexical form: root '::' extension.
    string value = 1;
}

// Globally unique identifier for one version of a versioned object
message ObjectVersionId {
    // Lexical form: object_id '::' creating_system_id '::' version_tree_id.
    string value = 1;
}

// Version tree identifier for one version. Lexical form:
// 
// trunk_version [ '.' branch_number '.' branch_version ]
message VersionTreeId {
    // String form of this identifier.
    string value = 1;
}

// Identifier for archetypes. Ideally these would identify globally unique archetypes.
message ArchetypeId {
    // Lexical form: rm_originator '-' rm_name '-' rm_entity '.' concept_name { '-' specialisation }* '.v' number.
    string value = 1;
}

// Identifier for templates
message TemplateId {
    // Lexical form to be determined.
    string value = 1;
}

// Identifier for terminologies such as accessed via a terminology query service. 
// In this class, the value attribute identifies the Terminology in the terminology service, e.g. SNOMED-CT . 
// A terminology is assumed to be in a particular language, which must be explicitly specified.
message TerminologyId {
    // Lexical form: name [ '(' version ')' ].
    string value = 1;
}

// Generic identifier type for identifiers whose format is otherwise unknown to openEHR. 
// Includes an attribute for naming the identification scheme (which may well be local).
message GenericId {
    // Unknown format.
    string value = 1;
    // Name of the scheme to which this identifier conforms. 
    // Ideally this name will be recognisable globally but realistically it may be a local ad hoc scheme whose name is not controlled or standardised in any way.
    string scheme = 2;
}

// Class describing a reference to another object, which may exist locally or be maintained outside the current namespace, e.g. in another service. Services are usually external, e.g. available in a LAN (including on the same host) or the internet via Corba, SOAP, or some other distributed protocol. However, in small systems they may be part of the same executable as the data containing the Id.
message ObjectRef {
    // Namespace to which this identifier belongs in the local system context (and possibly in any other openEHR compliant environment) e.g. terminology , demographic . These names are not yet standardised. Legal values for namespace are:
    //
    // - "local"
    // 
    // - "unknown"
    // 
    // - a string matching the standard regex [a-zA-Z][a-zA-Z0-9_.:\/&?=+-]*.
    // 
    // Note that the first two are just special values of the regex, and will be matched by it.
    string namespace = 1;
    // Name of the class (concrete or abstract) of object to which this identifier type refers, e.g. PARTY, PERSON, GUIDELINE etc. These class names are from the relevant reference model. The type name ANY can be used to indicate that any type is accepted (e.g. if the type is unknown).
    string type = 2;
    // Globally unique id of an object, regardless of where it is stored.
    ObjectId id = 3;
}

// Identifier for parties in a demographic or identity service. There are typically a number of subtypes of the PARTY class, including PERSON, ORGANISATION, etc. Abstract supertypes are allowed if the referenced object is of a type not known by the current implementation of this class (in other words, if the demographic model is changed by the addition of a new PARTY or ACTOR subtypes, valid PARTY_REFs can still be constructed to them).
message PartyRef {
    // Namespace to which this identifier belongs in the local system context (and possibly in any other openEHR compliant environment) e.g. terminology , demographic . These names are not yet standardised. Legal values for namespace are:
    //
    // - "local"
    // 
    // - "unknown"
    // 
    // - a string matching the standard regex [a-zA-Z][a-zA-Z0-9_.:\/&?=+-]*.
    // 
    // Note that the first two are just special values of the regex, and will be matched by it.
    string namespace = 1;
    // Name of the class (concrete or abstract) of object to which this identifier type refers, e.g. PARTY, PERSON, GUIDELINE etc. These class names are from the relevant reference model. The type name ANY can be used to indicate that any type is accepted (e.g. if the type is unknown).
    string type = 2;
    // Globally unique id of an object, regardless of where it is stored.
    ObjectId id = 3;
}

// Reference to a LOCATABLE instance inside the top-level content structure inside a VERSION<T> identified by the id attribute. The path attribute is applied to the object that VERSION.data points to.
message LocatableRef {
    // Namespace to which this identifier belongs in the local system context (and possibly in any other openEHR compliant environment) e.g. terminology , demographic . These names are not yet standardised. Legal values for namespace are:
    //
    // - "local"
    // 
    // - "unknown"
    // 
    // - a string matching the standard regex [a-zA-Z][a-zA-Z0-9_.:\/&?=+-]*.
    // 
    // Note that the first two are just special values of the regex, and will be matched by it.
    string namespace = 1;
    // Name of the class (concrete or abstract) of object to which this identifier type refers, e.g. PARTY, PERSON, GUIDELINE etc. These class names are from the relevant reference model. The type name ANY can be used to indicate that any type is accepted (e.g. if the type is unknown).
    string type = 2;
    // Globally unique id of an object, regardless of where it is stored.
    UidBasedId id = 3;
    // The path to an instance in question, as an absolute path with respect to the object found at VERSION.data. An empty path means that the object referred to by id being specified.
    optional string path = 4;
}